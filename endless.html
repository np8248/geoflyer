<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>GeoFlyer</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{overflow:hidden;touch-action:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
body{background:#000;display:flex;justify-content:center;align-items:center;height:100vh;font-family:'Arial',sans-serif;position:relative}
canvas{display:block;touch-action:none}
#ui{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:flex;flex-direction:column;align-items:center}
#pbar-wrap{position:absolute;top:10px;width:280px;height:7px;background:rgba(0,0,0,0.5);border-radius:4px;overflow:hidden}
#pbar{height:100%;width:0%;background:#0f0;border-radius:4px;transition:width 0.1s}
#ptext{position:absolute;top:20px;color:#fff;font-size:13px;text-shadow:1px 1px 2px #000}
#scoreTxt{position:absolute;top:10px;left:20px;color:#0f0;font-size:18px;font-weight:bold;text-shadow:0 0 8px #0f0;pointer-events:none}
#highTxt{position:absolute;top:32px;left:20px;color:#ff0;font-size:12px;text-shadow:1px 1px 2px #000;pointer-events:none}
#coinTxt{position:absolute;top:10px;right:100px;color:#ffd600;font-size:16px;font-weight:bold;text-shadow:0 0 8px #ffd600;pointer-events:none}
#pauseBtn{position:absolute;top:8px;right:12px;pointer-events:auto;cursor:pointer;color:#fff;font-size:22px;text-shadow:1px 1px 3px #000;opacity:0.7;user-select:none}
#pauseBtn:hover{opacity:1}
#homeBtn{position:absolute;top:10px;left:50%;transform:translateX(-50%);pointer-events:auto;cursor:pointer;color:#fff;font-size:13px;text-shadow:1px 1px 3px #000;opacity:0.6;user-select:none;padding:3px 10px;border-radius:4px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);text-decoration:none;transition:all 0.15s}
#homeBtn:hover{opacity:1;border-color:#0af;color:#0af}
.scr{position:absolute;top:0;left:0;width:100%;height:100%;display:none;flex-direction:column;justify-content:center;align-items:center;background:rgba(0,0,0,0.75);pointer-events:auto;cursor:pointer}
#startS{display:flex}
#startS h1{color:#fff;font-size:40px;text-shadow:0 0 20px #0af,0 0 40px #07f;margin-bottom:8px}
#startS h2{color:#adf;font-size:20px;margin-bottom:24px}
.scr p{color:#ccc;font-size:16px}.scr .sub{color:#8af;font-size:13px;margin-top:6px}
#deathS h2{color:#f44;font-size:34px;text-shadow:0 0 20px #f00;margin-bottom:12px}
#deathS{cursor:default}
.death-btns{display:flex;gap:16px;margin-top:20px}
.death-btn{pointer-events:auto;padding:12px 32px;border-radius:10px;font-size:16px;font-family:'Arial',sans-serif;cursor:pointer;border:2px solid;transition:all 0.15s;font-weight:bold}
.retry-btn{background:rgba(0,255,100,0.12);border-color:#0f0;color:#0f0;text-shadow:0 0 8px #0f0}
.retry-btn:hover{background:rgba(0,255,100,0.25);transform:translateY(-2px);box-shadow:0 4px 20px rgba(0,255,100,0.3)}
.menu-btn{background:rgba(0,170,255,0.12);border-color:#0af;color:#0af;text-shadow:0 0 8px #0af}
.menu-btn:hover{background:rgba(0,170,255,0.25);transform:translateY(-2px);box-shadow:0 4px 20px rgba(0,170,255,0.3)}
#winS h2{color:#0f0;font-size:34px;text-shadow:0 0 20px #0f0;margin-bottom:12px}
#pauseS h2{color:#fff;font-size:34px;text-shadow:0 0 20px #0af;margin-bottom:12px}
.retry-btn:active{background:rgba(0,255,100,0.25);transform:translateY(-2px);box-shadow:0 4px 20px rgba(0,255,100,0.3)}
.menu-btn:active{background:rgba(0,170,255,0.25);transform:translateY(-2px);box-shadow:0 4px 20px rgba(0,170,255,0.3)}
#pauseBtn:active,#homeBtn:active{opacity:1}
@media(max-width:700px){
  #scoreTxt{font-size:15px;top:max(10px,env(safe-area-inset-top))}
  #highTxt{font-size:11px;top:max(30px,calc(env(safe-area-inset-top) + 20px))}
  #coinTxt{font-size:14px;right:50px;top:max(10px,env(safe-area-inset-top))}
  #pauseBtn{font-size:28px;padding:6px 10px;top:max(8px,env(safe-area-inset-top));right:16px}
  #homeBtn{font-size:14px;padding:6px 14px;top:max(10px,env(safe-area-inset-top))}
  #startS h1{font-size:28px}
  #startS h2{font-size:16px}
  .scr p{font-size:14px}
  .scr .sub{font-size:11px;max-width:90vw;text-align:center}
  .death-btn{padding:14px 28px;font-size:15px}
  #deathS h2{font-size:28px}
  #pbar-wrap{width:200px}
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div id="scoreTxt">0m</div>
  <div id="highTxt">Best: 0m</div>
  <div id="coinTxt">&#9733; 0</div>
  <a id="homeBtn" href="index.html">&#9664; MENU</a>
  <div id="pauseBtn" onclick="togglePause()">| |</div>
</div>
<div class="scr" id="startS" onclick="onInput()">
  <h1>GEOFLYER</h1>
  <h2>Endless Mode</h2>
  <p>Click or press Space to play</p>
  <p class="sub">Hold to fly up, release to fall &bull; Survive as long as you can! &bull; P / Esc = Pause</p>
</div>
<div class="scr" id="deathS">
  <h2>YOU CRASHED!</h2>
  <p id="deathP"></p>
  <p id="deathRank" style="display:none;color:#0af;font-size:16px;margin-top:8px;"></p>
  <div id="deathUsername" style="display:none;margin-top:10px;text-align:center;">
    <p style="color:#8af;font-size:14px;margin-bottom:6px;">Enter a name for the leaderboard:</p>
    <div style="display:flex;gap:8px;justify-content:center;align-items:center;">
      <input id="deathUsernameInput" type="text" maxlength="20" placeholder="Username..."
        style="background:rgba(10,10,40,0.85);border:2px solid #2a2a60;border-radius:8px;color:#fff;font-size:14px;padding:6px 12px;width:160px;font-family:'Arial',sans-serif;outline:none;"
        onfocus="this.style.borderColor='#0af'" onblur="this.style.borderColor='#2a2a60'">
      <button onclick="saveDeathUsername()" style="background:rgba(0,170,255,0.12);border:2px solid #0af;border-radius:8px;color:#0af;font-size:13px;padding:6px 14px;cursor:pointer;font-family:'Arial',sans-serif;pointer-events:auto;">Submit</button>
    </div>
  </div>
  <div class="death-btns">
    <button class="death-btn retry-btn" onclick="onInput()">&#9654; Play Again</button>
    <button class="death-btn menu-btn" onclick="window.location.href='index.html'">&#9664; Menu</button>
  </div>
</div>
<div class="scr" id="winS" onclick="onInput()">
  <h2>LEVEL COMPLETE!</h2>
  <p id="winI"></p>
  <p style="margin-top:12px">Click or press Space to replay</p>
</div>
<div class="scr" id="pauseS" onclick="togglePause()">
  <h2>PAUSED</h2>
  <p>Click or press P / Escape to resume</p>
</div>


<script>
const C = document.getElementById('game');
const X = C.getContext('2d');
const W = 960, H = 540;

function resize() {
  const s = Math.min(innerWidth / W, innerHeight / H);
  C.width = W; C.height = H;
  C.style.width = (W * s) + 'px';
  C.style.height = (H * s) + 'px';
}
resize();
addEventListener('resize', resize);

// ================================================================
// CONSTANTS
// ================================================================
const T = 40;
const GRAV = 0.85;
const JUMP = -11.8;
let SPEED = 5.0;
const GND = T * 11;
let SHIP_UP = -0.5;
let SHIP_GRAV = 0.3;
let SHIP_MAX = 7;
let PSIZ = T - 4;
const G = Math.floor(GND / T);
let shipSkin = parseInt(localStorage.getItem('geoflyer-skin') || '0');
const SKIN_COUNT = 12;
const SKIN_ORDER = [2, 3, 0, 1, 7, 4, 5, 6, 8, 9, 10, 11];
let trailStyle = parseInt(localStorage.getItem('geoflyer-trail') || '0');
const TRAIL_NAMES = ['None','Smoke','Fire','Rainbow','Candy','Snow','Skin Echo','Laser','Champion'];
const TRAIL_COLORS = [
  null, // none
  ['#888888','#777777','#666666','#555555'], // smoke
  ['#ff2200','#ff6600','#ff9900','#ffcc00'], // fire
  ['#ff0000','#ff8800','#ffff00','#33ff33','#0099ff','#6633ff'], // rainbow
  ['#ff44aa','#ff88cc','#88ddff','#ffee44'], // candy
  ['#aaddff','#cceeff','#ffffff','#ddeeff'], // snow
  null, // skin echo (special)
  null, // laser (special - uses shadowBlur glow)
  ['#ffd600','#ffee66','#ffffff'] // champion
];
const FREE_TRAILS = [0, 1];
function getUnlockedTrails() {
  try { return JSON.parse(localStorage.getItem('geoflyer-unlocked-trails') || '[0,1]'); }
  catch(e) { return [0,1]; }
}
function isTrailUnlocked(idx) { return FREE_TRAILS.includes(idx) || getUnlockedTrails().includes(idx); }
if (!isTrailUnlocked(trailStyle)) { trailStyle = 0; localStorage.setItem('geoflyer-trail', '0'); }


// ================================================================
// SPACING (not used in endless - kept for compat)
// ================================================================
function sx(x) { return x; }

// ================================================================
// STATE
// ================================================================
let state = 'start', camX = 0, att = 1, particles = [];
let coinsGot = 0;
let activePowerUps = {};    // { bamboozled: endTime, invincible: endTime, magnet: endTime }
const POWERUP_DURATION = 10000; // 10 seconds
function hasPU(type) { return activePowerUps[type] && Date.now() < activePowerUps[type]; }
let powerUpGenX = 60;       // next tile x for power-up generation
let powerUpFlash = 0;
let powerUpFlashName = '';
let powerUpFlashType = '';
let bamboozledCount = 0;  // times bamboozled this run (for achievement)
let laserTrail = []; const LASER_MAX_POINTS = 600;
let persistentCoins = parseInt(localStorage.getItem('geoflyer-coins') || '0');
const FREE_SKINS = [0,1,2,3];
const SKIN_COSTS = {4:50, 5:100, 6:150, 7:200, 8:250};
function getUnlockedSkins() {
  try { return JSON.parse(localStorage.getItem('geoflyer-unlocked') || '[0,1,2,3]'); }
  catch(e) { return [0,1,2,3]; }
}
function isSkinUnlocked(idx) { return FREE_SKINS.includes(idx) || getUnlockedSkins().includes(idx); }
// Achievement system
const ACHIEVEMENTS = {
  'survive-1000m': { name: 'Marathon Flyer', desc: 'Survive 1000 meters', reward: 'skin', rewardSkin: 9 },
  'die-invincible': { name: 'Ironic Death', desc: 'Die while invincible power-up is active', reward: 'trail', rewardTrail: 2 },
  'collect-100': { name: 'Coin Hoarder', desc: 'Collect 100 coins in one run', reward: 'trail', rewardTrail: 3 },
  'collect-25-run': { name: 'Sweet Tooth', desc: 'Collect 25 coins in one run', reward: 'trail', rewardTrail: 4 },
  'survive-2000m': { name: 'Blizzard Runner', desc: 'Survive 2000 meters', reward: 'trail', rewardTrail: 5 },
  'loyal-10': { name: 'Loyal Flyer', desc: 'Play same skin 10 games in a row (300m+ each)', reward: 'trail', rewardTrail: 6 },
  'bamboozled-3': { name: 'Bamboozle Survivor', desc: 'Get bamboozled 3 times in one run and survive', reward: 'trail', rewardTrail: 7 },
  'leaderboard-1': { name: 'Champion', desc: 'Reach #1 on the leaderboard', reward: 'skin', rewardSkin: 10 }
};
function getAchievements() {
  try { return JSON.parse(localStorage.getItem('geoflyer-achievements') || '{}'); }
  catch(e) { return {}; }
}
function hasAchievement(id) { return !!getAchievements()[id]; }
function grantAchievement(id) {
  const achs = getAchievements();
  if (achs[id]) return;
  achs[id] = { time: Date.now() };
  localStorage.setItem('geoflyer-achievements', JSON.stringify(achs));
  const ach = ACHIEVEMENTS[id];
  if (ach && ach.reward === 'skin') {
    const unlocked = getUnlockedSkins();
    if (!unlocked.includes(ach.rewardSkin)) {
      unlocked.push(ach.rewardSkin);
      localStorage.setItem('geoflyer-unlocked', JSON.stringify(unlocked));
    }
  }
  if (ach && ach.reward === 'trail') {
    const unlocked = getUnlockedTrails();
    if (!unlocked.includes(ach.rewardTrail)) {
      unlocked.push(ach.rewardTrail);
      localStorage.setItem('geoflyer-unlocked-trails', JSON.stringify(unlocked));
    }
  }
  showAchievementPopup(ach);
}
let achPopup = null;
function showAchievementPopup(ach) {
  if (achPopup) achPopup.remove();
  achPopup = document.createElement('div');
  achPopup.style.cssText = 'position:fixed;top:60px;left:50%;transform:translateX(-50%);background:rgba(10,10,40,0.92);border:2px solid #ffd600;border-radius:12px;padding:14px 28px;color:#ffd600;font-size:16px;font-weight:bold;text-shadow:0 0 8px #ffd600;z-index:500;pointer-events:none;transition:opacity 0.5s;';
  achPopup.textContent = 'Achievement Unlocked: ' + ach.name + '!';
  document.body.appendChild(achPopup);
  setTimeout(() => { achPopup.style.opacity = '0'; }, 2500);
  setTimeout(() => { achPopup.remove(); achPopup = null; }, 3200);
}
// Validate shipSkin on load — reset to 0 if locked
if (!isSkinUnlocked(shipSkin)) { shipSkin = 0; localStorage.setItem('geoflyer-skin', '0'); }
let inputDown = false, inputTap = false, holdJump = false;
let canRestart = false;
let godMode = false;
let showHitboxes = false;
let P = { x: 120, y: GND/2 - PSIZ/2, vy: 0, rot: 0, onG: false, dead: false, ship: true };

// ================================================================
// INPUT
// ================================================================
function onInput() {
  if (state === 'start') { hide('startS'); startGame(); }
  else if (state === 'dead' && canRestart) { hide('deathS'); att++; startGame(); }
  else if (state === 'won' && canRestart) { hide('winS'); att = 1; startGame(); }
}

function toggleGod() {
  godMode = !godMode;
}

function forceRestart() {
  hide('deathS'); hide('winS'); hide('pauseS'); hide('startS');
  att++;
  startGame();
}

function toggleHitboxes() {
  showHitboxes = !showHitboxes;
}

function togglePause() {
  if (state === 'playing') {
    state = 'paused';
    show('pauseS');
  } else if (state === 'paused') {
    state = 'playing';
    hide('pauseS');
  }
}

function hide(id) { document.getElementById(id).style.display = 'none'; }
function show(id) { document.getElementById(id).style.display = 'flex'; }

function keyOn(id) { const el = document.getElementById(id); if (el) el.classList.add('active'); }
function keyOff(id) { const el = document.getElementById(id); if (el) el.classList.remove('active'); }
function keyFlash(id) { keyOn(id); setTimeout(() => keyOff(id), 150); }

document.addEventListener('keydown', e => {
  if (e.code === 'Escape') { keyFlash('k-esc'); e.preventDefault(); togglePause(); return; }
  if (e.key === 'p' || e.key === 'P') { keyFlash('k-p'); e.preventDefault(); togglePause(); return; }
  if (e.key === 'g' || e.key === 'G') { keyFlash('k-g'); toggleGod(); return; }
  if (e.key === 'r' || e.key === 'R') { keyFlash('k-r'); forceRestart(); return; }
  if (e.key === 'h' || e.key === 'H') { keyFlash('k-h'); toggleHitboxes(); return; }
  if (e.key === 'c' || e.key === 'C') { keyFlash('k-c'); let pos = SKIN_ORDER.indexOf(shipSkin); let tries = 0; do { pos = (pos + 1) % SKIN_ORDER.length; tries++; } while (!isSkinUnlocked(SKIN_ORDER[pos]) && tries < SKIN_ORDER.length); shipSkin = SKIN_ORDER[pos]; localStorage.setItem('geoflyer-skin', shipSkin); return; }
  if (e.key === 'm' || e.key === 'M') { keyFlash('k-m'); window.location.href = 'index.html'; return; }
  if (e.code === 'Space') { keyOn('k-space'); e.preventDefault(); inputDown = true; holdJump = true; inputTap = true; onInput(); }
  if (e.code === 'ArrowUp') { keyOn('k-up'); e.preventDefault(); inputDown = true; holdJump = true; inputTap = true; onInput(); }
  if (e.key === 'w' || e.key === 'W') { keyOn('k-w'); e.preventDefault(); inputDown = true; holdJump = true; inputTap = true; onInput(); }
});
document.addEventListener('keyup', e => {
  if (e.code === 'Space') keyOff('k-space');
  if (e.code === 'ArrowUp') keyOff('k-up');
  if (e.key === 'w' || e.key === 'W') keyOff('k-w');
  if (['Space','ArrowUp'].includes(e.code) || e.key === 'w' || e.key === 'W') { inputDown = false; holdJump = false; }
});
C.addEventListener('mousedown', () => { keyOn('k-mouse'); inputDown = true; holdJump = true; inputTap = true; onInput(); });
C.addEventListener('mouseup', () => { keyOff('k-mouse'); inputDown = false; holdJump = false; });
C.addEventListener('touchstart', e => { e.preventDefault(); inputDown = true; holdJump = true; inputTap = true; onInput(); }, {passive:false});
C.addEventListener('touchend', e => { e.preventDefault(); inputDown = false; holdJump = false; }, {passive:false});
// Fullscreen touch — catch taps outside canvas (e.g. on UI overlay areas)
document.addEventListener('touchstart', e => {
  if (e.target === C || e.target.closest('.death-btn') || e.target.closest('#pauseBtn') || e.target.closest('#homeBtn')) return;
  if (state === 'start' || state === 'playing') { e.preventDefault(); inputDown = true; holdJump = true; inputTap = true; onInput(); }
}, {passive:false});
document.addEventListener('touchend', e => {
  if (e.target === C || e.target.closest('.death-btn') || e.target.closest('#pauseBtn') || e.target.closest('#homeBtn')) return;
  if (state === 'playing' || state === 'start') { e.preventDefault(); inputDown = false; holdJump = false; }
}, {passive:false});
document.addEventListener('touchmove', e => { e.preventDefault(); }, {passive:false});

// ================================================================
// LEVEL OBJECTS - helpers apply sx() spacing
// ================================================================
const L = [];
const blockSet = new Set();
function addObj(t, tx, ty, extra) {
  const key = tx + ',' + ty;
  // Track block positions; skip duplicates
  if (t === 'B') {
    if (blockSet.has(key)) return;
    blockSet.add(key);
  }
  // Delete spikes that overlap with a block
  if (t === 'S' || t === 'SS' || t === 'CS' || t === 'SCS') {
    if (blockSet.has(key)) return;
  }
  L.push({ t, x: tx, y: ty, ...(extra||{}) });
}

// Single-tile objects: scale x with sx()
function blk(tx, ty) { addObj('B', sx(tx), ty); }
function spike(tx) { addObj('S', sx(tx), G - 1); }
function spikeAt(tx, ty) { addObj('S', sx(tx), ty); }
function cspike(tx) { addObj('CS', sx(tx), 0); }
function cspikeAt(tx, ty) { addObj('CS', sx(tx), ty); }
function deco(tx, ty) { addObj('D', sx(tx), ty); }
function pad(tx, ty) { addObj('P', sx(tx), ty); }
function shipPortal(tx) { addObj('PO', sx(tx), G - 3); }
function cubePortal(tx) { addObj('PC', sx(tx), G - 3); }
function hangSpike(tx, ty) { addObj('HG', sx(tx), ty); }
function fire(tx) { addObj('FR', sx(tx), G - 1); }
function smiley(tx, ty) { addObj('SM', sx(tx), ty); }
function coin(tx, ty) { addObj('CN', sx(tx), ty); }

// Multi-tile: scale START position, keep internal tiles consecutive
function plat(tx, ty, w) { const st = sx(tx); for (let i = 0; i < w; i++) addObj('B', st + i, ty); }
function pillar(tx, h) { const st = sx(tx); for (let i = 0; i < h; i++) addObj('B', st, G - 1 - i); }
function decoPlat(tx, ty, w) { const st = sx(tx); for (let i = 0; i < w; i++) addObj('D', st + i, ty); }

// ================================================================
// PROCEDURAL LEVEL GENERATOR - Endless Mode
// ================================================================
let genX = 20; // next tile x to generate at
let gndSpikeX = 0; // next tile x for ground spike generation
let ceilGenX = 0; // next tile x for ceiling block generation
let ceilSpikeX = 0; // next tile x for ceiling spike generation
let ceilBumpX = 0; // next tile x for ceiling bump generation
let coinGenX = 30; // next tile x for coin line generation
let highScore = 0;
try { highScore = parseInt(localStorage.getItem('endless-high') || '0'); } catch(e) {}

let pendingDeathScore = 0; // stored for deathUsername flow

// Dev unlock: grant everything to np8248
(function() {
  const u = (localStorage.getItem('geoflyer-username') || '').trim().toLowerCase();
  if (u === 'np8248') {
    const allSkins = [0,1,2,3,4,5,6,7,8,9,10,11];
    localStorage.setItem('geoflyer-unlocked', JSON.stringify(allSkins));
    const allTrails = [0,1,2,3,4,5,6,7,8];
    localStorage.setItem('geoflyer-unlocked-trails', JSON.stringify(allTrails));
  }
})();

// Retroactive check: if player is already #1 on load, grant Champion rewards
(async function checkLeaderboardUnlock() {
  try {
    const username = localStorage.getItem('geoflyer-username');
    if (!username || hasAchievement('leaderboard-1')) return;
    const res = await fetch('/api/leaderboard');
    const data = await res.json();
    if (data.scores && data.scores.length > 0 && data.scores[0].name.toLowerCase() === username.trim().toLowerCase()) {
      grantAchievement('leaderboard-1');
      const trails = getUnlockedTrails();
      if (!trails.includes(8)) { trails.push(8); localStorage.setItem('geoflyer-unlocked-trails', JSON.stringify(trails)); }
    }
  } catch(e) {}
})();

// Check if player has been granted capybara skin (skin 11)
(async function checkCapybaraGrant() {
  try {
    const username = localStorage.getItem('geoflyer-username');
    if (!username) return;
    const res = await fetch('/api/grant');
    const data = await res.json();
    if (data.granted && data.granted.includes(username.trim().toLowerCase())) {
      const skins = JSON.parse(localStorage.getItem('geoflyer-unlocked') || '[0,1,2,3]');
      if (!skins.includes(11)) { skins.push(11); localStorage.setItem('geoflyer-unlocked', JSON.stringify(skins)); }
    }
  } catch(e) {}
})();

async function submitScore(name, score) {
  try {
    const res = await fetch('/api/leaderboard', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({name, score: Math.floor(score)})
    });
    const data = await res.json();
    if (data.rank) {
      document.getElementById('deathRank').textContent = '#' + data.rank + ' on leaderboard!';
      document.getElementById('deathRank').style.display = 'block';
      if (data.rank === 1) {
        grantAchievement('leaderboard-1');
        const trails = getUnlockedTrails();
        if (!trails.includes(8)) { trails.push(8); localStorage.setItem('geoflyer-unlocked-trails', JSON.stringify(trails)); }
      }
    }
  } catch(e) { /* silently fail — game still works offline */ }
}

function saveDeathUsername() {
  const input = document.getElementById('deathUsernameInput');
  const val = input.value.trim();
  if (val.length < 1 || val.length > 20 || !/^[a-zA-Z0-9 ]+$/.test(val)) {
    input.style.borderColor = '#f44';
    setTimeout(() => { input.style.borderColor = '#2a2a60'; }, 1500);
    return;
  }
  localStorage.setItem('geoflyer-username', val);
  document.getElementById('deathUsername').style.display = 'none';
  submitScore(val, pendingDeathScore);
}

// Ceiling occupies rows 0-2; floor obstacles must leave at least 4 rows of gap below row 3
const MAX_FLOOR_H = G - 3 - 4; // = 4 for G=11

// Difficulty ramps with distance: 0 = easy, 1 = hardest
function diff() { return Math.min(1, camX / 40000); }

// Seeded-ish random per generation call
function rng() { return Math.random(); }
function rngInt(min, max) { return min + Math.floor(rng() * (max - min + 1)); }
function pick(arr) { return arr[Math.floor(rng() * arr.length)]; }
// Gap after each obstacle - more breathing room
function gap() { const d = diff(); return rngInt(Math.max(4, Math.floor(6 - d * 2)), Math.max(6, Math.floor(10 - d * 4))); }

// Helper: fill a rectangle of blocks
function blockRect(x, y, w, h) {
  for (let i = 0; i < w; i++)
    for (let j = 0; j < h; j++)
      addObj('B', x + i, y + j);
}
// Helper: add stepped columns to sides of a floor structure (pyramid-style edges)
// Structure sits on ground (bottom = G-1), top at topRow. Steps go outward+down.
function floorSteps(x, topRow, w) {
  const structH = G - topRow;
  const stepsL = Math.min(rngInt(1, 3), structH - 1);
  const stepsR = Math.min(rngInt(1, 3), structH - 1);
  for (let s = 1; s <= stepsL; s++) {
    const colH = structH - s;
    if (colH <= 0) break;
    blockRect(x - s, G - colH, 1, colH);
  }
  for (let s = 1; s <= stepsR; s++) {
    const colH = structH - s;
    if (colH <= 0) break;
    blockRect(x + w - 1 + s, G - colH, 1, colH);
  }
}
// Helper: add stepped columns to sides of a ceiling structure (inverted pyramid edges)
// Structure starts at topRow with height h. Steps go outward+up.
function ceilSteps(x, topRow, w, h) {
  const stepsL = Math.min(rngInt(1, 3), h - 1);
  const stepsR = Math.min(rngInt(1, 3), h - 1);
  for (let s = 1; s <= stepsL; s++) {
    const colH = h - s;
    if (colH <= 0) break;
    blockRect(x - s, topRow, 1, colH);
  }
  for (let s = 1; s <= stepsR; s++) {
    const colH = h - s;
    if (colH <= 0) break;
    blockRect(x + w - 1 + s, topRow, 1, colH);
  }
}
// Helper: build a pyramid from floor — cx is center tile, h is height
function buildPyramid(cx, h) {
  for (let row = 0; row < h; row++) {
    const rowW = 1 + row * 2;
    const startX = cx - row;
    for (let i = 0; i < rowW; i++)
      addObj('B', startX + i, G - h + row);
  }
  return 1 + (h - 1) * 2; // returns base width
}
// Helper: build an inverted pyramid from ceiling — cx is center tile, h is height
function buildInvertPyramid(cx, h) {
  for (let row = 0; row < h; row++) {
    const rowW = 1 + row * 2;
    const startX = cx - row;
    for (let i = 0; i < rowW; i++)
      addObj('B', startX + i, h - 1 - row);
  }
  return 1 + (h - 1) * 2;
}
// Helper: row of mixed spikes on top of blocks (pointing up) — randomly big or small
function spikeRowAbove(x, y, w) {
  for (let i = 0; i < w; i++) addObj(rng() < 0.5 ? 'S' : 'SS', x + i, y);
}
// Helper: row of mixed spikes below blocks (pointing down) — randomly big or small
function spikeRowBelow(x, y, w) {
  for (let i = 0; i < w; i++) addObj(rng() < 0.5 ? 'CS' : 'SCS', x + i, y);
}
// Helper: row of ONLY small spikes (for tight facing gaps)
function smallSpikeRowAbove(x, y, w) {
  for (let i = 0; i < w; i++) addObj('SS', x + i, y);
}
function smallSpikeRowBelow(x, y, w) {
  for (let i = 0; i < w; i++) addObj('SCS', x + i, y);
}

// ========== OBSTACLE PATTERNS ==========
// Rule: ALL spikes must be directly adjacent to a block surface. No floating spikes.
const patterns = [

  // --- PYRAMID: triangular block mass from floor, spikes on top ---
  function pyramidFloor() {
    const h = rngInt(2, Math.min(MAX_FLOOR_H, 4 + Math.floor(diff())));
    if (h >= G - 3) return 0;
    const cx = genX + h;
    const baseW = buildPyramid(cx, h);
    // spikes along all exposed step edges
    for (let row = 0; row < h; row++) {
      const spikeY = G - h + row - 1;
      if (spikeY < 0) continue;
      if (row === 0) {
        addObj(rng() < 0.5 ? 'S' : 'SS', cx, spikeY);
      } else {
        addObj(rng() < 0.5 ? 'S' : 'SS', cx - row, spikeY);
        addObj(rng() < 0.5 ? 'S' : 'SS', cx + row, spikeY);
      }
    }
    return baseW + gap();
  },

  // --- INVERTED PYRAMID: triangular mass from ceiling ---
  function pyramidCeiling() {
    const h = rngInt(2, 4 + Math.floor(diff()));
    if (h >= G - 3) return 0;
    const cx = genX + h;
    const baseW = buildInvertPyramid(cx, h);
    // spikes along all exposed step edges (inverted)
    for (let row = 0; row < h; row++) {
      const spikeY = h - row;
      if (row === 0) {
        addObj(rng() < 0.5 ? 'CS' : 'SCS', cx, spikeY);
      } else {
        addObj(rng() < 0.5 ? 'CS' : 'SCS', cx - row, spikeY);
        addObj(rng() < 0.5 ? 'CS' : 'SCS', cx + row, spikeY);
      }
    }
    return baseW + gap();
  },

  // --- PILLAR: column from floor with stepped edges, fly over ---
  function floorPillar() {
    const w = rngInt(2, 3);
    const h = rngInt(2, Math.min(MAX_FLOOR_H, 5 + Math.floor(diff())));
    if (h >= G - 3) return 0;
    blockRect(genX, G - h, w, h);
    floorSteps(genX, G - h, w);
    spikeRowAbove(genX, G - h - 1, w);
    return w + gap();
  },

  // --- PILLAR: column from ceiling with stepped edges, fly under ---
  function ceilingPillar() {
    const w = rngInt(2, 3);
    const h = rngInt(3, 5 + Math.floor(diff()));
    if (h >= G - 3) return 0;
    blockRect(genX, 0, w, h);
    ceilSteps(genX, 0, w, h);
    spikeRowBelow(genX, h, w);
    return w + gap();
  },

  // --- GATE: floor + ceiling pillars with stepped edges, gap to fly through ---
  function gatePillar() {
    const w = rngInt(2, 4);
    const floorH = rngInt(2, 3 + Math.floor(diff()));
    const ceilH = rngInt(2, 3 + Math.floor(diff()));
    const openRows = G - floorH - ceilH;
    if (openRows < 4) return 0;
    blockRect(genX, G - floorH, w, floorH);
    floorSteps(genX, G - floorH, w);
    blockRect(genX, 0, w, ceilH);
    ceilSteps(genX, 0, w, ceilH);
    smallSpikeRowAbove(genX, G - floorH - 1, w);
    smallSpikeRowBelow(genX, ceilH, w);
    return w + gap();
  },

  // --- ALT PILLARS: floor then ceiling pillar — weave up and down ---
  function altPillars() {
    const w = rngInt(2, 3);
    const spacing = rngInt(5, 8);
    const fh = rngInt(2, Math.min(MAX_FLOOR_H, 5 + Math.floor(diff())));
    const ch = rngInt(3, 5 + Math.floor(diff()));
    if (fh >= G - 3 || ch >= G - 3) return 0;
    blockRect(genX, G - fh, w, fh);
    floorSteps(genX, G - fh, w);
    spikeRowAbove(genX, G - fh - 1, w);
    const cx = genX + w + spacing;
    blockRect(cx, 0, w, ch);
    ceilSteps(cx, 0, w, ch);
    spikeRowBelow(cx, ch, w);
    return w * 2 + spacing + gap();
  },

  // --- ENCLOSED TUNNEL: floor + ceiling corridor ---
  function enclosedTunnel() {
    const w = rngInt(6, 12);
    const floorH = rngInt(2, 3);
    const ceilH = rngInt(2, 3);
    const openRows = G - floorH - ceilH;
    if (openRows < 4) return 0;
    blockRect(genX, 0, w, ceilH);
    blockRect(genX, G - floorH, w, floorH);
    smallSpikeRowBelow(genX, ceilH, w);
    smallSpikeRowAbove(genX, G - floorH - 1, w);
    return w + gap();
  },

  // --- TUNNEL WITH PILLAR: corridor with a stepped pillar inside ---
  function tunnelWithPillar() {
    const w = rngInt(10, 14);
    const floorH = rngInt(2, 3);
    const ceilH = rngInt(2, 3);
    const openRows = G - floorH - ceilH;
    if (openRows < 6) return 0;
    blockRect(genX, 0, w, ceilH);
    blockRect(genX, G - floorH, w, floorH);
    const pillarX = genX + rngInt(4, w - 5);
    const pillarW = 2;
    if (rng() < 0.5) {
      const ph = rngInt(2, openRows - 4);
      blockRect(pillarX, G - floorH - ph, pillarW, ph);
      floorSteps(pillarX, G - floorH - ph, pillarW);
      spikeRowAbove(pillarX, G - floorH - ph - 1, pillarW);
    } else {
      const ph = rngInt(2, openRows - 4);
      blockRect(pillarX, ceilH, pillarW, ph);
      ceilSteps(pillarX, ceilH, pillarW, ph);
      spikeRowBelow(pillarX, ceilH + ph, pillarW);
    }
    return w + gap();
  },

  // --- STAIRCASE UP: ascending steps from floor ---
  function staircaseUp() {
    const steps = rngInt(2, Math.min(MAX_FLOOR_H, 4));
    const stepW = rngInt(2, 3);
    let ox = 0;
    for (let s = 0; s < steps; s++) {
      const h = s + 1;
      if (h > MAX_FLOOR_H) break;
      blockRect(genX + ox, G - h, stepW, h);
      spikeRowAbove(genX + ox, G - h - 1, stepW);
      ox += stepW;
    }
    return ox + gap();
  },

  // --- STAIRCASE DOWN: descending steps from ceiling ---
  function staircaseDown() {
    const steps = rngInt(3, 5);
    const stepW = rngInt(2, 3);
    let ox = 0;
    for (let s = 0; s < steps; s++) {
      const h = s + 1;
      if (h >= G - 3) break;
      blockRect(genX + ox, 0, stepW, h);
      spikeRowBelow(genX + ox, h, stepW);
      ox += stepW;
    }
    return ox + gap();
  },

  // --- WALL WITH WINDOW: solid wall with stepped edges, opening to fly through ---
  function wallWithWindow() {
    const w = rngInt(2, 4);
    const winH = 4;
    const winRow = rngInt(3, G - winH - 2);
    for (let i = 0; i < w; i++) {
      for (let j = 0; j < winRow; j++) addObj('B', genX + i, j);
      for (let j = winRow + winH; j < G; j++) addObj('B', genX + i, j);
    }
    // stepped edges on the wall sections
    ceilSteps(genX, 0, w, winRow);
    floorSteps(genX, winRow + winH, w);
    smallSpikeRowBelow(genX, winRow, w);
    smallSpikeRowAbove(genX, winRow + winH - 1, w);
    return w + gap();
  },

  // --- L-SHAPE FLOOR: base with a stepped tower on one side ---
  function lShapeFloor() {
    const baseW = rngInt(4, 6);
    const baseH = rngInt(1, 2);
    const towerW = 2;
    const towerH = rngInt(2, Math.min(MAX_FLOOR_H - baseH, 4 + Math.floor(diff())));
    if (towerH < 1 || baseH + towerH >= G - 3) return 0;
    const towerSide = rng() < 0.5 ? 0 : baseW - towerW;
    blockRect(genX, G - baseH, baseW, baseH);
    blockRect(genX + towerSide, G - baseH - towerH, towerW, towerH);
    floorSteps(genX + towerSide, G - baseH - towerH, towerW);
    for (let i = 0; i < baseW; i++) {
      if (i >= towerSide && i < towerSide + towerW) continue;
      addObj(rng() < 0.5 ? 'S' : 'SS', genX + i, G - baseH - 1);
    }
    spikeRowAbove(genX + towerSide, G - baseH - towerH - 1, towerW);
    return baseW + gap();
  },

  // --- L-SHAPE CEILING: ceiling base with stepped tower hanging down ---
  function lShapeCeiling() {
    const baseW = rngInt(4, 6);
    const baseH = rngInt(1, 2);
    const towerW = 2;
    const towerH = rngInt(2, 4 + Math.floor(diff()));
    if (baseH + towerH >= G - 3) return 0;
    const towerSide = rng() < 0.5 ? 0 : baseW - towerW;
    blockRect(genX, 0, baseW, baseH);
    blockRect(genX + towerSide, baseH, towerW, towerH);
    ceilSteps(genX + towerSide, baseH, towerW, towerH);
    for (let i = 0; i < baseW; i++) {
      if (i >= towerSide && i < towerSide + towerW) continue;
      addObj(rng() < 0.5 ? 'CS' : 'SCS', genX + i, baseH);
    }
    spikeRowBelow(genX + towerSide, baseH + towerH, towerW);
    return baseW + gap();
  },

  // --- NARROWING CORRIDOR: enclosed path that gets tighter ---
  function narrowingCorridor() {
    const w = rngInt(6, 10);
    const startGap = Math.min(G - 2, rngInt(7, 9));
    const endGap = Math.max(5, startGap - rngInt(1, 2 + Math.floor(diff())));
    for (let i = 0; i < w; i++) {
      const t = i / (w - 1);
      const gapH = Math.round(startGap + (endGap - startGap) * t);
      const ceilH = Math.floor((G - gapH) / 2);
      const floorH = G - gapH - ceilH;
      for (let j = 0; j < ceilH; j++) addObj('B', genX + i, j);
      for (let j = 0; j < floorH; j++) addObj('B', genX + i, G - 1 - j);
    }
    return w + gap();
  },

  // --- U-SHAPE: walls with stepped edges and spiked floor ---
  function uShape() {
    const w = rngInt(6, 10);
    const wallH = rngInt(2, Math.min(MAX_FLOOR_H, 4 + Math.floor(diff())));
    if (wallH >= G - 3) return 0;
    const wallW = 2;
    blockRect(genX, G - wallH, wallW, wallH);
    floorSteps(genX, G - wallH, wallW);
    spikeRowAbove(genX, G - wallH - 1, wallW);
    blockRect(genX + w - wallW, G - wallH, wallW, wallH);
    floorSteps(genX + w - wallW, G - wallH, wallW);
    spikeRowAbove(genX + w - wallW, G - wallH - 1, wallW);
    blockRect(genX + wallW, G - 1, w - wallW * 2, 1);
    spikeRowAbove(genX + wallW, G - 2, w - wallW * 2);
    return w + gap();
  },

  // --- SHELF ROOM: corridor with a shelf creating upper/lower paths ---
  function shelfRoom() {
    const w = rngInt(8, 12);
    const floorH = rngInt(2, 3);
    const ceilH = rngInt(2, 3);
    const openRows = G - floorH - ceilH;
    if (openRows < 6) return 0;
    blockRect(genX, 0, w, ceilH);
    blockRect(genX, G - floorH, w, floorH);
    const shelfGap = rngInt(2, 3);
    const shelfW = w - shelfGap * 2;
    if (shelfW < 3) return 0;
    const shelfRow = ceilH + Math.floor(openRows / 2);
    blockRect(genX + shelfGap, shelfRow, shelfW, 1);
    spikeRowAbove(genX + shelfGap, shelfRow - 1, shelfW);
    spikeRowBelow(genX + shelfGap, shelfRow + 1, shelfW);
    return w + gap();
  },

  // --- DOUBLE STAIRCASE: floor up + ceiling down, diamond shape ---
  function doubleStaircase() {
    if (diff() < 0.15) return 0;
    const steps = rngInt(2, 3);
    const stepW = 2;
    let ox = 0;
    for (let s = 0; s < steps; s++) {
      const floorH = s + 1;
      const ceilH = s + 1;
      if (floorH + ceilH >= G - 4) break;
      blockRect(genX + ox, G - floorH, stepW, floorH);
      blockRect(genX + ox, 0, stepW, ceilH);
      ox += stepW;
    }
    for (let s = steps - 1; s >= 0; s--) {
      const floorH = s + 1;
      const ceilH = s + 1;
      blockRect(genX + ox, G - floorH, stepW, floorH);
      blockRect(genX + ox, 0, stepW, ceilH);
      ox += stepW;
    }
    return ox + gap();
  },

  // --- OVERHANG: ceiling block with floor base, stepped edges ---
  function overhang() {
    const w = rngInt(5, 8);
    const floorH = rngInt(2, 3);
    const ceilH = rngInt(2, 3);
    const openRows = G - floorH - ceilH;
    if (openRows < 5) return 0;
    blockRect(genX, G - floorH, w, floorH);
    const ceilW = rngInt(3, w - 2);
    const ceilOff = rng() < 0.5 ? 0 : w - ceilW;
    blockRect(genX + ceilOff, 0, ceilW, ceilH);
    ceilSteps(genX + ceilOff, 0, ceilW, ceilH);
    smallSpikeRowBelow(genX + ceilOff, ceilH, ceilW);
    smallSpikeRowAbove(genX, G - floorH - 1, w);
    return w + gap();
  },

  // --- ENCLOSED ROOM: walls with openings at different heights ---
  function enclosedRoom() {
    if (diff() < 0.1) return 0;
    const roomW = rngInt(8, 12);
    const wallW = 2;
    const floorH = rngInt(2, 3);
    const ceilH = rngInt(2, 3);
    blockRect(genX, 0, roomW, ceilH);
    blockRect(genX, G - floorH, roomW, floorH);
    const entryOpen = rngInt(ceilH + 1, G - floorH - 4);
    for (let j = ceilH; j < G - floorH; j++) {
      if (j >= entryOpen && j < entryOpen + 3) continue;
      for (let i = 0; i < wallW; i++) addObj('B', genX + i, j);
    }
    const exitOpen = rngInt(ceilH + 1, G - floorH - 4);
    for (let j = ceilH; j < G - floorH; j++) {
      if (j >= exitOpen && j < exitOpen + 3) continue;
      for (let i = 0; i < wallW; i++) addObj('B', genX + roomW - wallW + i, j);
    }
    return roomW + gap();
  },

  // --- TIGHT CORRIDOR: long enclosed section with bumps ---
  function tightCorridor() {
    const w = rngInt(10, 16);
    const ceilH = rngInt(3, 4);
    const floorH = rngInt(2, 3);
    const openRows = G - ceilH - floorH;
    if (openRows < 4) return 0;
    blockRect(genX, 0, w, ceilH);
    blockRect(genX, G - floorH, w, floorH);
    // Add a bump from ceiling or floor midway
    const bumpX = genX + rngInt(3, w - 4);
    const bumpW = rngInt(2, 3);
    if (rng() < 0.5) {
      const bh = rngInt(1, 2);
      if (ceilH + bh + 3 < G - floorH) {
        blockRect(bumpX, ceilH, bumpW, bh);
        spikeRowBelow(bumpX, ceilH + bh, bumpW);
      }
    } else {
      const bh = rngInt(1, 2);
      if (floorH + bh + 3 < G - ceilH) {
        blockRect(bumpX, G - floorH - bh, bumpW, bh);
        spikeRowAbove(bumpX, G - floorH - bh - 1, bumpW);
      }
    }
    smallSpikeRowBelow(genX, ceilH, w);
    smallSpikeRowAbove(genX, G - floorH - 1, w);
    return w + gap();
  },

  // --- BIG STEPPED MASS: large structure with staircase edge, like GD screenshot ---
  function steppedMass() {
    const baseW = rngInt(6, 10);
    const maxH = rngInt(3, Math.min(MAX_FLOOR_H, 6 + Math.floor(diff())));
    if (maxH >= G - 3) return 0;
    const fromFloor = rng() < 0.5;
    const stairSide = rng() < 0.5 ? 'left' : 'right';
    // build stepped structure: one side is flat, other steps down
    for (let col = 0; col < baseW; col++) {
      let colH;
      if (stairSide === 'left') {
        colH = Math.min(maxH, col + 1); // grows from left
      } else {
        colH = Math.min(maxH, baseW - col); // grows from right
      }
      if (fromFloor) {
        blockRect(genX + col, G - colH, 1, colH);
      } else {
        blockRect(genX + col, 0, 1, colH);
      }
    }
    // spikes along the top/bottom edge
    if (fromFloor) {
      for (let col = 0; col < baseW; col++) {
        const colH = stairSide === 'left' ? Math.min(maxH, col + 1) : Math.min(maxH, baseW - col);
        addObj(rng() < 0.5 ? 'S' : 'SS', genX + col, G - colH - 1);
      }
    } else {
      for (let col = 0; col < baseW; col++) {
        const colH = stairSide === 'left' ? Math.min(maxH, col + 1) : Math.min(maxH, baseW - col);
        addObj(rng() < 0.5 ? 'CS' : 'SCS', genX + col, colH);
      }
    }
    return baseW + gap();
  }
];
// Boost tunnel-type patterns for enclosed feel (indices: 4=gate, 6=enclosedTunnel, 7=tunnelWithPillar, 10=wallWithWindow, 13=narrowingCorridor, 18=enclosedRoom, 20=tightCorridor)
[4, 6, 7, 10, 13, 18, 20].forEach(i => { if (patterns[i]) patterns.push(patterns[i]); });

function generateAhead() {
  const aheadTile = Math.floor((camX + W + T * 10) / T);
  let safety = 0;
  while (genX < aheadTile && safety < 50) {
    safety++;
    const pat = pick(patterns);
    const used = pat();
    if (used > 0) genX += used;
    else genX += Math.max(3, gap());
  }
  // Tunnel ceiling: 2 blocks thick (rows 0-1) + spikes at row 2
  while (ceilGenX < aheadTile) {
    addObj('B', ceilGenX, 0);
    addObj('B', ceilGenX, 1);
    ceilGenX++;
  }
  // Ceiling spikes — skip if column has any floor blocks in upper half (would block path)
  while (ceilSpikeX < aheadTile) {
    let blocked = false;
    for (let r = 3; r <= 6; r++) {
      if (blockSet.has(ceilSpikeX + ',' + r)) { blocked = true; break; }
    }
    if (!blocked && rng() < 0.4) {
      addObj(rng() < 0.5 ? 'CS' : 'SCS', ceilSpikeX, 2);
    }
    ceilSpikeX++;
  }
  // Ceiling bumps — skip if column has floor blocks nearby
  while (ceilBumpX < aheadTile) {
    let blocked = false;
    for (let r = 3; r <= 6; r++) {
      if (blockSet.has(ceilBumpX + ',' + r)) { blocked = true; break; }
    }
    if (!blocked && rng() < 0.08) {
      const bw = rngInt(1, 2);
      for (let i = 0; i < bw; i++) addObj('B', ceilBumpX + i, 2);
      ceilBumpX += bw + rngInt(6, 12);
    }
    ceilBumpX++;
  }
  // Scatter ground spikes — skip if column already has floor blocks above ground
  while (gndSpikeX < aheadTile) {
    const hasBlock = blockSet.has(gndSpikeX + ',' + (G - 1)) || blockSet.has(gndSpikeX + ',' + (G - 2));
    if (!hasBlock && rng() < 0.35) {
      addObj(rng() < 0.5 ? 'S' : 'SS', gndSpikeX, G - 1);
    }
    gndSpikeX++;
  }
  // Coins — random single coins or small groups, less frequent
  while (coinGenX < aheadTile) {
    if (rng() < 0.06) {
      // Pick a row in the safe flying zone (rows 4-8)
      const row = rngInt(4, G - 3);
      const count = 3; // always spawn coins in groups of 3
      // Check columns are clear of blocks and spikes
      let clear = true;
      for (let i = 0; i < count; i++) {
        const cx = coinGenX + i;
        for (let r = row - 1; r <= row + 1; r++) {
          if (blockSet.has(cx + ',' + r)) { clear = false; break; }
        }
        if (!clear) break;
      }
      if (clear) {
        for (let i = 0; i < count; i++) {
          addObj('CN', coinGenX + i, row);
        }
        coinGenX += count + rngInt(25, 50);
        continue;
      }
    }
    coinGenX++;
  }
  // Power-up spawning
  while (powerUpGenX < aheadTile) {
    if (rng() < 0.02) {
      const row = rngInt(4, G - 3);
      let clear = true;
      for (let r = row - 1; r <= row + 1; r++) {
        if (blockSet.has(powerUpGenX + ',' + r)) { clear = false; break; }
      }
      if (clear) {
        const types = ['bamboozled', 'invincible', 'magnet'];
        addObj('PU', powerUpGenX, row, { puType: types[Math.floor(rng() * 3)] });
        powerUpGenX += rngInt(80, 150);
        continue;
      }
    }
    powerUpGenX++;
  }
}

function cleanupBehind() {
  const behindTile = Math.floor((camX - T * 5) / T);
  while (L.length > 0 && L[0].x < behindTile) {
    const obj = L.shift();
    if (obj.t === 'B') blockSet.delete(obj.x + ',' + obj.y);
  }
}

// ================================================================
// COLOR ZONES - cycle through colors every 3000px
// ================================================================
const zoneList = [
  { bg:'#0a0e3a', bgR:'#101878', bgB:'#1a2494', gnd:'#04061a', gl:'#4488ff',
    sk:'#1a1a2e', skIn:'#2a2a4e', skB:'#111128', nm:'blue' },
  { bg:'#7a0040', bgR:'#a00058', bgB:'#c00078', gnd:'#1a0008', gl:'#ff4090',
    sk:'#fff', skIn:'#ddd', skB:'#ccc', nm:'pink' },
  { bg:'#2a0060', bgR:'#3c0090', bgB:'#5000b0', gnd:'#0a0018', gl:'#aa66ff',
    sk:'#fff', skIn:'#ddd', skB:'#ccc', nm:'purple' },
  { bg:'#3a0000', bgR:'#580000', bgB:'#780000', gnd:'#0a0000', gl:'#ff2020',
    sk:'#fff', skIn:'#ddd', skB:'#ccc', nm:'red' },
  { bg:'#3a0040', bgR:'#580068', bgB:'#780090', gnd:'#140018', gl:'#e040fb',
    sk:'#fff', skIn:'#ddd', skB:'#ccc', nm:'magenta' }
];
const ZONE_LEN = 1200;
const ZONE_TRANSITION = 250;

function hexToRGB(hex) {
  hex = hex.replace('#', '');
  if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
  return [parseInt(hex.substring(0,2),16), parseInt(hex.substring(2,4),16), parseInt(hex.substring(4,6),16)];
}
function rgbToHex(r,g,b) {
  return '#' + ((1<<24)+(Math.round(r)<<16)+(Math.round(g)<<8)+Math.round(b)).toString(16).slice(1);
}
function lerpColor(hex1, hex2, t) {
  const [r1,g1,b1] = hexToRGB(hex1);
  const [r2,g2,b2] = hexToRGB(hex2);
  return rgbToHex(r1+(r2-r1)*t, g1+(g2-g1)*t, b1+(b2-b1)*t);
}

function getZone(px) {
  const idx = Math.floor(px / ZONE_LEN) % zoneList.length;
  const posInZone = px - Math.floor(px / ZONE_LEN) * ZONE_LEN;
  const distToEnd = ZONE_LEN - posInZone;
  if (distToEnd > ZONE_TRANSITION) return zoneList[idx];
  const nextIdx = (idx + 1) % zoneList.length;
  const t = 1 - distToEnd / ZONE_TRANSITION;
  const a = zoneList[idx], b = zoneList[nextIdx];
  return {
    bg: lerpColor(a.bg, b.bg, t),
    bgR: lerpColor(a.bgR, b.bgR, t),
    bgB: lerpColor(a.bgB, b.bgB, t),
    gnd: lerpColor(a.gnd, b.gnd, t),
    gl: lerpColor(a.gl, b.gl, t),
    sk: lerpColor(a.sk, b.sk, t),
    skIn: lerpColor(a.skIn, b.skIn, t),
    skB: lerpColor(a.skB, b.skB, t),
    nm: a.nm
  };
}

// ================================================================
// GAME LOGIC
// ================================================================
let gameStartTime = 0;
let lastSpeedUpCount = 0;
let speedUpFlash = 0;
let baseSpeed = 5.0;

function startGame() {
  state = 'playing'; camX = 0; canRestart = false;
  P = { x: 120, y: GND/2 - PSIZ/2, vy: 0, rot: 0, onG: false, dead: false, ship: true };
  particles = []; inputTap = false;
  coinsGot = 0; laserTrail = [];
  L.length = 0; blockSet.clear(); genX = 20; gndSpikeX = 0; ceilGenX = 0; ceilSpikeX = 0; ceilBumpX = 0; coinGenX = 30; powerUpGenX = 60; // reset level
  activePowerUps = {}; powerUpFlash = 0; powerUpFlashName = ''; powerUpFlashType = '';
  bamboozledCount = 0;
  gameStartTime = Date.now();
  lastSpeedUpCount = 0;
  speedUpFlash = 0;
  baseSpeed = SPEED;
  generateAhead(); // pre-fill screen
  document.getElementById('highTxt').textContent = 'Best: ' + highScore + 'm';
}

function kill() {
  if (P.dead) return;
  if (godMode) return;
  P.dead = true; state = 'dead'; canRestart = false;
  for (let i = 0; i < 16; i++) {
    particles.push({
      x: P.x + PSIZ/2, y: P.y + PSIZ/2,
      vx: (Math.random()-0.5)*14, vy: (Math.random()-0.5)*14 - 4,
      sz: Math.random()*8+3, life: 1,
      col: ['#0f0','#0af','#ff0'][Math.floor(Math.random()*3)]
    });
  }
  // Show death screen after 600ms, allow restart after another 600ms
  setTimeout(() => {
    const dist = Math.floor(camX / T);
    const isNewHigh = dist > highScore;
    if (isNewHigh) { highScore = dist; localStorage.setItem('endless-high', highScore); }
    // Achievement checks
    if (hasPU('invincible') && !hasAchievement('die-invincible')) grantAchievement('die-invincible');
    if (bamboozledCount >= 3 && !hasAchievement('bamboozled-3')) grantAchievement('bamboozled-3');
    if (dist >= 1000 && !hasAchievement('survive-1000m')) grantAchievement('survive-1000m');
    if (dist >= 2000 && !hasAchievement('survive-2000m')) grantAchievement('survive-2000m');
    if (coinsGot >= 25 && !hasAchievement('collect-25-run')) grantAchievement('collect-25-run');
    persistentCoins += coinsGot;
    if (coinsGot >= 100 && !hasAchievement('collect-100')) grantAchievement('collect-100');
    // Loyal Flyer streak tracking
    const streakSkin = parseInt(localStorage.getItem('geoflyer-streak-skin') || '-1');
    let streakCount = parseInt(localStorage.getItem('geoflyer-streak-count') || '0');
    if (dist >= 300 && shipSkin === streakSkin) {
      streakCount++;
    } else if (dist >= 300 && streakSkin !== shipSkin) {
      streakCount = 1;
    } else {
      streakCount = 0;
    }
    localStorage.setItem('geoflyer-streak-skin', shipSkin);
    localStorage.setItem('geoflyer-streak-count', streakCount);
    if (streakCount >= 10 && !hasAchievement('loyal-10')) grantAchievement('loyal-10');
    localStorage.setItem('geoflyer-coins', persistentCoins);
    const h2 = document.getElementById('deathS').querySelector('h2');
    h2.textContent = isNewHigh ? 'NEW HIGH SCORE!' : 'YOU CRASHED!';
    h2.style.color = isNewHigh ? '#ffd600' : '#f44';
    h2.style.textShadow = isNewHigh ? '0 0 20px #ffd600' : '0 0 20px #f00';
    document.getElementById('deathP').textContent = dist + 'm' + (isNewHigh ? '' : '  |  Best: ' + highScore + 'm') + '  |  Coins: ' + coinsGot;
    // Reset leaderboard UI
    document.getElementById('deathRank').style.display = 'none';
    document.getElementById('deathUsername').style.display = 'none';
    // Submit score to leaderboard
    const username = localStorage.getItem('geoflyer-username');
    if (isNewHigh && username) {
      submitScore(username, dist);
    } else if (isNewHigh && !username) {
      pendingDeathScore = dist;
      document.getElementById('deathUsername').style.display = 'block';
      document.getElementById('deathUsernameInput').value = '';
    }
    show('deathS');
    setTimeout(() => { canRestart = true; }, 600);
  }, 600);
}

function win() {
  state = 'won'; canRestart = false;
  let txt = 'Completed in ' + att + ' attempt' + (att>1?'s':'') + '!';
  if (totalCoins > 0) txt += ' Coins: ' + coinsGot + '/' + totalCoins;
  document.getElementById('winI').textContent = txt;
  show('winS');
  setTimeout(() => { canRestart = true; }, 1000);
}

function pr() { return { x: P.x+2, y: P.y+2, w: PSIZ-4, h: PSIZ-4 }; }
function ov(a, b) { return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

function update() {
  if (state !== 'playing') return;
  camX += SPEED;

  // Power-up expiry
  const now = Date.now();
  for (const pu in activePowerUps) {
    if (now >= activePowerUps[pu]) delete activePowerUps[pu];
  }

  if (P.ship) {
    const bamboozled = hasPU('bamboozled');
    if (bamboozled) {
      if (inputDown) P.vy += SHIP_GRAV; else P.vy += SHIP_UP;
    } else {
      if (inputDown) P.vy += SHIP_UP; else P.vy += SHIP_GRAV;
    }
    P.vy = Math.max(-SHIP_MAX, Math.min(SHIP_MAX, P.vy));
    P.y += P.vy;
    if (P.y + PSIZ > GND) { P.y = GND - PSIZ; P.vy = 0; }
    P.rot = P.vy * 2;
  } else {
    P.vy += GRAV;
    P.y += P.vy;
    P.onG = false;
    if (P.y + PSIZ >= GND) { P.y = GND - PSIZ; P.vy = 0; P.onG = true; }
  }

  const pR = pr();
  const wX = pR.x + camX;
  const stx = Math.floor((wX - T*2) / T);
  const etx = Math.floor((wX + pR.w + T*2) / T);

  for (const obj of L) {
    if (obj.x < stx || obj.x > etx) continue;
    const osx = obj.x * T - camX;
    const sy = obj.y * T;

    switch (obj.t) {
      case 'B': {
        const bR = { x: osx, y: sy, w: T, h: T };
        const p = pr();
        if (!ov(p, bR)) break;
        const oL = (p.x+p.w)-bR.x, oR = (bR.x+bR.w)-p.x;
        const oT = (p.y+p.h)-bR.y, oB = (bR.y+bR.h)-p.y;
        const mn = Math.min(oL, oR, oT, oB);
        if (P.ship) {
          // Prioritize vertical resolution to allow sliding over block edges
          if (mn === oT && P.vy >= 0) { P.y = sy - PSIZ; P.vy = 0; }
          else if (mn === oB && P.vy <= 0) { P.y = sy + T; P.vy = 0; }
          else if (mn === oL || mn === oR) {
            // Edge clipping — resolve vertically if overlap is small
            if (oT < PSIZ * 0.5) { P.y = sy - PSIZ; P.vy = Math.min(P.vy, 0); }
            else if (oB < PSIZ * 0.5) { P.y = sy + T; P.vy = Math.max(P.vy, 0); }
            else { kill(); return; }
          }
          else { kill(); return; }
        } else {
          if (mn === oT && P.vy >= 0) { P.y = sy - PSIZ; P.vy = 0; P.onG = true; }
          else if (mn === oL) { kill(); return; }
          else if (mn === oB && P.vy < 0) { P.y = sy + T; P.vy = 0; }
        }
        break;
      }
      case 'S': {
        const sR = { x: osx+8, y: sy+10, w: T-16, h: T-10 };
        if (ov(pr(), sR) && !hasPU('invincible')) { kill(); return; }
        break;
      }
      case 'CS': {
        const sR = { x: osx+8, y: sy, w: T-16, h: T-10 };
        if (ov(pr(), sR) && !hasPU('invincible')) { kill(); return; }
        break;
      }
      case 'SS': {
        const sR = { x: osx+10, y: sy+T/2+2, w: T-20, h: T/2-2 };
        if (ov(pr(), sR) && !hasPU('invincible')) { kill(); return; }
        break;
      }
      case 'SCS': {
        const sR = { x: osx+10, y: sy, w: T-20, h: T/2-2 };
        if (ov(pr(), sR) && !hasPU('invincible')) { kill(); return; }
        break;
      }
      case 'HG': {
        const sR = { x: osx+6, y: sy+T, w: T-12, h: T };
        if (ov(pr(), sR) && !hasPU('invincible')) { kill(); return; }
        break;
      }
      case 'FR': {
        const fR = { x: osx+6, y: sy + T - 18, w: T-12, h: 18 };
        if (ov(pr(), fR) && !hasPU('invincible')) { kill(); return; }
        break;
      }
      case 'P': {
        const pRect = { x: osx+4, y: sy, w: T-8, h: T };
        if (ov(pr(), pRect)) { P.vy = -15; P.onG = false; }
        break;
      }
      case 'PO': {
        const pRect = { x: osx, y: sy, w: T, h: T*2 };
        if (ov(pr(), pRect) && !P.ship) { P.ship = true; P.vy = -2; }
        break;
      }
      case 'PC': {
        const pRect = { x: osx, y: sy, w: T, h: T*2 };
        if (ov(pr(), pRect) && P.ship) { P.ship = false; P.vy = 0; }
        break;
      }
      case 'CN': {
        if (obj.collected) break;
        if (hasPU('magnet')) {
          obj.collected = true; coinsGot++; break;
        }
        const cR = { x: osx+4, y: sy+4, w: T-8, h: T-8 };
        if (ov(pr(), cR)) { obj.collected = true; coinsGot++; }
        break;
      }
      case 'PU': {
        if (obj.collected) break;
        const puR = { x: osx+4, y: sy+4, w: T-8, h: T-8 };
        if (ov(pr(), puR)) {
          obj.collected = true;
          activePowerUps[obj.puType] = Date.now() + POWERUP_DURATION;
          powerUpFlash = Date.now();
          const names = { bamboozled: 'BAMBOOZLED!', invincible: 'INVINCIBLE!', magnet: 'MAGNET!' };
          powerUpFlashName = names[obj.puType] || 'POWER UP!';
          powerUpFlashType = obj.puType;
          if (obj.puType === 'bamboozled') bamboozledCount++;
          // Magnet: instantly collect all visible coins
          if (obj.puType === 'magnet') {
            for (const o2 of L) {
              if (o2.t === 'CN' && !o2.collected) { o2.collected = true; coinsGot++; }
            }
          }
        }
        break;
      }
    }
  }

  if (!P.ship) {
    if ((inputTap || holdJump) && P.onG) { P.vy = JUMP; P.onG = false; }
  }
  inputTap = false;

  if (!P.ship) {
    if (!P.onG) P.rot += 5;
    else P.rot = Math.round(P.rot / 90) * 90;
  }

  if (P.y > H + 50 || P.y < -100) { kill(); return; }

  // Record laser trail points
  if (trailStyle === 7 && state === 'playing') {
    laserTrail.push({ wx: P.x + camX + PSIZ/2, wy: P.y + PSIZ/2 });
    if (laserTrail.length > LASER_MAX_POINTS) laserTrail.shift();
  }

  // Endless: generate ahead and cleanup behind
  generateAhead();
  cleanupBehind();

  const dist = Math.floor(camX / T);
  document.getElementById('scoreTxt').textContent = dist + 'm';
  document.getElementById('coinTxt').textContent = '\u2733 ' + coinsGot + ' / ' + persistentCoins;
}

// ================================================================
// RENDERING
// ================================================================
// Background rects - wrapping pattern that tiles endlessly
const BG_TILE_W = 2600; // background repeats every this many pixels (parallax space)
const bgRects = [];
(function() {
  const gap = 20;
  // Check overlap accounting for wrapping at BG_TILE_W boundary
  function overlaps(rect) {
    for (const r of bgRects) {
      // Check at normal position and wrapped positions (±BG_TILE_W)
      for (const ox of [0, -BG_TILE_W, BG_TILE_W]) {
        const rx = rect.x + ox;
        if (rx < r.x + r.w + gap && rx + rect.w + gap > r.x &&
            rect.y < r.y + r.h + gap && rect.y + rect.h + gap > r.y) return true;
      }
    }
    return false;
  }
  const cols = Math.ceil(BG_TILE_W / 260) + 2;
  for (let c = 0; c < cols; c++) {
    for (let r = 0; r < 3; r++) {
      let placed = false;
      for (let attempt = 0; attempt < 30; attempt++) {
        // Shrink size on later attempts to help fit
        const shrink = Math.min(attempt * 3, 60);
        const rect = {
          x: c * 260 - 100 + (Math.random() - 0.5) * 80,
          y: r * (GND / 3) + (Math.random() - 0.5) * 30,
          w: Math.max(80, 140 + Math.random() * 180 - shrink),
          h: Math.max(50, 70 + Math.random() * 110 - shrink)
        };
        if (!overlaps(rect)) { bgRects.push(rect); placed = true; break; }
      }
      if (!placed) {
        // Tiny fallback rect in a unique y-band so it can't overlap vertically
        const fallback = {
          x: c * 260 - 50 + (Math.random() - 0.5) * 20,
          y: r * (GND / 3) + 40 + Math.random() * 10,
          w: 60 + Math.random() * 30,
          h: 40 + Math.random() * 20
        };
        if (!overlaps(fallback)) bgRects.push(fallback);
        // else skip — better to have one fewer block than overlapping
      }
    }
  }
})();

const stars = [];
for (let i = 0; i < 50; i++) stars.push({
  x: Math.random() * 20000, y: Math.random() * (GND - 30) + 10,
  sz: Math.random() * 2.5 + 0.8, br: Math.random() * 0.5 + 0.3
});

const beatLights = [];
for (let i = 0; i < 30; i++) beatLights.push({
  x: Math.random() * 20000,
  y: Math.random() * (GND - 60) + 20,
  sz: Math.random() * 2 + 1.5,
  phase: Math.random() * Math.PI * 2
});

function drawBG() {
  const z = getZone(camX);
  X.fillStyle = z.bg;
  X.fillRect(0, 0, W, GND);

  const pOff = (camX * 0.15) % BG_TILE_W;
  X.fillStyle = z.bgR;
  X.strokeStyle = z.bgB;
  X.lineWidth = 2;
  for (const r of bgRects) {
    let rx = r.x - pOff;
    if (rx + r.w < -BG_TILE_W) rx += BG_TILE_W;
    if (rx > W + 50) rx -= BG_TILE_W;
    if (rx + r.w < -50 || rx > W + 50) continue;
    X.fillRect(rx, r.y, r.w, r.h);
    X.strokeRect(rx, r.y, r.w, r.h);
  }

  for (const s of stars) {
    let ssx = ((s.x - camX * 0.08) % (W + 80));
    if (ssx < 0) ssx += W + 80;
    const a = s.br + Math.sin(Date.now() * 0.002 + s.x) * 0.12;
    X.fillStyle = `rgba(255,255,200,${Math.max(0, a)})`;
    X.fillRect(ssx, s.y, s.sz, s.sz);
  }

  // Beat lights — subtle pulsing dots at ~120 BPM (2 Hz)
  const bTime = Date.now() * 0.001;
  for (const bl of beatLights) {
    let blx = ((bl.x - camX * 0.05) % (W + 100));
    if (blx < 0) blx += W + 100;
    const pulse = Math.sin(bTime * Math.PI * 4 + bl.phase);
    const bAlpha = 0.3 + pulse * 0.15;
    const bSz = bl.sz + pulse * 0.6;
    X.fillStyle = `rgba(180,220,255,${Math.max(0, bAlpha)})`;
    X.fillRect(blx, bl.y, bSz, bSz);
  }

  // Ground area below blocks
  X.fillStyle = z.gnd;
  X.fillRect(0, GND + T, W, H - GND - T);

  const go = camX % T;
  const bgCols = Math.ceil(W / T) + 2;

  // Ceiling blocks are real objects generated in generateAhead, drawn by drawObjects

  // --- GROUND: row of blocks + scattered decorative spikes on top ---
  for (let col = -1; col < bgCols; col++) {
    const bx = col * T - go;
    X.fillStyle = '#111';
    X.fillRect(bx, GND, T, T);
    X.strokeStyle = 'rgba(255,255,255,0.18)'; X.lineWidth = 0.7;
    for (let i = T/4; i < T; i += T/4) {
      X.beginPath(); X.moveTo(bx+i, GND); X.lineTo(bx+i, GND+T); X.stroke();
      X.beginPath(); X.moveTo(bx, GND+i); X.lineTo(bx+T, GND+i); X.stroke();
    }
    X.strokeStyle = '#fff'; X.lineWidth = 1.5;
    X.strokeRect(bx+0.5, GND+0.5, T-1, T-1);
    X.fillStyle = 'rgba(255,255,255,0.05)';
    X.fillRect(bx+2, GND+2, T-4, (T-4)/2);
    // ground spikes are real collision objects, generated in generateAhead
  }

  // Glow line at ground
  X.strokeStyle = z.gl; X.lineWidth = 2;
  X.beginPath(); X.moveTo(0, GND); X.lineTo(W, GND); X.stroke();
}

function drawBlock(bx, by) {
  X.fillStyle = '#111';
  X.fillRect(bx, by, T, T);
  X.strokeStyle = 'rgba(255,255,255,0.18)'; X.lineWidth = 0.7;
  for (let i = T/4; i < T; i += T/4) {
    X.beginPath(); X.moveTo(bx+i, by); X.lineTo(bx+i, by+T); X.stroke();
    X.beginPath(); X.moveTo(bx, by+i); X.lineTo(bx+T, by+i); X.stroke();
  }
  X.strokeStyle = '#fff'; X.lineWidth = 1.5;
  X.strokeRect(bx+0.5, by+0.5, T-1, T-1);
  X.fillStyle = 'rgba(255,255,255,0.05)';
  X.fillRect(bx+2, by+2, T-4, (T-4)/2);
}

function drawDecoBlock(bx, by) {
  X.globalAlpha = 0.18;
  X.fillStyle = '#222'; X.fillRect(bx, by, T, T);
  X.strokeStyle = '#888'; X.lineWidth = 1;
  X.strokeRect(bx+0.5, by+0.5, T-1, T-1);
  X.globalAlpha = 1;
}

function drawSpike(bx, by, z) {
  X.fillStyle = '#fff';
  X.beginPath(); X.moveTo(bx+T/2, by+2); X.lineTo(bx+T-3, by+T); X.lineTo(bx+3, by+T); X.closePath(); X.fill();
  X.fillStyle = '#ddd';
  X.beginPath(); X.moveTo(bx+T/2, by+10); X.lineTo(bx+T-9, by+T-2); X.lineTo(bx+9, by+T-2); X.closePath(); X.fill();
  X.strokeStyle = '#000'; X.lineWidth = 1.5;
  X.beginPath(); X.moveTo(bx+T/2, by+2); X.lineTo(bx+T-3, by+T); X.lineTo(bx+3, by+T); X.closePath(); X.stroke();
}

function drawCSpike(bx, by, z) {
  X.fillStyle = '#fff';
  X.beginPath(); X.moveTo(bx+T/2, by+T-2); X.lineTo(bx+T-3, by); X.lineTo(bx+3, by); X.closePath(); X.fill();
  X.fillStyle = '#ddd';
  X.beginPath(); X.moveTo(bx+T/2, by+T-10); X.lineTo(bx+T-9, by+2); X.lineTo(bx+9, by+2); X.closePath(); X.fill();
  X.strokeStyle = '#000'; X.lineWidth = 1.5;
  X.beginPath(); X.moveTo(bx+T/2, by+T-2); X.lineTo(bx+T-3, by); X.lineTo(bx+3, by); X.closePath(); X.stroke();
}

// Small spike pointing UP (half height, sits in bottom half of tile)
function drawSmallSpike(bx, by, z) {
  const hh = T / 2; // half height
  X.fillStyle = '#fff';
  X.beginPath(); X.moveTo(bx+T/2, by+hh+2); X.lineTo(bx+T-6, by+T); X.lineTo(bx+6, by+T); X.closePath(); X.fill();
  X.fillStyle = '#ddd';
  X.beginPath(); X.moveTo(bx+T/2, by+hh+7); X.lineTo(bx+T-10, by+T-2); X.lineTo(bx+10, by+T-2); X.closePath(); X.fill();
  X.strokeStyle = '#000'; X.lineWidth = 1.5;
  X.beginPath(); X.moveTo(bx+T/2, by+hh+2); X.lineTo(bx+T-6, by+T); X.lineTo(bx+6, by+T); X.closePath(); X.stroke();
}

// Small ceiling spike pointing DOWN (half height, hangs from top half of tile)
function drawSmallCSpike(bx, by, z) {
  const hh = T / 2;
  X.fillStyle = '#fff';
  X.beginPath(); X.moveTo(bx+T/2, by+hh-2); X.lineTo(bx+T-6, by); X.lineTo(bx+6, by); X.closePath(); X.fill();
  X.fillStyle = '#ddd';
  X.beginPath(); X.moveTo(bx+T/2, by+hh-7); X.lineTo(bx+T-10, by+2); X.lineTo(bx+10, by+2); X.closePath(); X.fill();
  X.strokeStyle = '#000'; X.lineWidth = 1.5;
  X.beginPath(); X.moveTo(bx+T/2, by+hh-2); X.lineTo(bx+T-6, by); X.lineTo(bx+6, by); X.closePath(); X.stroke();
}

function drawHang(bx, by) {
  X.strokeStyle = '#ffd600'; X.lineWidth = 2.5;
  for (let i = 0; i < 3; i++) {
    X.beginPath(); X.ellipse(bx+T/2, by+i*13+5, 5, 7, 0, 0, Math.PI*2); X.stroke();
  }
  const dy = by + 38;
  X.fillStyle = '#222'; X.fillRect(bx+4, dy, T-8, T-10);
  X.fillStyle = '#fff'; X.fillRect(bx+8, dy+3, T-16, T-16);
  X.fillStyle = '#222';
  X.beginPath(); X.moveTo(bx+4, dy+T-10); X.lineTo(bx+T-4, dy+T-10); X.lineTo(bx+T/2, dy+T+12); X.closePath(); X.fill();
  X.fillStyle = '#fff';
  X.beginPath(); X.moveTo(bx+10, dy+T-10); X.lineTo(bx+T-10, dy+T-10); X.lineTo(bx+T/2, dy+T+5); X.closePath(); X.fill();
}

function drawPad(bx, by) {
  X.fillStyle = '#ffd600'; X.fillRect(bx+4, by+T-12, T-8, 12);
  X.fillStyle = '#ff8f00';
  X.beginPath(); X.moveTo(bx+T/2, by+T-20); X.lineTo(bx+T/2+8, by+T-6); X.lineTo(bx+T/2-8, by+T-6); X.closePath(); X.fill();
}

function drawPortal(bx, by, isShip) {
  const t = Date.now() * 0.003;
  const col = isShip ? '#e040fb' : '#00e676';
  X.save(); X.translate(bx+T/2, by+T);
  X.shadowColor = col; X.shadowBlur = 25;
  X.strokeStyle = col; X.lineWidth = 3;
  X.beginPath(); X.ellipse(0, 0, T*0.6+Math.sin(t)*3, T*0.9+Math.cos(t)*3, 0, 0, Math.PI*2); X.stroke();
  X.strokeStyle = '#fff'; X.lineWidth = 2;
  X.beginPath(); X.ellipse(0, 0, T*0.35+Math.cos(t)*2, T*0.6+Math.sin(t)*2, 0, 0, Math.PI*2); X.stroke();
  X.fillStyle = col; X.beginPath(); X.arc(0, 0, 6, 0, Math.PI*2); X.fill();
  X.shadowBlur = 0; X.restore();
}

function drawFire(bx, by) {
  const t = Date.now() * 0.005;
  for (let i = 0; i < 4; i++) {
    const fx = bx + 3 + i*10 + Math.sin(t+i*1.8)*3;
    const fh = 14 + Math.sin(t*1.5+i)*6;
    X.fillStyle = i%2===0 ? '#ffd600' : '#ff6f00';
    X.globalAlpha = 0.8;
    X.beginPath(); X.moveTo(fx, by+T); X.lineTo(fx+5, by+T); X.lineTo(fx+2.5, by+T-fh); X.closePath(); X.fill();
  }
  X.globalAlpha = 1;
}

function drawSmiley(bx, by) {
  const cx = bx+T/2, cy = by+T/2;
  X.fillStyle = '#fff'; X.beginPath(); X.arc(cx, cy, T/2-6, 0, Math.PI*2); X.fill();
  X.fillStyle = '#000';
  X.beginPath(); X.arc(cx-4, cy-2, 2.5, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(cx+4, cy-2, 2.5, 0, Math.PI*2); X.fill();
  X.strokeStyle = '#000'; X.lineWidth = 1.5;
  X.beginPath(); X.arc(cx, cy+3, 4, 0, Math.PI); X.stroke();
}

function drawCoin(bx, by, collected) {
  if (collected) return;
  const cx = bx+T/2, cy = by+T/2;
  X.save();
  X.shadowColor = '#ffd600'; X.shadowBlur = 12;
  X.fillStyle = '#ffd600'; X.beginPath(); X.arc(cx, cy, T/2-6, 0, Math.PI*2); X.fill();
  X.fillStyle = '#ffab00'; X.beginPath(); X.arc(cx, cy, T/2-10, 0, Math.PI*2); X.fill();
  X.fillStyle = '#ffd600'; X.font = '16px Arial'; X.textAlign = 'center'; X.textBaseline = 'middle';
  X.fillText('\u2605', cx, cy+1);
  X.shadowBlur = 0; X.restore();
}

function drawPowerUp(bx, by, puType, collected) {
  if (collected) return;
  const cx = bx+T/2, cy = by+T/2;
  const t = Date.now() * 0.003;
  const bob = Math.sin(t * 2) * 3;
  X.save();
  // All power-ups look the same before pickup — blue mystery orb
  X.shadowColor = '#0af'; X.shadowBlur = 14;
  X.fillStyle = '#0af';
  X.beginPath(); X.arc(cx, cy + bob, T/2 - 4, 0, Math.PI*2); X.fill();
  X.fillStyle = 'rgba(0,0,0,0.3)';
  X.beginPath(); X.arc(cx, cy + bob, T/2 - 8, 0, Math.PI*2); X.fill();
  X.fillStyle = '#fff'; X.font = 'bold 16px Arial';
  X.textAlign = 'center'; X.textBaseline = 'middle';
  X.fillText('?', cx, cy + bob + 1);
  X.shadowBlur = 0; X.restore();
}

function drawObjects() {
  const vL = camX - T*2, vR = camX + W + T*2;
  for (const o of L) {
    const wx = o.x * T;
    if (wx < vL || wx > vR) continue;
    const ox = wx - camX, oy = o.y * T;
    const z = getZone(o.x * T);
    switch (o.t) {
      case 'B':  drawBlock(ox, oy); break;
      case 'D':  drawDecoBlock(ox, oy); break;
      case 'S':  drawSpike(ox, oy, z); break;
      case 'CS': drawCSpike(ox, oy, z); break;
      case 'SS': drawSmallSpike(ox, oy, z); break;
      case 'SCS': drawSmallCSpike(ox, oy, z); break;
      case 'HG': drawHang(ox, oy); break;
      case 'P':  drawPad(ox, oy); break;
      case 'PO': drawPortal(ox, oy, true); break;
      case 'PC': drawPortal(ox, oy, false); break;
      case 'FR': drawFire(ox, oy); break;
      case 'SM': drawSmiley(ox, oy); break;
      case 'CN': drawCoin(ox, oy, o.collected); break;
      case 'PU': drawPowerUp(ox, oy, o.puType, o.collected); break;
    }
    // Hitbox overlay
    if (showHitboxes) {
      let hb = null;
      switch (o.t) {
        case 'B':  hb = { x: ox, y: oy, w: T, h: T }; break;
        case 'S':  hb = { x: ox+8, y: oy+10, w: T-16, h: T-10 }; break;
        case 'CS': hb = { x: ox+8, y: oy, w: T-16, h: T-10 }; break;
        case 'SS': hb = { x: ox+10, y: oy+T/2+2, w: T-20, h: T/2-2 }; break;
        case 'SCS': hb = { x: ox+10, y: oy, w: T-20, h: T/2-2 }; break;
        case 'HG': hb = { x: ox+6, y: oy+T, w: T-12, h: T }; break;
        case 'FR': hb = { x: ox+6, y: oy+T-18, w: T-12, h: 18 }; break;
      }
      if (hb) {
        X.strokeStyle = '#f00';
        X.lineWidth = 1.5;
        X.strokeRect(hb.x, hb.y, hb.w, hb.h);
        X.fillStyle = 'rgba(255,0,0,0.15)';
        X.fillRect(hb.x, hb.y, hb.w, hb.h);
      }
    }
  }
  // Player hitbox
  if (showHitboxes && !P.dead) {
    const p = { x: P.x+2, y: P.y+2, w: PSIZ-4, h: PSIZ-4 };
    X.strokeStyle = '#0f0';
    X.lineWidth = 1.5;
    X.strokeRect(p.x, p.y, p.w, p.h);
    X.fillStyle = 'rgba(0,255,0,0.15)';
    X.fillRect(p.x, p.y, p.w, p.h);
  }
}

// ================================================================
// SHIP SKINS
// ================================================================

// --- Skin 0: Sci-fi Spaceship ---
function drawShipSkin0() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.008;
  // Twin engine plasma trail
  if (trailStyle === 0) {
  for (let i = 0; i < 10; i++) {
    const fx = -w/2 - 8 - i * 6;
    X.globalAlpha = 0.6 - i * 0.055;
    X.fillStyle = i < 3 ? '#66ffff' : (i < 6 ? '#0088ff' : '#4400cc');
    X.beginPath(); X.arc(fx + Math.sin(t+i)*2, -h/6 + Math.sin(t*1.5+i)*2, Math.max(1, 5-i*0.4), 0, Math.PI*2); X.fill();
    X.beginPath(); X.arc(fx + Math.sin(t+i+2)*2, h/6 + Math.sin(t*1.5+i+1)*2, Math.max(1, 5-i*0.4), 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Twin engine glow
  X.save(); X.shadowColor = '#0ff'; X.shadowBlur = 14;
  X.fillStyle = '#66ffff';
  X.beginPath(); X.arc(-w/2 + 1, -h/6, 3.5, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(-w/2 + 1, h/6, 3.5, 0, Math.PI*2); X.fill();
  X.restore();
  // Main hull - layered dark blue
  X.fillStyle = '#1a1a2e';
  X.beginPath();
  X.moveTo(w/2 + 5, 0);
  X.quadraticCurveTo(w/2 + 2, -h/3, w/6, -h/3);
  X.lineTo(-w/3, -h/3);
  X.lineTo(-w/2, -h/5);
  X.lineTo(-w/2, h/5);
  X.lineTo(-w/3, h/3);
  X.lineTo(w/6, h/3);
  X.quadraticCurveTo(w/2 + 2, h/3, w/2 + 5, 0);
  X.closePath(); X.fill();
  // Upper hull panel (lighter)
  X.fillStyle = '#242448';
  X.beginPath();
  X.moveTo(w/2 + 3, -1);
  X.quadraticCurveTo(w/2, -h/3 + 2, w/6, -h/3 + 2);
  X.lineTo(-w/4, -h/3 + 2); X.lineTo(-w/4, -1);
  X.closePath(); X.fill();
  // Swept wings
  X.fillStyle = '#141430';
  X.beginPath(); X.moveTo(0, -h/3); X.lineTo(-w/4, -h/2 - 2); X.lineTo(-w/2 - 2, -h/3); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(0, h/3); X.lineTo(-w/4, h/2 + 2); X.lineTo(-w/2 - 2, h/3); X.closePath(); X.fill();
  // Energy lines
  const pulse = 0.6 + Math.sin(t * 3) * 0.3;
  X.strokeStyle = `rgba(0,255,255,${pulse})`; X.lineWidth = 1;
  X.beginPath(); X.moveTo(w/2 + 2, 0); X.lineTo(-w/3, 0); X.stroke();
  X.beginPath(); X.moveTo(w/4, -h/6); X.lineTo(-w/4, -h/3 + 2); X.stroke();
  X.beginPath(); X.moveTo(w/4, h/6); X.lineTo(-w/4, h/3 - 2); X.stroke();
  // Cockpit dome
  X.save(); X.shadowColor = '#0af'; X.shadowBlur = 6;
  const cg = X.createRadialGradient(w/5, -1, 1, w/5, 0, 5);
  cg.addColorStop(0, '#ffffff'); cg.addColorStop(0.4, '#44ddff'); cg.addColorStop(1, '#0066aa');
  X.fillStyle = cg;
  X.beginPath(); X.ellipse(w/5, 0, 5, 4, 0, 0, Math.PI*2); X.fill();
  X.restore();
}

function drawCubeSkin0() {
  const h = PSIZ;
  const t = Date.now() * 0.008;
  // Trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 5; i++) {
    X.globalAlpha = 0.3 - i * 0.05;
    X.fillStyle = i < 3 ? '#66ffff' : '#0088ff';
    X.fillRect(-h/2 - i * 7, -h/2 + 4, 6, h - 8);
  }
  X.globalAlpha = 1;
  }
  // Body - dark hull
  X.fillStyle = '#1a1a2e'; X.fillRect(-h/2, -h/2, h, h);
  // Upper panel lighter
  X.fillStyle = '#242448'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, (h - 6)/2);
  // Lower panel
  X.fillStyle = '#1e1e3a'; X.fillRect(-h/2 + 3, 0, h - 6, h/2 - 3);
  // Energy line across middle
  const pulse = 0.6 + Math.sin(t * 3) * 0.3;
  X.strokeStyle = `rgba(0,255,255,${pulse})`; X.lineWidth = 1;
  X.beginPath(); X.moveTo(-h/2 + 4, 0); X.lineTo(h/2 - 4, 0); X.stroke();
  // Border
  X.strokeStyle = '#0ff'; X.lineWidth = 1.5; X.strokeRect(-h/2, -h/2, h, h);
  // Cockpit eye
  X.save(); X.shadowColor = '#0af'; X.shadowBlur = 6;
  X.fillStyle = '#44ddff'; X.beginPath(); X.arc(2, -2, 4, 0, Math.PI*2); X.fill();
  X.restore();
  X.fillStyle = '#fff'; X.beginPath(); X.arc(3, -3, 1.5, 0, Math.PI*2); X.fill();
}

// --- Skin 1: Neon Racer ---
function drawShipSkin1() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.003;
  const hue1 = (t * 30) % 360;
  // Light streak trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 8; i++) {
    X.globalAlpha = 0.4 - i * 0.045;
    X.strokeStyle = `hsl(${hue1}, 100%, 60%)`;
    X.lineWidth = 3 - i * 0.3;
    X.beginPath(); X.moveTo(-w/2 - i * 7, -1); X.lineTo(-w/2 - i * 7 - 5, -1); X.stroke();
    X.strokeStyle = `hsl(${hue1 + 180}, 100%, 60%)`;
    X.beginPath(); X.moveTo(-w/2 - i * 7, 1); X.lineTo(-w/2 - i * 7 - 5, 1); X.stroke();
  }
  X.globalAlpha = 1;
  }
  // Sharp angular wedge
  const col1 = `hsl(${hue1}, 100%, 55%)`;
  const col2 = `hsl(${hue1 + 180}, 100%, 55%)`;
  X.save();
  X.shadowColor = col1; X.shadowBlur = 15;
  X.fillStyle = col1;
  X.beginPath();
  X.moveTo(w/2 + 3, 0);
  X.lineTo(0, -h/2);
  X.lineTo(-w/2, -h/3);
  X.lineTo(-w/2 + 4, 0);
  X.closePath(); X.fill();
  X.shadowColor = col2;
  X.fillStyle = col2;
  X.beginPath();
  X.moveTo(w/2 + 3, 0);
  X.lineTo(0, h/2);
  X.lineTo(-w/2, h/3);
  X.lineTo(-w/2 + 4, 0);
  X.closePath(); X.fill();
  X.restore();
  // Center line
  X.strokeStyle = '#fff'; X.lineWidth = 1;
  X.beginPath(); X.moveTo(w/2, 0); X.lineTo(-w/2 + 4, 0); X.stroke();
  // Pulsing core
  const pulse = 2 + Math.sin(t * 3) * 1.5;
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(0, 0, pulse, 0, Math.PI * 2); X.fill();
}

function drawCubeSkin1() {
  const h = PSIZ;
  const t = Date.now() * 0.003;
  const hue1 = (t * 30) % 360;
  const col1 = `hsl(${hue1}, 100%, 55%)`;
  // Trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 4; i++) {
    X.globalAlpha = 0.3 - i * 0.06;
    X.fillStyle = col1;
    X.fillRect(-h/2 - i * 8, -h/2 + 3, 7, h - 6);
  }
  X.globalAlpha = 1;
  }
  X.save();
  X.shadowColor = col1; X.shadowBlur = 12;
  X.fillStyle = col1; X.fillRect(-h/2, -h/2, h, h);
  X.restore();
  X.fillStyle = `hsl(${hue1 + 180}, 100%, 55%)`; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, h - 6);
  X.fillStyle = 'rgba(255,255,255,0.15)'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, (h - 6) / 2);
  X.strokeStyle = '#fff'; X.lineWidth = 1.5; X.strokeRect(-h/2, -h/2, h, h);
  const pulse = 2 + Math.sin(t * 3) * 1;
  X.fillStyle = '#fff'; X.beginPath(); X.arc(2, 0, pulse, 0, Math.PI * 2); X.fill();
}

// --- Skin 2: GD-style clean ship/cube ---
function drawShipSkin2() {
  const h = PSIZ, w = PSIZ;
  // Trail
  if (trailStyle === 0) {
  X.globalAlpha = 0.35; X.fillStyle = '#0f0';
  X.fillRect(-w/2 - 20, -4, 22, 8);
  X.globalAlpha = 0.15; X.fillRect(-w/2 - 38, -3, 20, 6);
  X.globalAlpha = 1;
  }
  // Body - gradient green to teal
  const grd = X.createLinearGradient(-w/2, -h/2, w/2, h/2);
  grd.addColorStop(0, '#00e676'); grd.addColorStop(1, '#00bfa5');
  X.fillStyle = grd;
  X.beginPath();
  X.moveTo(w/2, 0);
  X.lineTo(-w/2, -h/2);
  X.lineTo(-w/2 + 6, 0);
  X.lineTo(-w/2, h/2);
  X.closePath(); X.fill();
  // Small wings
  X.fillStyle = '#00c853';
  X.beginPath(); X.moveTo(-w/6, -h/2 + 2); X.lineTo(-w/4, -h/2 - 5); X.lineTo(-w/2 + 2, -h/2 + 4); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-w/6, h/2 - 2); X.lineTo(-w/4, h/2 + 5); X.lineTo(-w/2 + 2, h/2 - 4); X.closePath(); X.fill();
  // Highlight
  X.fillStyle = 'rgba(255,255,255,0.15)';
  X.beginPath();
  X.moveTo(w/2 - 4, -1);
  X.lineTo(-w/2 + 6, -h/2 + 6);
  X.lineTo(-w/2 + 10, 0);
  X.closePath(); X.fill();
  // Clean outline
  X.strokeStyle = '#1b5e20'; X.lineWidth = 2;
  X.beginPath();
  X.moveTo(w/2, 0); X.lineTo(-w/2, -h/2);
  X.lineTo(-w/2 + 6, 0); X.lineTo(-w/2, h/2);
  X.closePath(); X.stroke();
  // Eye
  X.fillStyle = '#fff'; X.fillRect(-2, -5, 10, 8);
  X.fillStyle = '#000'; X.fillRect(2, -3, 5, 5);
}

function drawCubeSkin2() {
  const h = PSIZ;
  // Trail
  if (trailStyle === 0) {
  X.globalAlpha = 0.3; X.fillStyle = '#0f0';
  X.fillRect(-h/2 - 12, -h/2 + 4, 14, h - 8); X.globalAlpha = 1;
  }
  // Body gradient
  const grd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  grd.addColorStop(0, '#00e676'); grd.addColorStop(1, '#00bfa5');
  X.fillStyle = grd; X.fillRect(-h/2, -h/2, h, h);
  X.fillStyle = 'rgba(255,255,255,0.12)'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, (h - 6) / 2);
  // Small wings
  X.fillStyle = '#00c853';
  X.beginPath(); X.moveTo(-h/2 + 4, -h/2); X.lineTo(h/4, -h/2 - 5); X.lineTo(h/4, -h/2); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-h/2 + 4, h/2); X.lineTo(h/4, h/2 + 5); X.lineTo(h/4, h/2); X.closePath(); X.fill();
  // Clean outline
  X.strokeStyle = '#1b5e20'; X.lineWidth = 2.5; X.strokeRect(-h/2, -h/2, h, h);
  // Eye
  X.fillStyle = '#fff'; X.fillRect(-5, -6, 12, 10);
  X.fillStyle = '#000'; X.fillRect(-1, -3, 6, 6);
}

// --- Skin 3: Space Shuttle ---
function drawShipSkin3() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.01;
  // Engine exhaust - blue-white plasma
  if (trailStyle === 0) {
  for (let i = 0; i < 10; i++) {
    const fx = -w/2 - 6 - i * 6 + Math.sin(t * 2 + i * 1.3) * 2;
    const fy = Math.sin(t + i * 0.8) * 3;
    const sz = 5 - i * 0.4;
    X.globalAlpha = 0.7 - i * 0.06;
    X.fillStyle = i < 3 ? '#ccddff' : (i < 6 ? '#6688ff' : '#3344aa');
    X.beginPath(); X.arc(fx, fy, Math.max(1, sz), 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Engine pods (top and bottom)
  X.fillStyle = '#555566';
  X.fillRect(-w/2 - 3, -h/3 - 2, w/4, 5);
  X.fillRect(-w/2 - 3, h/3 - 3, w/4, 5);
  X.fillStyle = '#6688ff';
  X.beginPath(); X.arc(-w/2, -h/3, 2.5, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(-w/2, h/3, 2.5, 0, Math.PI*2); X.fill();
  // Main fuselage - metallic silver/gray
  const fGrd = X.createLinearGradient(0, -h/3, 0, h/3);
  fGrd.addColorStop(0, '#aaaabb'); fGrd.addColorStop(0.4, '#dddde8'); fGrd.addColorStop(0.6, '#ccccdd'); fGrd.addColorStop(1, '#888899');
  X.fillStyle = fGrd;
  X.beginPath();
  X.moveTo(w/2 + 4, 0);
  X.quadraticCurveTo(w/2 + 2, -h/4, w/6, -h/4);
  X.lineTo(-w/2, -h/4);
  X.lineTo(-w/2, h/4);
  X.lineTo(w/6, h/4);
  X.quadraticCurveTo(w/2 + 2, h/4, w/2 + 4, 0);
  X.closePath(); X.fill();
  // Delta wings
  X.fillStyle = '#777788';
  X.beginPath(); X.moveTo(-w/6, -h/4); X.lineTo(-w/3, -h/2 - 1); X.lineTo(-w/2, -h/4); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-w/6, h/4); X.lineTo(-w/3, h/2 + 1); X.lineTo(-w/2, h/4); X.closePath(); X.fill();
  // Fuselage seam line
  X.strokeStyle = '#666677'; X.lineWidth = 0.8;
  X.beginPath(); X.moveTo(w/3, 0); X.lineTo(-w/2 + 2, 0); X.stroke();
  // Cockpit windshield
  X.save(); X.shadowColor = '#aaddff'; X.shadowBlur = 5;
  const wg = X.createLinearGradient(w/4, -3, w/4, 3);
  wg.addColorStop(0, '#cceeFF'); wg.addColorStop(1, '#6699cc');
  X.fillStyle = wg;
  X.beginPath();
  X.moveTo(w/2 + 2, 0);
  X.quadraticCurveTo(w/2, -h/6, w/4, -h/6);
  X.lineTo(w/4, h/6);
  X.quadraticCurveTo(w/2, h/6, w/2 + 2, 0);
  X.closePath(); X.fill();
  X.restore();
  // Outline
  X.strokeStyle = '#555566'; X.lineWidth = 1;
  X.beginPath();
  X.moveTo(w/2 + 4, 0);
  X.quadraticCurveTo(w/2 + 2, -h/4, w/6, -h/4);
  X.lineTo(-w/2, -h/4); X.lineTo(-w/2, h/4); X.lineTo(w/6, h/4);
  X.quadraticCurveTo(w/2 + 2, h/4, w/2 + 4, 0);
  X.closePath(); X.stroke();
}

function drawCubeSkin3() {
  const h = PSIZ;
  const t = Date.now() * 0.01;
  // Trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 4; i++) {
    X.globalAlpha = 0.35 - i * 0.07;
    X.fillStyle = i < 2 ? '#ccddff' : '#6688ff';
    X.fillRect(-h/2 - i * 7, -h/2 + 5, 6, h - 10);
  }
  X.globalAlpha = 1;
  }
  // Metallic body
  const fGrd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  fGrd.addColorStop(0, '#aaaabb'); fGrd.addColorStop(0.5, '#dddde8'); fGrd.addColorStop(1, '#888899');
  X.fillStyle = fGrd; X.fillRect(-h/2, -h/2, h, h);
  // Hull panel line
  X.strokeStyle = '#666677'; X.lineWidth = 0.8;
  X.beginPath(); X.moveTo(-h/2 + 4, 0); X.lineTo(h/2 - 4, 0); X.stroke();
  X.beginPath(); X.moveTo(0, -h/2 + 4); X.lineTo(0, h/2 - 4); X.stroke();
  // Wing stubs
  X.fillStyle = '#777788';
  X.beginPath(); X.moveTo(-h/2 + 4, -h/2); X.lineTo(0, -h/2 - 5); X.lineTo(0, -h/2); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-h/2 + 4, h/2); X.lineTo(0, h/2 + 5); X.lineTo(0, h/2); X.closePath(); X.fill();
  // Border
  X.strokeStyle = '#555566'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Cockpit window
  X.save(); X.shadowColor = '#aaddff'; X.shadowBlur = 4;
  X.fillStyle = '#aaddff';
  X.beginPath(); X.arc(3, -2, 5, 0, Math.PI * 2); X.fill();
  X.restore();
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(4, -3, 1.8, 0, Math.PI * 2); X.fill();
}

// --- Skin 4: Phoenix ---
function drawShipSkin4() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.008;
  const flap = Math.sin(t * 1.2) * 3;
  // Ember/flame trail
  if (trailStyle === 0) {
  for (let i = 0; i < 12; i++) {
    const fx = -w/2 - 4 - i * 5;
    const fy = Math.sin(t * 2 + i * 1.3) * 4;
    const sz = 4.5 - i * 0.35;
    X.globalAlpha = 0.7 - i * 0.055;
    X.fillStyle = i < 3 ? '#ff2200' : (i < 6 ? '#ff6600' : (i < 9 ? '#ffaa00' : '#ffdd44'));
    X.beginPath(); X.arc(fx, fy, Math.max(1, sz), 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Tail flames (sharp pointed shapes behind body)
  X.fillStyle = '#cc2200';
  X.beginPath();
  X.moveTo(-w/6, 0); X.lineTo(-w/2 - 6, -h/5); X.lineTo(-w/2, -h/10); X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-w/6, 0); X.lineTo(-w/2 - 6, h/5); X.lineTo(-w/2, h/10); X.closePath(); X.fill();
  X.fillStyle = '#ff6600';
  X.beginPath();
  X.moveTo(-w/6, 0); X.lineTo(-w/2 - 10, 0); X.lineTo(-w/2 - 2, -h/14); X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-w/6, 0); X.lineTo(-w/2 - 10, 0); X.lineTo(-w/2 - 2, h/14); X.closePath(); X.fill();
  // Flickering flame tips on tail
  if (trailStyle === 0) {
  const fl1 = Math.sin(t * 4) * 2;
  const fl2 = Math.sin(t * 5 + 1) * 2;
  X.fillStyle = '#ffcc00'; X.globalAlpha = 0.8;
  X.beginPath(); X.moveTo(-w/2 - 6, -h/5); X.lineTo(-w/2 - 10 + fl1, -h/4); X.lineTo(-w/2 - 3, -h/6); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-w/2 - 6, h/5); X.lineTo(-w/2 - 10 + fl2, h/4); X.lineTo(-w/2 - 3, h/6); X.closePath(); X.fill();
  X.globalAlpha = 1;
  }
  // Wings (sharp, angular, flame-shaped with jagged edges)
  const wgrd = X.createLinearGradient(0, -h/2, 0, 0);
  wgrd.addColorStop(0, '#ffaa00'); wgrd.addColorStop(1, '#dd4400');
  X.fillStyle = wgrd;
  // Top wing - sharp angular shape
  X.beginPath();
  X.moveTo(w/8, -h/8);
  X.lineTo(w/10, -h/4 - flap);
  X.lineTo(-w/8, -h/2 - 2 - flap);      // wing tip point
  X.lineTo(-w/6, -h/3 - flap);           // jagged notch
  X.lineTo(-w/3, -h/2 + 1 - flap);      // second point
  X.lineTo(-w/4, -h/4 - flap);           // inner notch
  X.lineTo(-w/3, -h/8);
  X.closePath(); X.fill();
  // Bottom wing
  X.beginPath();
  X.moveTo(w/8, h/8);
  X.lineTo(w/10, h/4 + flap);
  X.lineTo(-w/8, h/2 + 2 + flap);
  X.lineTo(-w/6, h/3 + flap);
  X.lineTo(-w/3, h/2 - 1 + flap);
  X.lineTo(-w/4, h/4 + flap);
  X.lineTo(-w/3, h/8);
  X.closePath(); X.fill();
  // Flame glow at wing tips
  X.fillStyle = '#ffee44'; X.globalAlpha = 0.8;
  X.beginPath();
  X.moveTo(-w/8, -h/2 - 2 - flap); X.lineTo(-w/8 - 3, -h/2 - 5 - flap); X.lineTo(-w/8 + 3, -h/2 - 1 - flap); X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-w/8, h/2 + 2 + flap); X.lineTo(-w/8 - 3, h/2 + 5 + flap); X.lineTo(-w/8 + 3, h/2 + 1 + flap); X.closePath(); X.fill();
  X.globalAlpha = 1;
  // Body (angular diamond/kite shape, NOT oval)
  const bgrd = X.createLinearGradient(-w/4, -h/6, w/4, h/6);
  bgrd.addColorStop(0, '#ff5500'); bgrd.addColorStop(0.5, '#ee3300'); bgrd.addColorStop(1, '#cc1100');
  X.fillStyle = bgrd;
  X.beginPath();
  X.moveTo(w/3 + 4, 0);          // sharp nose
  X.lineTo(w/8, -h/6);           // upper front
  X.lineTo(-w/4, -h/7);          // upper back
  X.lineTo(-w/6, 0);             // tail center
  X.lineTo(-w/4, h/7);           // lower back
  X.lineTo(w/8, h/6);            // lower front
  X.closePath(); X.fill();
  // Bright belly line
  X.strokeStyle = '#ff8800'; X.lineWidth = 1;
  X.beginPath(); X.moveTo(w/3, 0); X.lineTo(-w/6, 0); X.stroke();
  // Head (angular, not round)
  X.fillStyle = '#ee3300';
  X.beginPath();
  X.moveTo(w/2 + 5, 0);          // beak tip
  X.lineTo(w/3 + 2, -h/7);      // top of head
  X.lineTo(w/6, -h/8);           // back top
  X.lineTo(w/6, h/8);            // back bottom
  X.lineTo(w/3 + 2, h/7);       // bottom of head
  X.closePath(); X.fill();
  // Crest (tall, sharp flame spikes)
  X.fillStyle = '#ffcc00';
  X.beginPath();
  X.moveTo(w/5, -h/7);
  X.lineTo(w/5 - 2, -h/7 - 7);
  X.lineTo(w/5 + 2, -h/7 - 2);
  X.lineTo(w/5 + 4, -h/7 - 9);
  X.lineTo(w/5 + 6, -h/7 - 3);
  X.lineTo(w/5 + 7, -h/7);
  X.closePath(); X.fill();
  // Sharp beak
  X.fillStyle = '#ff8800';
  X.beginPath();
  X.moveTo(w/2 + 5, 0);
  X.lineTo(w/3 + 3, -2);
  X.lineTo(w/3 + 3, 2);
  X.closePath(); X.fill();
  // Eye (fierce, angular)
  X.fillStyle = '#ffee44';
  X.save(); X.shadowColor = '#ff6600'; X.shadowBlur = 6;
  X.beginPath();
  X.moveTo(w/3, -1);
  X.lineTo(w/4 + 1, -3);
  X.lineTo(w/4 - 1, -1);
  X.lineTo(w/4 + 1, 1);
  X.closePath(); X.fill();
  X.restore();
  X.fillStyle = '#111';
  X.beginPath(); X.arc(w/4 + 2, -1, 1, 0, Math.PI*2); X.fill();
}

function drawCubeSkin4() {
  const h = PSIZ;
  const t = Date.now() * 0.008;
  const flap = Math.sin(t * 1.2) * 2;
  // Ember trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 5; i++) {
    X.globalAlpha = 0.4 - i * 0.07;
    X.fillStyle = i < 3 ? '#ff4400' : '#ffaa00';
    const fy = Math.sin(t * 2 + i) * 3;
    X.beginPath(); X.arc(-h/2 - i * 7, fy, 3 - i * 0.4, 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Sharp angular wings above and below cube
  const wgrd = X.createLinearGradient(0, -h/2 - 8, 0, 0);
  wgrd.addColorStop(0, '#ffaa00'); wgrd.addColorStop(1, '#dd4400');
  X.fillStyle = wgrd;
  // Top wing - jagged flame shape
  X.beginPath();
  X.moveTo(h/4, -h/2);
  X.lineTo(h/8, -h/2 - 4 - flap);
  X.lineTo(-h/8, -h/2 - 10 - flap);   // outer point
  X.lineTo(-h/6, -h/2 - 5 - flap);    // notch
  X.lineTo(-h/3, -h/2 - 8 - flap);    // second point
  X.lineTo(-h/4, -h/2 - 2 - flap);
  X.lineTo(-h/3, -h/2);
  X.closePath(); X.fill();
  // Bottom wing
  X.beginPath();
  X.moveTo(h/4, h/2);
  X.lineTo(h/8, h/2 + 4 + flap);
  X.lineTo(-h/8, h/2 + 10 + flap);
  X.lineTo(-h/6, h/2 + 5 + flap);
  X.lineTo(-h/3, h/2 + 8 + flap);
  X.lineTo(-h/4, h/2 + 2 + flap);
  X.lineTo(-h/3, h/2);
  X.closePath(); X.fill();
  // Flame tips on wings
  X.fillStyle = '#ffee44'; X.globalAlpha = 0.8;
  X.beginPath();
  X.moveTo(-h/8, -h/2 - 10 - flap); X.lineTo(-h/8 - 2, -h/2 - 13 - flap); X.lineTo(-h/8 + 2, -h/2 - 9 - flap);
  X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-h/8, h/2 + 10 + flap); X.lineTo(-h/8 - 2, h/2 + 13 + flap); X.lineTo(-h/8 + 2, h/2 + 9 + flap);
  X.closePath(); X.fill();
  X.globalAlpha = 1;
  // Sharp tail flames behind cube
  X.fillStyle = '#cc2200';
  X.beginPath();
  X.moveTo(-h/2, -h/6); X.lineTo(-h/2 - 7, -h/4); X.lineTo(-h/2 - 3, -h/8); X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-h/2, h/6); X.lineTo(-h/2 - 7, h/4); X.lineTo(-h/2 - 3, h/8); X.closePath(); X.fill();
  X.fillStyle = '#ff6600';
  X.beginPath();
  X.moveTo(-h/2, -h/12); X.lineTo(-h/2 - 9, 0); X.lineTo(-h/2, h/12); X.closePath(); X.fill();
  // Body gradient
  const grd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  grd.addColorStop(0, '#ff5500'); grd.addColorStop(0.5, '#ee3300'); grd.addColorStop(1, '#cc1100');
  X.fillStyle = grd; X.fillRect(-h/2, -h/2, h, h);
  // Sharp crest spikes on top edge
  X.fillStyle = '#ffcc00';
  X.beginPath();
  X.moveTo(h/6 - 3, -h/2);
  X.lineTo(h/6 - 2, -h/2 - 6);
  X.lineTo(h/6 + 1, -h/2 - 1);
  X.lineTo(h/6 + 3, -h/2 - 8);
  X.lineTo(h/6 + 5, -h/2 - 2);
  X.lineTo(h/6 + 6, -h/2 - 5);
  X.lineTo(h/6 + 8, -h/2);
  X.closePath(); X.fill();
  // Golden border
  X.strokeStyle = '#ffaa00'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Fierce angular eye with glow
  X.save(); X.shadowColor = '#ff6600'; X.shadowBlur = 6;
  X.fillStyle = '#ffee44';
  X.beginPath();
  X.moveTo(6, -1);
  X.lineTo(0, -4);
  X.lineTo(-2, -1);
  X.lineTo(0, 2);
  X.closePath(); X.fill();
  X.restore();
  X.fillStyle = '#111';
  X.beginPath(); X.arc(2, -1, 1.5, 0, Math.PI*2); X.fill();
}

// --- Skin 5: Pirate Ship ---
function drawShipSkin5() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.005;
  // Wake/splash trail
  if (trailStyle === 0) {
  for (let i = 0; i < 8; i++) {
    const wx = -w/2 - 6 - i * 7;
    const wy = h/8 + Math.sin(t * 2.5 + i * 1.5) * 2;
    const sz = 3.5 - i * 0.35;
    X.globalAlpha = 0.35 - i * 0.035;
    X.fillStyle = '#88bbdd';
    X.beginPath(); X.arc(wx, wy, Math.max(1, sz), 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Sail (behind hull) - billowing to the right
  const wave = Math.sin(t * 2) * 1.5;
  X.fillStyle = '#eee8d0';
  X.beginPath();
  X.moveTo(-w/10, -h/5);
  X.lineTo(-w/10, -h/2 - 10);
  X.quadraticCurveTo(w/4 + wave, -h/3 - 5, w/5 + wave, -h/5 - 2);
  X.closePath(); X.fill();
  X.strokeStyle = '#bbb098'; X.lineWidth = 0.6;
  X.beginPath();
  X.moveTo(-w/10, -h/5);
  X.lineTo(-w/10, -h/2 - 10);
  X.quadraticCurveTo(w/4 + wave, -h/3 - 5, w/5 + wave, -h/5 - 2);
  X.closePath(); X.stroke();
  // Mast
  X.strokeStyle = '#3a2000'; X.lineWidth = 2;
  X.beginPath(); X.moveTo(-w/10, -h/5); X.lineTo(-w/10, -h/2 - 13); X.stroke();
  // Jolly roger flag at mast top
  const fw = Math.sin(t * 3) * 2;
  X.fillStyle = '#111';
  X.fillRect(-w/10 + 1, -h/2 - 18 + fw, 9, 7);
  X.fillStyle = '#ddd';
  X.beginPath(); X.arc(-w/10 + 5, -h/2 - 15.5 + fw, 1.5, 0, Math.PI*2); X.fill();
  X.fillRect(-w/10 + 4, -h/2 - 13 + fw, 1.5, 2);
  // Hull - flat deck on top, curved bottom
  const hGrd = X.createLinearGradient(0, -h/5, 0, h/4);
  hGrd.addColorStop(0, '#A07830'); hGrd.addColorStop(0.4, '#8B6914'); hGrd.addColorStop(1, '#6B4F10');
  X.fillStyle = hGrd;
  X.beginPath();
  X.moveTo(w/2 + 6, -h/10);         // bow tip
  X.lineTo(w/3, -h/5);              // deck front
  X.lineTo(-w/3, -h/5);             // deck runs flat
  X.lineTo(-w/2, -h/4);             // stern raised up
  X.lineTo(-w/2, h/8);              // stern bottom
  X.quadraticCurveTo(-w/6, h/3 + 2, w/6, h/4);
  X.quadraticCurveTo(w/3, h/5, w/2 + 6, -h/10);
  X.closePath(); X.fill();
  // Plank lines on hull
  X.strokeStyle = '#5a3a08'; X.lineWidth = 0.5;
  X.beginPath(); X.moveTo(-w/3, -h/10); X.lineTo(w/3, -h/10); X.stroke();
  X.beginPath(); X.moveTo(-w/3, h/12); X.lineTo(w/4, h/12); X.stroke();
  // Deck railing
  X.strokeStyle = '#6B4F10'; X.lineWidth = 1;
  X.beginPath(); X.moveTo(w/3, -h/5 - 1); X.lineTo(-w/3, -h/5 - 1); X.stroke();
  // Railing posts
  for (let i = -2; i <= 2; i++) {
    const px = i * w/6;
    X.beginPath(); X.moveTo(px, -h/5 - 1); X.lineTo(px, -h/5 + 2); X.stroke();
  }
  // Cannon ports
  X.fillStyle = '#222';
  X.beginPath(); X.arc(-w/6, h/16, 2, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(w/10, h/16, 2, 0, Math.PI*2); X.fill();
  // Stern cabin window
  X.fillStyle = '#ffdd66';
  X.fillRect(-w/2 + 2, -h/6, 4, 3);
  // Hull outline
  X.strokeStyle = '#4a2a00'; X.lineWidth = 1.5;
  X.beginPath();
  X.moveTo(w/2 + 6, -h/10);
  X.lineTo(w/3, -h/5);
  X.lineTo(-w/3, -h/5);
  X.lineTo(-w/2, -h/4);
  X.lineTo(-w/2, h/8);
  X.quadraticCurveTo(-w/6, h/3 + 2, w/6, h/4);
  X.quadraticCurveTo(w/3, h/5, w/2 + 6, -h/10);
  X.closePath(); X.stroke();
}

function drawCubeSkin5() {
  const h = PSIZ;
  const t = Date.now() * 0.005;
  // Wake trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 4; i++) {
    X.globalAlpha = 0.3 - i * 0.06;
    X.fillStyle = '#88bbdd';
    X.beginPath(); X.arc(-h/2 - i * 8, h/6 + Math.sin(t + i) * 2, 3 - i*0.4, 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Mast + sail above cube
  X.strokeStyle = '#3a2000'; X.lineWidth = 2;
  X.beginPath(); X.moveTo(0, -h/2); X.lineTo(0, -h/2 - 12); X.stroke();
  const sw = Math.sin(t * 2) * 1.5;
  X.fillStyle = '#eee8d0';
  X.beginPath();
  X.moveTo(0, -h/2 - 11);
  X.quadraticCurveTo(h/3 + sw, -h/2 - 6, h/4 + sw, -h/2 - 1);
  X.lineTo(0, -h/2);
  X.closePath(); X.fill();
  X.strokeStyle = '#bbb098'; X.lineWidth = 0.5;
  X.stroke();
  // Flag at top
  const fw = Math.sin(t * 3) * 1.5;
  X.fillStyle = '#111';
  X.fillRect(1, -h/2 - 17 + fw, 8, 6);
  X.fillStyle = '#ddd';
  X.beginPath(); X.arc(5, -h/2 - 14.5 + fw, 1.2, 0, Math.PI*2); X.fill();
  // Wooden body
  const hGrd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  hGrd.addColorStop(0, '#A07830'); hGrd.addColorStop(0.5, '#8B6914'); hGrd.addColorStop(1, '#6B4F10');
  X.fillStyle = hGrd; X.fillRect(-h/2, -h/2, h, h);
  // Plank lines
  X.strokeStyle = '#5a3a08'; X.lineWidth = 0.7;
  for (let i = 1; i < 4; i++) {
    X.beginPath(); X.moveTo(-h/2 + 3, -h/2 + i * h/4); X.lineTo(h/2 - 3, -h/2 + i * h/4); X.stroke();
  }
  // Cannon ports on hull
  X.fillStyle = '#222';
  X.beginPath(); X.arc(-h/5, 0, 2, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(h/5, 0, 2, 0, Math.PI*2); X.fill();
  // Deck railing on top edge
  X.strokeStyle = '#6B4F10'; X.lineWidth = 1;
  X.beginPath(); X.moveTo(-h/2, -h/2); X.lineTo(h/2, -h/2); X.stroke();
  // Border
  X.strokeStyle = '#4a2a00'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Skull and crossbones eye
  X.fillStyle = '#eee8d0'; X.beginPath(); X.arc(1, -1, 5, 0, Math.PI*2); X.fill();
  X.fillStyle = '#333';
  X.beginPath(); X.arc(-1, -2, 1.5, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(3, -2, 1.5, 0, Math.PI*2); X.fill();
  X.fillRect(0, 1, 2, 3);
}

// --- Skin 6: Ice Crystal ---
function drawShipSkin6() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.006;
  // Sparkle/snowflake trail particles
  if (trailStyle === 0) {
  for (let i = 0; i < 8; i++) {
    const fx = -w/2 - 6 - i * 7 + Math.sin(t * 1.2 + i * 2) * 3;
    const fy = Math.sin(t * 1.8 + i * 1.5) * 8;
    const sz = 3 - i * 0.3;
    X.globalAlpha = 0.6 - i * 0.065;
    X.fillStyle = i % 2 === 0 ? '#aaddff' : '#ffffff';
    X.beginPath(); X.arc(fx, fy, Math.max(0.5, sz), 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Crystalline diamond body - icy blue/white gradient
  const grd = X.createLinearGradient(-w/2, -h/2, w/2, h/2);
  grd.addColorStop(0, '#88ccff'); grd.addColorStop(0.5, '#cceeff'); grd.addColorStop(1, '#66aaee');
  X.fillStyle = grd;
  X.beginPath();
  X.moveTo(w/2 + 5, 0);
  X.lineTo(0, -h/2);
  X.lineTo(-w/2, -h/4);
  X.lineTo(-w/2 + 4, 0);
  X.lineTo(-w/2, h/4);
  X.lineTo(0, h/2);
  X.closePath(); X.fill();
  // Faceted highlights - overlapping translucent triangles
  X.fillStyle = 'rgba(255,255,255,0.2)';
  X.beginPath(); X.moveTo(w/2 + 2, 0); X.lineTo(0, -h/2 + 4); X.lineTo(-w/4, 0); X.closePath(); X.fill();
  X.fillStyle = 'rgba(200,230,255,0.15)';
  X.beginPath(); X.moveTo(w/4, -h/4); X.lineTo(-w/6, -h/3); X.lineTo(-w/6, 0); X.closePath(); X.fill();
  X.fillStyle = 'rgba(255,255,255,0.1)';
  X.beginPath(); X.moveTo(-w/4, 0); X.lineTo(-w/2 + 4, h/4); X.lineTo(0, h/3); X.closePath(); X.fill();
  // Icy outline
  X.strokeStyle = '#88bbee'; X.lineWidth = 1.5;
  X.beginPath();
  X.moveTo(w/2 + 5, 0); X.lineTo(0, -h/2); X.lineTo(-w/2, -h/4);
  X.lineTo(-w/2 + 4, 0); X.lineTo(-w/2, h/4); X.lineTo(0, h/2);
  X.closePath(); X.stroke();
  // Sparkle accents
  const sp = Math.sin(t * 3) * 0.3 + 0.7;
  X.globalAlpha = sp;
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(w/6, -h/6, 2, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(-w/6, h/6, 1.5, 0, Math.PI * 2); X.fill();
  X.globalAlpha = 1;
}

function drawCubeSkin6() {
  const h = PSIZ;
  const t = Date.now() * 0.006;
  // Snowflake/sparkle trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 5; i++) {
    const fy = Math.sin(t * 1.5 + i * 1.8) * 5;
    X.globalAlpha = 0.4 - i * 0.07;
    X.fillStyle = i % 2 === 0 ? '#aaddff' : '#fff';
    X.beginPath(); X.arc(-h/2 - i * 7, fy, 2.5 - i * 0.3, 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Light blue body
  const grd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  grd.addColorStop(0, '#88ccff'); grd.addColorStop(1, '#66aaee');
  X.fillStyle = grd; X.fillRect(-h/2, -h/2, h, h);
  // White frost overlay triangles
  X.fillStyle = 'rgba(255,255,255,0.2)';
  X.beginPath(); X.moveTo(-h/2, -h/2); X.lineTo(h/4, -h/2); X.lineTo(-h/2, h/4); X.closePath(); X.fill();
  X.fillStyle = 'rgba(200,230,255,0.15)';
  X.beginPath(); X.moveTo(h/2, h/2); X.lineTo(-h/4, h/2); X.lineTo(h/2, -h/4); X.closePath(); X.fill();
  // Icy border
  X.strokeStyle = '#88bbee'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Blue eye
  X.fillStyle = '#4488cc'; X.fillRect(-3, -5, 10, 8);
  X.fillStyle = '#cceeff'; X.fillRect(0, -3, 5, 5);
}

// --- Skin 7: Seagull ---
function drawShipSkin7() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.006;
  const flap = Math.sin(t * 1.5) * 3;
  // White wisp trail
  if (trailStyle === 0) {
  for (let i = 0; i < 8; i++) {
    const fx = -w/2 - 6 - i * 7 + Math.sin(t * 1.3 + i * 1.5) * 3;
    const fy = Math.sin(t * 1.6 + i * 1.2) * 5;
    const sz = 3 - i * 0.3;
    X.globalAlpha = 0.35 - i * 0.04;
    X.fillStyle = '#ddeeff';
    X.beginPath(); X.arc(fx, fy, Math.max(0.5, sz), 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Tail feathers (short, behind body)
  X.fillStyle = '#99aabb';
  X.beginPath();
  X.moveTo(-w/4, -1);
  X.lineTo(-w/2 - 6, -h/8);
  X.lineTo(-w/2 - 8, 0);
  X.lineTo(-w/2 - 6, h/8);
  X.lineTo(-w/4, 1);
  X.closePath(); X.fill();
  // Wings (long, curved, with animated flap)
  // Top wing
  X.fillStyle = '#dde8f0';
  X.beginPath();
  X.moveTo(w/8, -2);
  X.quadraticCurveTo(w/10, -h/4 - flap, -w/4, -h/2 - 3 - flap);
  X.lineTo(-w/3 - 2, -h/2 + 2 - flap);
  X.quadraticCurveTo(-w/5, -h/5 - flap, -w/4, -2);
  X.closePath(); X.fill();
  // Bottom wing
  X.beginPath();
  X.moveTo(w/8, 2);
  X.quadraticCurveTo(w/10, h/4 + flap, -w/4, h/2 + 3 + flap);
  X.lineTo(-w/3 - 2, h/2 - 2 + flap);
  X.quadraticCurveTo(-w/5, h/5 + flap, -w/4, 2);
  X.closePath(); X.fill();
  // Gray/dark wing tips
  X.fillStyle = '#556677';
  X.beginPath();
  X.moveTo(-w/4 - 2, -h/2 - 1 - flap);
  X.lineTo(-w/3 - 4, -h/2 + 1 - flap);
  X.lineTo(-w/3, -h/2 + 5 - flap);
  X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-w/4 - 2, h/2 + 1 + flap);
  X.lineTo(-w/3 - 4, h/2 - 1 + flap);
  X.lineTo(-w/3, h/2 - 5 + flap);
  X.closePath(); X.fill();
  // Body (oval bird torso)
  X.fillStyle = '#f0f4f8';
  X.beginPath();
  X.ellipse(0, 0, w/3, h/7, 0, 0, Math.PI*2);
  X.fill();
  // Light belly highlight
  X.fillStyle = 'rgba(255,255,255,0.4)';
  X.beginPath();
  X.ellipse(0, 2, w/4, h/10, 0, 0, Math.PI*2);
  X.fill();
  // Head (round)
  X.fillStyle = '#f0f4f8';
  X.beginPath(); X.arc(w/4 + 2, -1, h/7, 0, Math.PI*2); X.fill();
  // Beak (yellow-orange, slightly curved down)
  X.fillStyle = '#eeaa33';
  X.beginPath();
  X.moveTo(w/4 + h/7, -1);
  X.lineTo(w/2 + 7, -1);
  X.lineTo(w/2 + 5, 2);
  X.quadraticCurveTo(w/2 + 3, 3, w/4 + h/7, 1);
  X.closePath(); X.fill();
  // Eye
  X.fillStyle = '#222';
  X.beginPath(); X.arc(w/4 + 4, -2, 2, 0, Math.PI*2); X.fill();
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(w/4 + 4.5, -2.5, 0.7, 0, Math.PI*2); X.fill();
}

function drawCubeSkin7() {
  const h = PSIZ;
  const t = Date.now() * 0.006;
  const flap = Math.sin(t * 1.5) * 2;
  // White wisp trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 5; i++) {
    const fy = Math.sin(t * 1.4 + i * 1.6) * 4;
    X.globalAlpha = 0.35 - i * 0.06;
    X.fillStyle = '#ddeeff';
    X.beginPath(); X.arc(-h/2 - i * 7, fy, 2.5 - i * 0.3, 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Wings extending above and below cube
  X.fillStyle = '#dde8f0';
  // Top wing
  X.beginPath();
  X.moveTo(h/4, -h/2);
  X.quadraticCurveTo(0, -h/2 - 5 - flap, -h/4, -h/2 - 9 - flap);
  X.lineTo(-h/3, -h/2 - 5 - flap);
  X.quadraticCurveTo(-h/6, -h/2 - 1, -h/4, -h/2);
  X.closePath(); X.fill();
  // Bottom wing
  X.beginPath();
  X.moveTo(h/4, h/2);
  X.quadraticCurveTo(0, h/2 + 5 + flap, -h/4, h/2 + 9 + flap);
  X.lineTo(-h/3, h/2 + 5 + flap);
  X.quadraticCurveTo(-h/6, h/2 + 1, -h/4, h/2);
  X.closePath(); X.fill();
  // Dark wing tips
  X.fillStyle = '#556677';
  X.beginPath(); X.arc(-h/4, -h/2 - 8 - flap, 2, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(-h/4, h/2 + 8 + flap, 2, 0, Math.PI*2); X.fill();
  // Tail feathers behind
  X.fillStyle = '#99aabb';
  X.beginPath();
  X.moveTo(-h/2, -h/8); X.lineTo(-h/2 - 5, -h/6); X.lineTo(-h/2 - 6, 0);
  X.lineTo(-h/2 - 5, h/6); X.lineTo(-h/2, h/8);
  X.closePath(); X.fill();
  // White body
  X.fillStyle = '#f0f4f8'; X.fillRect(-h/2, -h/2, h, h);
  // Belly highlight
  X.fillStyle = 'rgba(255,255,255,0.3)';
  X.fillRect(-h/4, -h/4, h/2, h/2);
  // Border
  X.strokeStyle = '#99aabb'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Beak stub on right edge
  X.fillStyle = '#eeaa33';
  X.beginPath();
  X.moveTo(h/2, -2); X.lineTo(h/2 + 5, 0); X.lineTo(h/2, 3);
  X.closePath(); X.fill();
  // Eye
  X.fillStyle = '#222';
  X.beginPath(); X.arc(h/6, -2, 2.5, 0, Math.PI*2); X.fill();
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(h/6 + 0.7, -2.5, 0.8, 0, Math.PI*2); X.fill();
}

// --- Skin 8: Dolphin ---
function drawShipSkin8() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.007;
  // Water droplet trail
  if (trailStyle === 0) {
  for (let i = 0; i < 8; i++) {
    const fx = -w/2 - 6 - i * 7 + Math.sin(t * 1.4 + i * 1.8) * 3;
    const fy = Math.sin(t * 2.0 + i * 1.3) * 7;
    const sz = 3 - i * 0.3;
    X.globalAlpha = 0.5 - i * 0.055;
    X.fillStyle = i % 2 === 0 ? '#66bbee' : '#aaddff';
    X.beginPath(); X.arc(fx, fy, Math.max(0.5, sz), 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Smooth curved blue-gray body
  const grd = X.createLinearGradient(0, -h/2, 0, h/2);
  grd.addColorStop(0, '#5588aa'); grd.addColorStop(0.5, '#88bbcc'); grd.addColorStop(1, '#ccddee');
  X.fillStyle = grd;
  X.beginPath();
  X.moveTo(w/2 + 4, 0);
  X.quadraticCurveTo(w/2 + 2, -h/3, w/6, -h/3);
  X.lineTo(-w/2, -h/4);
  X.lineTo(-w/2, h/4);
  X.lineTo(w/6, h/3);
  X.quadraticCurveTo(w/2 + 2, h/3, w/2 + 4, 0);
  X.closePath(); X.fill();
  // Lighter belly
  X.fillStyle = 'rgba(220,238,248,0.35)';
  X.beginPath();
  X.moveTo(w/2 + 2, 2);
  X.quadraticCurveTo(w/3, h/3 - 2, -w/3, h/4);
  X.lineTo(-w/3, 2);
  X.closePath(); X.fill();
  // Dorsal fin on top
  X.fillStyle = '#4477aa';
  X.beginPath(); X.moveTo(0, -h/3); X.lineTo(-w/8, -h/2 - 3); X.lineTo(-w/4, -h/3); X.closePath(); X.fill();
  // Tail fluke at back
  X.fillStyle = '#5588aa';
  X.beginPath(); X.moveTo(-w/2, -h/4); X.lineTo(-w/2 - 7, -h/3 - 3); X.lineTo(-w/3, -h/5); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-w/2, h/4); X.lineTo(-w/2 - 7, h/3 + 3); X.lineTo(-w/3, h/5); X.closePath(); X.fill();
  // Eye
  X.fillStyle = '#224';
  X.beginPath(); X.arc(w/5, -2, 2.5, 0, Math.PI * 2); X.fill();
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(w/5 + 0.8, -2.5, 0.8, 0, Math.PI * 2); X.fill();
}

function drawCubeSkin8() {
  const h = PSIZ;
  const t = Date.now() * 0.007;
  // Water splash trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 5; i++) {
    const fy = Math.sin(t * 1.8 + i * 1.5) * 5;
    X.globalAlpha = 0.4 - i * 0.07;
    X.fillStyle = i % 2 === 0 ? '#66bbee' : '#aaddff';
    X.beginPath(); X.arc(-h/2 - i * 7, fy, 2.5 - i * 0.3, 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Blue-gray gradient body
  const grd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  grd.addColorStop(0, '#5588aa'); grd.addColorStop(1, '#88bbcc');
  X.fillStyle = grd; X.fillRect(-h/2, -h/2, h, h);
  // Lighter blue inner
  X.fillStyle = '#aaccdd'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, h - 6);
  // Curved highlight
  X.fillStyle = 'rgba(255,255,255,0.15)';
  X.beginPath(); X.moveTo(-h/2, -h/2); X.lineTo(h/4, -h/2); X.lineTo(-h/2, h/4); X.closePath(); X.fill();
  // Border
  X.strokeStyle = '#4477aa'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Teal eye
  X.fillStyle = '#008899'; X.fillRect(-3, -5, 10, 8);
  X.fillStyle = '#ccffff'; X.fillRect(0, -3, 5, 5);
}

// --- Skin 9: Shooting Star ---
function drawShipSkin9() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.008;
  // Long rainbow/gold sparkle trail
  if (trailStyle === 0) {
  for (let i = 0; i < 12; i++) {
    const fx = -w/2 - 6 - i * 7 + Math.sin(t + i * 0.8) * 2;
    const fy = Math.sin(t * 1.5 + i * 1.2) * 5;
    const sz = 4 - i * 0.3;
    X.globalAlpha = 0.7 - i * 0.055;
    const hue = (t * 40 + i * 30) % 360;
    X.fillStyle = `hsl(${hue}, 90%, 65%)`;
    X.beginPath(); X.arc(fx, fy, Math.max(0.5, sz), 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Radiating glow
  X.save();
  X.shadowColor = '#ffdd44'; X.shadowBlur = 18;
  // Golden-white pointed star shape
  X.fillStyle = '#ffe866';
  X.beginPath();
  X.moveTo(w/2 + 6, 0);       // right point
  X.lineTo(w/8, -h/6);
  X.lineTo(0, -h/2);            // top point
  X.lineTo(-w/8, -h/6);
  X.lineTo(-w/2, -h/5);         // left-top point
  X.lineTo(-w/5, 0);
  X.lineTo(-w/2, h/5);          // left-bottom point
  X.lineTo(-w/8, h/6);
  X.lineTo(0, h/2);             // bottom point
  X.lineTo(w/8, h/6);
  X.closePath(); X.fill();
  X.restore();
  // White glow overlay
  X.fillStyle = 'rgba(255,255,255,0.3)';
  X.beginPath();
  X.moveTo(w/2 + 4, 0); X.lineTo(w/8, -h/8); X.lineTo(-w/6, 0); X.lineTo(w/8, h/8);
  X.closePath(); X.fill();
  // Sparkle accents
  const sp = Math.sin(t * 3) * 0.3 + 0.7;
  X.globalAlpha = sp;
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(w/6, -h/5, 2, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(-w/6, h/5, 1.5, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(w/4, h/8, 1.5, 0, Math.PI * 2); X.fill();
  X.globalAlpha = 1;
}

function drawCubeSkin9() {
  const h = PSIZ;
  const t = Date.now() * 0.008;
  // Gold/rainbow trail segments
  if (trailStyle === 0) {
  for (let i = 1; i <= 6; i++) {
    X.globalAlpha = 0.5 - i * 0.07;
    const hue = (t * 40 + i * 45) % 360;
    X.fillStyle = `hsl(${hue}, 90%, 65%)`;
    X.fillRect(-h/2 - i * 7, -h/2 + 5, 6, h - 10);
  }
  X.globalAlpha = 1;
  }
  // Golden body with glow
  X.save();
  X.shadowColor = '#ffdd44'; X.shadowBlur = 12;
  X.fillStyle = '#ffe866'; X.fillRect(-h/2, -h/2, h, h);
  X.restore();
  // White glow overlay
  X.fillStyle = 'rgba(255,255,255,0.25)'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, h - 6);
  // Sparkle accents
  const sp = Math.sin(t * 3) * 0.3 + 0.7;
  X.globalAlpha = sp;
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(-h/4, -h/4, 2, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(h/4, h/4, 1.5, 0, Math.PI * 2); X.fill();
  X.globalAlpha = 1;
  // Border
  X.strokeStyle = '#ccaa22'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Gold eye
  X.fillStyle = '#cc8800'; X.fillRect(-3, -5, 10, 8);
  X.fillStyle = '#fff'; X.fillRect(0, -3, 5, 5);
}

function drawShipSkin10() {
  const w = PSIZ * 1.2, h = PSIZ;
  const t = Date.now() * 0.008;
  // Built-in gold sparkle trail when no trail equipped
  if (trailStyle === 0) {
    for (let i = 1; i <= 6; i++) {
      X.globalAlpha = 0.5 - i * 0.07;
      X.fillStyle = i % 2 === 0 ? '#ffd600' : '#ffee66';
      X.beginPath(); X.arc(-w/2 - i * 8, Math.sin(t * 2 + i) * 3, 2.5 - i * 0.3, 0, Math.PI * 2); X.fill();
    }
    X.globalAlpha = 1;
  }
  // Gold hull body (the "1" rotated 90° CW — vertical stroke becomes horizontal hull)
  X.save();
  X.shadowColor = '#ffd600'; X.shadowBlur = 14;
  X.fillStyle = '#ffd600';
  X.beginPath();
  X.moveTo(w/2 + 4, 0);          // nose (front tip — the base of "1")
  X.lineTo(w/6, -h/3);            // top-front edge
  X.lineTo(-w/3, -h/3);           // top-rear edge
  X.lineTo(-w/3, -h/2 - 2);      // dorsal fin top (the serif/flag of "1")
  X.lineTo(-w/2 - 2, -h/3);      // dorsal fin back
  X.lineTo(-w/2, -h/3);           // rear top
  X.lineTo(-w/2, h/3);            // rear bottom
  X.lineTo(w/6, h/3);             // bottom-front edge
  X.closePath(); X.fill();
  X.restore();
  // Lighter gold overlay
  X.fillStyle = 'rgba(255,238,102,0.35)';
  X.beginPath();
  X.moveTo(w/3, 0);
  X.lineTo(0, -h/5);
  X.lineTo(-w/4, -h/5);
  X.lineTo(-w/4, h/5);
  X.lineTo(0, h/5);
  X.closePath(); X.fill();
  // Trophy in center (cup + stem + base)
  X.fillStyle = '#ffffff';
  X.beginPath();
  X.moveTo(-5, -5);   // cup top-left
  X.lineTo(5, -5);    // cup top-right
  X.lineTo(3, 1);     // cup bottom-right
  X.lineTo(-3, 1);    // cup bottom-left
  X.closePath(); X.fill();
  X.fillRect(-1, 1, 2, 3);  // stem
  X.fillRect(-3, 4, 6, 1.5); // base
  // Sparkle accents
  const sp = Math.sin(t * 3) * 0.3 + 0.7;
  X.globalAlpha = sp;
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(w/4, -h/6, 2, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(-w/5, h/5, 1.5, 0, Math.PI * 2); X.fill();
  X.globalAlpha = 1;
}

function drawCubeSkin10() {
  const h = PSIZ;
  const t = Date.now() * 0.008;
  // Built-in gold sparkle trail when no trail equipped
  if (trailStyle === 0) {
    for (let i = 1; i <= 6; i++) {
      X.globalAlpha = 0.5 - i * 0.07;
      X.fillStyle = i % 2 === 0 ? '#ffd600' : '#ffee66';
      X.fillRect(-h/2 - i * 7, -h/2 + 5, 6, h - 10);
    }
    X.globalAlpha = 1;
  }
  // Gold body with glow
  X.save();
  X.shadowColor = '#ffd600'; X.shadowBlur = 14;
  X.fillStyle = '#ffd600'; X.fillRect(-h/2, -h/2, h, h);
  X.restore();
  // White glow overlay
  X.fillStyle = 'rgba(255,238,102,0.3)'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, h - 6);
  // Large "1" text
  X.fillStyle = '#fff'; X.font = 'bold ' + Math.floor(h * 0.5) + 'px Arial';
  X.textAlign = 'center'; X.textBaseline = 'middle';
  X.fillText('1', 0, -h/8);
  // Small trophy below
  X.fillStyle = '#fff';
  X.beginPath();
  X.moveTo(-4, h/8 - 2); X.lineTo(4, h/8 - 2); X.lineTo(3, h/8 + 2); X.lineTo(-3, h/8 + 2);
  X.closePath(); X.fill();
  X.fillRect(-1, h/8 + 2, 2, 2);
  X.fillRect(-3, h/8 + 4, 6, 1);
  // Gold border
  X.strokeStyle = '#cc9900'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Sparkle accents
  const sp = Math.sin(t * 3) * 0.3 + 0.7;
  X.globalAlpha = sp;
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(-h/4, -h/4, 2, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(h/4, h/4, 1.5, 0, Math.PI * 2); X.fill();
  X.globalAlpha = 1;
}

function drawShipSkin11() {
  const w = PSIZ * 1.2, h = PSIZ;
  // Golden glow
  X.save();
  X.shadowColor = '#C89830'; X.shadowBlur = 8;
  // Body: golden blob potato shape with thick outline
  X.fillStyle = '#D4A43C';
  X.strokeStyle = '#4A3228'; X.lineWidth = 2.5;
  X.beginPath();
  X.moveTo(w/3, 0);
  X.quadraticCurveTo(w/3, -h/2.5, w/6, -h/2.8);
  X.quadraticCurveTo(-w/6, -h/2.5, -w/3, -h/3);
  X.quadraticCurveTo(-w/2 - 2, -h/4, -w/2 - 2, 0);
  X.quadraticCurveTo(-w/2 - 2, h/3, -w/3, h/3);
  X.lineTo(w/6, h/3);
  X.quadraticCurveTo(w/3, h/3, w/3, 0);
  X.closePath(); X.fill(); X.stroke();
  X.restore();
  // Protruding snout at front (rounded bump)
  X.save();
  X.shadowColor = '#C89830'; X.shadowBlur = 4;
  X.fillStyle = '#DAAF4A';
  X.beginPath();
  X.moveTo(w/4, -h/5);
  X.quadraticCurveTo(w/2 + 4, -h/5, w/2 + 4, 0);
  X.quadraticCurveTo(w/2 + 4, h/5, w/4, h/5);
  X.closePath(); X.fill();
  // Only stroke the outer curve, not the inner edge
  X.strokeStyle = '#4A3228'; X.lineWidth = 2.5;
  X.beginPath();
  X.moveTo(w/4, -h/5);
  X.quadraticCurveTo(w/2 + 4, -h/5, w/2 + 4, 0);
  X.quadraticCurveTo(w/2 + 4, h/5, w/4, h/5);
  X.stroke();
  X.restore();
  // Highlight shine on body
  X.fillStyle = 'rgba(255,240,180,0.35)';
  X.beginPath();
  X.ellipse(-w/8, -h/5, w/5, h/6, -0.2, 0, Math.PI * 2);
  X.fill();
  // Darker golden spots
  X.fillStyle = '#B8902E';
  X.beginPath(); X.ellipse(-w/6, -h/10, 3, 2, 0.3, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.ellipse(-w/4, h/6, 2.5, 1.5, -0.2, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.ellipse(0, h/8, 2, 1.5, 0.5, 0, Math.PI * 2); X.fill();
  // Stubby legs with outline
  X.fillStyle = '#D4A43C'; X.strokeStyle = '#4A3228'; X.lineWidth = 2;
  X.beginPath();
  X.moveTo(-w/5 - 3, h/3 - 2);
  X.quadraticCurveTo(-w/5 - 4, h/3 + 5, -w/5, h/3 + 5);
  X.quadraticCurveTo(-w/5 + 4, h/3 + 5, -w/5 + 3, h/3 - 2);
  X.fill(); X.stroke();
  X.beginPath();
  X.moveTo(w/8 - 3, h/3 - 2);
  X.quadraticCurveTo(w/8 - 4, h/3 + 5, w/8, h/3 + 5);
  X.quadraticCurveTo(w/8 + 4, h/3 + 5, w/8 + 3, h/3 - 2);
  X.fill(); X.stroke();
  // Tiny ear bump
  X.fillStyle = '#D4A43C'; X.strokeStyle = '#4A3228'; X.lineWidth = 2;
  X.beginPath(); X.arc(w/8, -h/2.8 - 1, 3, Math.PI, 0); X.fill(); X.stroke();
  // Small tilted oval eye
  X.fillStyle = '#2A1A10';
  X.save(); X.translate(w/4 + 2, -h/6); X.rotate(-0.3);
  X.beginPath(); X.ellipse(0, 0, 2.5, 1.8, 0, 0, Math.PI * 2); X.fill();
  X.restore();
  // Rosy cheek
  X.fillStyle = 'rgba(210,140,140,0.45)';
  X.beginPath(); X.arc(w/3 - 2, -h/14, 4, 0, Math.PI * 2); X.fill();
  // Orange on back with leaf
  X.fillStyle = '#D06030';
  X.beginPath(); X.arc(-w/10, -h/2.8 - 2, 4, 0, Math.PI * 2); X.fill();
  X.fillStyle = '#E08040';
  X.beginPath(); X.arc(-w/10, -h/2.8 - 3, 3.5, 0, Math.PI * 2); X.fill();
  X.fillStyle = '#5A8030';
  X.beginPath();
  X.moveTo(-w/10, -h/2.8 - 7);
  X.quadraticCurveTo(-w/10 + 4, -h/2.8 - 9, -w/10 + 2, -h/2.8 - 5);
  X.closePath(); X.fill();
  // "C" on body
  X.fillStyle = '#4A3228';
  X.font = 'bold ' + Math.floor(h * 0.25) + 'px Arial';
  X.textAlign = 'center'; X.textBaseline = 'middle';
  X.fillText('C', -w/6, 2);
}

function drawCubeSkin11() {
  const h = PSIZ;
  // Golden body with glow
  X.save();
  X.shadowColor = '#C89830'; X.shadowBlur = 8;
  X.fillStyle = '#D4A43C';
  X.fillRect(-h/2, -h/2, h, h);
  X.restore();
  X.strokeStyle = '#4A3228'; X.lineWidth = 2.5;
  X.strokeRect(-h/2, -h/2, h, h);
  // Shine highlight
  X.fillStyle = 'rgba(255,240,180,0.3)';
  X.fillRect(-h/2 + 3, -h/2 + 3, h/2 - 3, h/3);
  // Darker golden spots
  X.fillStyle = '#B8902E';
  X.beginPath(); X.ellipse(-h/5, h/5, 3, 2, 0.3, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.ellipse(h/6, h/4, 2, 1.5, -0.4, 0, Math.PI * 2); X.fill();
  // Tiny ear bumps
  X.fillStyle = '#D4A43C'; X.strokeStyle = '#4A3228'; X.lineWidth = 2;
  X.beginPath(); X.arc(-h/4, -h/2, 4, Math.PI, 0); X.fill(); X.stroke();
  X.beginPath(); X.arc(h/4, -h/2, 4, Math.PI, 0); X.fill(); X.stroke();
  // Rounded muzzle/snout area (lower face bump)
  X.fillStyle = '#DAAF4A';
  X.beginPath();
  X.ellipse(0, h/8, h/3.5, h/5, 0, 0, Math.PI * 2);
  X.fill();
  // Small tilted oval eyes
  X.fillStyle = '#2A1A10';
  X.save(); X.translate(-h/5, -h/6); X.rotate(-0.3);
  X.beginPath(); X.ellipse(0, 0, 3, 2, 0, 0, Math.PI * 2); X.fill();
  X.restore();
  X.save(); X.translate(h/5, -h/6); X.rotate(0.3);
  X.beginPath(); X.ellipse(0, 0, 3, 2, 0, 0, Math.PI * 2); X.fill();
  X.restore();
  // Rosy cheeks
  X.fillStyle = 'rgba(210,140,140,0.4)';
  X.beginPath(); X.arc(-h/4, -h/12, 4, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(h/4, -h/12, 4, 0, Math.PI * 2); X.fill();
  // Nose on muzzle
  X.fillStyle = '#B8902E';
  X.beginPath(); X.ellipse(0, h/8, 3, 2.5, 0, 0, Math.PI * 2); X.fill();
  // Orange on head
  X.fillStyle = '#D06030';
  X.beginPath(); X.arc(0, -h/2 - 2, 4, 0, Math.PI * 2); X.fill();
  X.fillStyle = '#E08040';
  X.beginPath(); X.arc(0, -h/2 - 3, 3.5, 0, Math.PI * 2); X.fill();
  X.fillStyle = '#5A8030';
  X.beginPath();
  X.moveTo(0, -h/2 - 7);
  X.quadraticCurveTo(4, -h/2 - 9, 2, -h/2 - 5);
  X.closePath(); X.fill();
  // "C" on lower body
  X.fillStyle = '#4A3228';
  X.font = 'bold ' + Math.floor(h * 0.22) + 'px Arial';
  X.textAlign = 'center'; X.textBaseline = 'middle';
  X.fillText('C', 0, h/3);
}

function drawPlayer() {
  if (P.dead) {
    particles.forEach(p => {
      p.x += p.vx; p.y += p.vy; p.vy += 0.3; p.life -= 0.02;
      if (p.life > 0) {
        X.globalAlpha = p.life; X.fillStyle = p.col;
        X.fillRect(p.x-p.sz/2, p.y-p.sz/2, p.sz, p.sz);
        X.globalAlpha = 1;
      }
    });
    particles = particles.filter(p => p.life > 0);
    return;
  }
  // Draw laser trail in screen space (before player rotation transform)
  if (trailStyle === 7 && laserTrail.length > 1) {
    X.save();
    X.strokeStyle = '#0ff';
    X.shadowColor = '#0ff';
    X.shadowBlur = 12;
    X.lineWidth = 3;
    X.beginPath();
    let started = false;
    for (let i = 0; i < laserTrail.length; i++) {
      const sx = laserTrail[i].wx - camX;
      if (sx < -50) continue; // skip off-screen left
      const sy = laserTrail[i].wy;
      if (!started) { X.moveTo(sx, sy); started = true; }
      else X.lineTo(sx, sy);
    }
    X.stroke();
    // Brighter white tip near current position
    if (laserTrail.length >= 2) {
      const tipLen = Math.min(20, laserTrail.length);
      X.strokeStyle = '#fff';
      X.shadowColor = '#fff';
      X.shadowBlur = 16;
      X.lineWidth = 2;
      X.beginPath();
      const startIdx = laserTrail.length - tipLen;
      X.moveTo(laserTrail[startIdx].wx - camX, laserTrail[startIdx].wy);
      for (let i = startIdx + 1; i < laserTrail.length; i++) {
        X.lineTo(laserTrail[i].wx - camX, laserTrail[i].wy);
      }
      X.stroke();
    }
    X.shadowBlur = 0;
    X.restore();
  }

  const cx = P.x+PSIZ/2, cy = P.y+PSIZ/2;
  X.save(); X.translate(cx, cy); X.rotate(P.rot * Math.PI / 180);

  // Custom trail overlay (if not default)
  if (trailStyle > 0) {
    const t = Date.now() * 0.008;
    const h = PSIZ;
    if (trailStyle === 1) { // Smoke — puffy expanding clouds
      for (let i = 0; i < 12; i++) {
        const age = (t * 0.6 + i * 0.4) % 5;
        const fx = -h/2 - 12 - i * 8;
        const fy = Math.sin(t * 0.5 + i * 0.7) * 4 - age * 1.5;
        const sz = 3 + age * 2.5 + i * 0.4;
        X.globalAlpha = Math.max(0, 0.4 - i * 0.03);
        X.fillStyle = TRAIL_COLORS[1][i % 4];
        X.beginPath(); X.arc(fx, fy, sz, 0, Math.PI * 2); X.fill();
        X.beginPath(); X.arc(fx + 3, fy - 2, sz * 0.6, 0, Math.PI * 2); X.fill();
      }
    } else if (trailStyle === 2) { // Fire — shooting flames
      // Bright core jet
      const grd = X.createLinearGradient(-h/2, 0, -h/2 - 60, 0);
      grd.addColorStop(0, 'rgba(255,255,200,0.7)');
      grd.addColorStop(0.2, 'rgba(255,220,0,0.5)');
      grd.addColorStop(0.5, 'rgba(255,100,0,0.3)');
      grd.addColorStop(1, 'rgba(255,0,0,0)');
      X.fillStyle = grd;
      const flicker = Math.sin(t * 6) * 2;
      X.beginPath();
      X.moveTo(-h/2, -h/5 + flicker);
      X.lineTo(-h/2 - 70 - Math.sin(t*4)*8, flicker * 0.5);
      X.lineTo(-h/2, h/5 + flicker);
      X.closePath(); X.fill();
      // Fire particles shooting out
      for (let i = 0; i < 14; i++) {
        const speed = 5 + i * 4;
        const fx = -h/2 - 4 - speed + Math.sin(t * 3 + i * 1.1) * (2 + i * 0.5);
        const fy = Math.sin(t * 4 + i * 1.7) * (3 + i * 0.8) + flicker * 0.3;
        const sz = Math.max(1, 6 - i * 0.35);
        X.globalAlpha = Math.max(0, 0.8 - i * 0.055);
        X.fillStyle = i < 3 ? '#ffffcc' : (i < 6 ? '#ffcc00' : (i < 10 ? '#ff6600' : '#cc2200'));
        X.beginPath(); X.arc(fx, fy, sz, 0, Math.PI * 2); X.fill();
      }
    } else if (trailStyle === 3) { // Rainbow — hue-cycling sparkles
      for (let i = 0; i < 12; i++) {
        const fx = -h/2 - 6 - i * 7 + Math.sin(t + i * 0.8) * 2;
        const fy = Math.sin(t * 1.5 + i * 1.2) * 5;
        const sz = 4 - i * 0.3;
        X.globalAlpha = 0.7 - i * 0.055;
        const hue = (t * 40 + i * 30) % 360;
        X.fillStyle = `hsl(${hue}, 90%, 65%)`;
        X.beginPath(); X.arc(fx, fy, Math.max(0.5, sz), 0, Math.PI * 2); X.fill();
      }
    } else if (trailStyle === 4) { // Candy — pieces tumbling and falling
      const candyColors = ['#ff44aa','#ff88cc','#88ddff','#ffee44','#66ff66','#ff6644'];
      for (let i = 0; i < 10; i++) {
        const seed = i * 137.5;
        const age = (t * 0.7 + seed) % 4;
        const fx = -h/2 - 6 - age * 18;
        const fy = -2 + age * age * 3 + Math.sin(seed) * 4;
        const sz = 4 - age * 0.5;
        const spin = t * 3 + seed;
        X.globalAlpha = Math.max(0, 0.8 - age * 0.18);
        X.save();
        X.translate(fx, fy);
        X.rotate(spin);
        X.fillStyle = candyColors[i % candyColors.length];
        // Alternate between circles, squares, and little stars
        if (i % 3 === 0) {
          X.beginPath(); X.arc(0, 0, sz, 0, Math.PI * 2); X.fill();
        } else if (i % 3 === 1) {
          X.fillRect(-sz, -sz, sz * 2, sz * 2);
        } else {
          X.beginPath();
          for (let p = 0; p < 5; p++) {
            const a = (p * 4 * Math.PI / 5) - Math.PI / 2;
            const r = p % 2 === 0 ? sz * 1.2 : sz * 0.5;
            if (p === 0) X.moveTo(Math.cos(a)*r, Math.sin(a)*r);
            else X.lineTo(Math.cos(a)*r, Math.sin(a)*r);
          }
          X.closePath(); X.fill();
        }
        X.restore();
      }
    } else if (trailStyle === 5) { // Snow — snowflake crystals
      for (let i = 0; i < 12; i++) {
        const phase = i / 12;  // evenly spaced 0..1
        const age = (t * 0.5 + phase * 4) % 4;
        const seed = i * 73.7; // just for visual variation
        const fx = -h/2 - 6 - age * 12;
        const fy = Math.sin(seed + t * 0.3) * 5 + age * 1.2;
        const sz = 4 - age * 0.5;
        const spin = t * 1.5 + seed;
        X.globalAlpha = Math.max(0, 0.75 - age * 0.18);
        X.strokeStyle = i % 3 === 0 ? '#ffffff' : (i % 3 === 1 ? '#cceeff' : '#aaddff');
        X.lineWidth = 0.8;
        X.save();
        X.translate(fx, fy);
        X.rotate(spin);
        // Draw 6-armed snowflake
        for (let a = 0; a < 6; a++) {
          const ang = a * Math.PI / 3;
          const cx = Math.cos(ang), sy = Math.sin(ang);
          X.beginPath(); X.moveTo(0, 0); X.lineTo(cx * sz, sy * sz); X.stroke();
          // Small branches
          X.beginPath(); X.moveTo(cx * sz * 0.5, sy * sz * 0.5);
          X.lineTo(cx * sz * 0.5 + Math.cos(ang + 0.8) * sz * 0.3, sy * sz * 0.5 + Math.sin(ang + 0.8) * sz * 0.3);
          X.stroke();
          X.beginPath(); X.moveTo(cx * sz * 0.5, sy * sz * 0.5);
          X.lineTo(cx * sz * 0.5 + Math.cos(ang - 0.8) * sz * 0.3, sy * sz * 0.5 + Math.sin(ang - 0.8) * sz * 0.3);
          X.stroke();
        }
        X.restore();
      }
    } else if (trailStyle === 7) {
      // Laser — rendered outside rotation transform (see above)
    } else if (trailStyle === 6) { // Skin Echo — spits out tumbling mini copies like candy
      for (let i = 0; i < 10; i++) {
        const seed = i * 137.5;
        const age = (t * 0.7 + seed) % 4;
        const fx = -h/2 - 6 - age * 18;
        const fy = -2 + age * age * 3 + Math.sin(seed) * 4;
        const spin = t * 3 + seed;
        const sc = 0.5 - age * 0.05;
        X.save();
        X.translate(fx, fy);
        X.rotate(spin);
        X.scale(sc, sc);
        X.globalAlpha = Math.max(0, 0.9 - age * 0.18);
        if (P.ship) {
          switch(shipSkin) {
            case 0: drawShipSkin0(); break; case 1: drawShipSkin1(); break;
            case 2: drawShipSkin2(); break; case 3: drawShipSkin3(); break;
            case 4: drawShipSkin4(); break; case 5: drawShipSkin5(); break;
            case 6: drawShipSkin6(); break; case 7: drawShipSkin7(); break;
            case 8: drawShipSkin8(); break; case 9: drawShipSkin9(); break;
            case 10: drawShipSkin10(); break;
            case 11: drawShipSkin11(); break;
          }
        } else {
          switch(shipSkin) {
            case 0: drawCubeSkin0(); break; case 1: drawCubeSkin1(); break;
            case 2: drawCubeSkin2(); break; case 3: drawCubeSkin3(); break;
            case 4: drawCubeSkin4(); break; case 5: drawCubeSkin5(); break;
            case 6: drawCubeSkin6(); break; case 7: drawCubeSkin7(); break;
            case 8: drawCubeSkin8(); break; case 9: drawCubeSkin9(); break;
            case 10: drawCubeSkin10(); break;
            case 11: drawCubeSkin11(); break;
          }
        }
        X.restore();
      }
    } else if (trailStyle === 8) { // Champion — gold "1"s and trophies tumbling
      const champColors = ['#ffd600','#ffee66','#fff','#cc9900'];
      for (let i = 0; i < 10; i++) {
        const seed = i * 137.5;
        const age = (t * 0.7 + seed) % 4;
        const fx = -h/2 - 6 - age * 18;
        const fy = -2 + age * age * 3 + Math.sin(seed) * 4;
        const sz = 4 - age * 0.5;
        const spin = t * 3 + seed;
        X.globalAlpha = Math.max(0, 0.8 - age * 0.18);
        X.save();
        X.translate(fx, fy);
        X.rotate(spin);
        X.fillStyle = champColors[i % champColors.length];
        if (i % 2 === 0) {
          // "1" text
          X.font = 'bold ' + Math.max(4, Math.floor(sz * 2.5)) + 'px Arial';
          X.textAlign = 'center'; X.textBaseline = 'middle';
          X.fillText('1', 0, 0);
        } else {
          // Trophy shape (cup trapezoid + stem + base)
          X.beginPath();
          X.moveTo(-sz, -sz);
          X.lineTo(sz, -sz);
          X.lineTo(sz * 0.6, sz * 0.3);
          X.lineTo(-sz * 0.6, sz * 0.3);
          X.closePath(); X.fill();
          X.fillRect(-sz * 0.15, sz * 0.3, sz * 0.3, sz * 0.4);
          X.fillRect(-sz * 0.5, sz * 0.7, sz, sz * 0.2);
        }
        X.restore();
      }
    }
    X.globalAlpha = 1;
  }

  if (P.ship) {
    switch (shipSkin) {
      case 0: drawShipSkin0(); break;
      case 1: drawShipSkin1(); break;
      case 2: drawShipSkin2(); break;
      case 3: drawShipSkin3(); break;
      case 4: drawShipSkin4(); break;
      case 5: drawShipSkin5(); break;
      case 6: drawShipSkin6(); break;
      case 7: drawShipSkin7(); break;
      case 8: drawShipSkin8(); break;
      case 9: drawShipSkin9(); break;
      case 10: drawShipSkin10(); break;
      case 11: drawShipSkin11(); break;
    }
  } else {
    switch (shipSkin) {
      case 0: drawCubeSkin0(); break;
      case 1: drawCubeSkin1(); break;
      case 2: drawCubeSkin2(); break;
      case 3: drawCubeSkin3(); break;
      case 4: drawCubeSkin4(); break;
      case 5: drawCubeSkin5(); break;
      case 6: drawCubeSkin6(); break;
      case 7: drawCubeSkin7(); break;
      case 8: drawCubeSkin8(); break;
      case 9: drawCubeSkin9(); break;
      case 10: drawCubeSkin10(); break;
      case 11: drawCubeSkin11(); break;
    }
  }
  X.restore();
}

// ================================================================
// MAIN LOOP
// ================================================================
function checkSpeedUp() {
  if (state !== 'playing') return;
  const elapsed = (Date.now() - gameStartTime) / 1000;
  const count = Math.floor(elapsed / 30);
  if (count > lastSpeedUpCount) {
    lastSpeedUpCount = count;
    SPEED = baseSpeed + count * 0.5;
    document.getElementById('v-speed').textContent = SPEED.toFixed(1);
    document.getElementById('s-speed').value = SPEED;
    speedUpFlash = Date.now();
  }
}

function drawSpeedUpFlash() {
  if (speedUpFlash === 0) return;
  const elapsed = Date.now() - speedUpFlash;
  if (elapsed > 1500) { speedUpFlash = 0; return; }
  const alpha = elapsed < 300 ? elapsed / 300 : Math.max(0, 1 - (elapsed - 300) / 1200);
  X.save();
  X.globalAlpha = alpha;
  X.fillStyle = '#ff4400';
  X.font = 'bold 48px Arial';
  X.textAlign = 'center';
  X.textBaseline = 'middle';
  X.shadowColor = '#ff4400';
  X.shadowBlur = 20;
  X.fillText('SPEED UP!', W / 2, H / 2 - 40);
  X.restore();
}

function drawPowerUpHUD() {
  const names = { bamboozled: 'BAMBOOZLED!', invincible: 'INVINCIBLE!', magnet: 'MAGNET!' };
  const colors = { bamboozled: '#e040fb', invincible: '#ffd600', magnet: '#0af' };
  const barW = 160, barH = 10;
  const now = Date.now();
  let slot = 0;

  X.save();
  for (const pu of ['bamboozled', 'invincible', 'magnet']) {
    if (!activePowerUps[pu] || now >= activePowerUps[pu]) continue;
    const remaining = activePowerUps[pu] - now;
    const pct = remaining / POWERUP_DURATION;
    const barX = W/2 - barW/2, barY = 56 + slot * 28;
    const col = colors[pu];

    X.fillStyle = col; X.font = 'bold 13px Arial';
    X.textAlign = 'center'; X.shadowColor = col; X.shadowBlur = 8;
    X.fillText(names[pu], W/2, barY - 4);

    X.shadowBlur = 0;
    X.fillStyle = 'rgba(0,0,0,0.5)';
    X.fillRect(barX, barY, barW, barH);
    X.fillStyle = col;
    X.fillRect(barX, barY, barW * pct, barH);
    X.strokeStyle = 'rgba(255,255,255,0.3)'; X.lineWidth = 1;
    X.strokeRect(barX, barY, barW, barH);
    slot++;
  }

  // Bamboozled purple tint
  if (hasPU('bamboozled')) {
    X.fillStyle = 'rgba(224, 64, 251, 0.04)';
    X.fillRect(0, 0, W, H);
  }

  X.restore();
}

function drawPowerUpFlash() {
  if (powerUpFlash === 0) return;
  const elapsed = Date.now() - powerUpFlash;
  const dur = 2500;
  if (elapsed > dur) { powerUpFlash = 0; return; }

  const cx = W / 2, cy = H / 2 - 30;

  if (powerUpFlashType === 'bamboozled') {
    // Green spinning "BAMBOOZLED?" letters
    const fadeIn = Math.min(1, elapsed / 300);
    const fadeOut = elapsed > dur - 600 ? Math.max(0, (dur - elapsed) / 600) : 1;
    const alpha = fadeIn * fadeOut;
    const text = 'BAMBOOZLED?';
    const spin = elapsed * 0.004; // rotation over time
    const spread = Math.min(1, elapsed / 500); // letters spread outward then settle
    X.save();
    X.globalAlpha = alpha;
    X.textAlign = 'center'; X.textBaseline = 'middle';
    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      // Each letter gets its own wobble
      const offsetAngle = (i / text.length) * Math.PI * 2 + spin;
      const wobbleY = Math.sin(offsetAngle) * 8 * spread;
      const letterRot = Math.sin(offsetAngle + i) * 0.3 * spread;
      const xOff = (i - (text.length - 1) / 2) * 32;
      // Scale up on entry
      const scale = 0.5 + spread * 0.5;
      X.save();
      X.translate(cx + xOff, cy + wobbleY);
      X.rotate(letterRot);
      X.scale(scale, scale);
      // Green glow
      X.shadowColor = '#0f0'; X.shadowBlur = 18;
      X.fillStyle = ch === '?' ? '#ffff00' : '#00ff44';
      X.font = 'bold 44px Arial';
      X.fillText(ch, 0, 0);
      // Outline
      X.strokeStyle = 'rgba(0,0,0,0.5)'; X.lineWidth = 2;
      X.strokeText(ch, 0, 0);
      X.restore();
    }
    X.restore();

  } else if (powerUpFlashType === 'magnet') {
    // "MAGNET!" with two magnets pulling coins inward
    const fadeIn = Math.min(1, elapsed / 300);
    const fadeOut = elapsed > dur - 600 ? Math.max(0, (dur - elapsed) / 600) : 1;
    const alpha = fadeIn * fadeOut;
    X.save();
    X.globalAlpha = alpha;
    X.textAlign = 'center'; X.textBaseline = 'middle';
    // Main text
    X.shadowColor = '#0af'; X.shadowBlur = 20;
    X.fillStyle = '#0af';
    X.font = 'bold 44px Arial';
    X.fillText('MAGNET!', cx, cy);
    X.strokeStyle = 'rgba(0,0,0,0.4)'; X.lineWidth = 2;
    X.strokeText('MAGNET!', cx, cy);
    // Left magnet (U-shape)
    const magnetDist = 180 + Math.sin(elapsed * 0.005) * 10;
    for (let side = -1; side <= 1; side += 2) {
      const mx = cx + side * magnetDist;
      const my = cy;
      X.save();
      X.translate(mx, my);
      if (side === 1) X.scale(-1, 1);
      // U magnet shape
      X.lineWidth = 5;
      // Red arm
      X.strokeStyle = '#ff3333';
      X.beginPath(); X.moveTo(-12, -18); X.lineTo(-12, 6);
      X.arc(0, 6, 12, Math.PI, 0, true);
      X.stroke();
      // Blue arm
      X.strokeStyle = '#3366ff';
      X.beginPath(); X.moveTo(12, 6); X.lineTo(12, -18);
      X.stroke();
      // Caps
      X.fillStyle = '#ff3333';
      X.fillRect(-15, -22, 8, 8);
      X.fillStyle = '#3366ff';
      X.fillRect(7, -22, 8, 8);
      X.restore();
    }
    // Coins flying inward toward center
    const numCoins = 8;
    for (let i = 0; i < numCoins; i++) {
      const angle = (i / numCoins) * Math.PI * 2 + elapsed * 0.002;
      const progress = ((elapsed * 0.001 + i * 0.3) % 1.5) / 1.5; // 0->1 cycle
      const dist = (1 - progress) * 140 + 20;
      const coinX = cx + Math.cos(angle) * dist;
      const coinY = cy + Math.sin(angle) * dist * 0.5;
      const coinAlpha = progress < 0.8 ? 1 : (1 - progress) / 0.2;
      X.save();
      X.globalAlpha = alpha * coinAlpha;
      X.shadowColor = '#ffd600'; X.shadowBlur = 6;
      X.fillStyle = '#ffd600';
      X.beginPath(); X.arc(coinX, coinY, 6, 0, Math.PI * 2); X.fill();
      X.fillStyle = '#ffab00';
      X.beginPath(); X.arc(coinX, coinY, 4, 0, Math.PI * 2); X.fill();
      X.restore();
    }
    X.restore();

  } else if (powerUpFlashType === 'invincible') {
    // Shield forming around text
    const fadeIn = Math.min(1, elapsed / 300);
    const fadeOut = elapsed > dur - 600 ? Math.max(0, (dur - elapsed) / 600) : 1;
    const alpha = fadeIn * fadeOut;
    const shieldGrow = Math.min(1, elapsed / 800); // shield expands over 800ms
    X.save();
    X.globalAlpha = alpha;
    X.textAlign = 'center'; X.textBaseline = 'middle';
    // Shield layers (outer to inner)
    const maxR = 90;
    const r = maxR * shieldGrow;
    // Outer glow ring
    X.shadowColor = '#ffd600'; X.shadowBlur = 30;
    X.strokeStyle = 'rgba(255,214,0,' + (0.3 * shieldGrow) + ')';
    X.lineWidth = 6;
    X.beginPath(); X.arc(cx, cy, r + 10, 0, Math.PI * 2); X.stroke();
    // Shield hex segments forming
    X.shadowBlur = 12;
    const segments = 6;
    const segAngle = Math.PI * 2 / segments;
    for (let i = 0; i < segments; i++) {
      const segProgress = Math.max(0, Math.min(1, (shieldGrow * segments - i) / 1));
      if (segProgress <= 0) continue;
      const a1 = segAngle * i - Math.PI / 2;
      const a2 = a1 + segAngle * segProgress;
      X.strokeStyle = 'rgba(255,214,0,' + (0.6 * segProgress) + ')';
      X.lineWidth = 4;
      X.beginPath(); X.arc(cx, cy, r, a1, a2); X.stroke();
      // Segment node dots
      X.fillStyle = '#ffd600';
      X.beginPath();
      X.arc(cx + Math.cos(a1) * r, cy + Math.sin(a1) * r, 3 * segProgress, 0, Math.PI * 2);
      X.fill();
    }
    // Inner shield fill
    X.fillStyle = 'rgba(255,214,0,' + (0.06 * shieldGrow) + ')';
    X.beginPath(); X.arc(cx, cy, r, 0, Math.PI * 2); X.fill();
    // Center star burst on completion
    if (shieldGrow >= 1) {
      const burstT = (elapsed - 800) * 0.003;
      const pulse = 1 + Math.sin(burstT * 3) * 0.1;
      X.fillStyle = '#ffd600'; X.font = 'bold 20px Arial';
      X.save(); X.translate(cx, cy - 40);
      X.scale(pulse, pulse);
      X.fillText('\u2605', 0, 0);
      X.restore();
    }
    // Text
    X.shadowColor = '#ffd600'; X.shadowBlur = 20;
    X.fillStyle = '#ffd600';
    X.font = 'bold 42px Arial';
    X.fillText('INVINCIBLE!', cx, cy);
    X.strokeStyle = 'rgba(0,0,0,0.4)'; X.lineWidth = 2;
    X.strokeText('INVINCIBLE!', cx, cy);
    X.restore();
  }
}

function loop() {
  try {
    X.clearRect(0, 0, W, H);
    drawBG();
    drawObjects();
    checkSpeedUp();
    update();
    drawPlayer();
    drawSpeedUpFlash();
    drawPowerUpFlash();
    drawPowerUpHUD();
  } catch(e) {
    console.error('Game error:', e);
  }
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
