<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GeoFlyer</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;display:flex;justify-content:center;align-items:center;height:100vh;overflow:hidden;font-family:'Arial',sans-serif;position:relative}
canvas{display:block}
#ui{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:flex;flex-direction:column;align-items:center}
#pbar-wrap{position:absolute;top:10px;width:280px;height:7px;background:rgba(0,0,0,0.5);border-radius:4px;overflow:hidden}
#pbar{height:100%;width:0%;background:#0f0;border-radius:4px;transition:width 0.1s}
#ptext{position:absolute;top:20px;color:#fff;font-size:13px;text-shadow:1px 1px 2px #000}
#scoreTxt{position:absolute;top:10px;left:20px;color:#0f0;font-size:18px;font-weight:bold;text-shadow:0 0 8px #0f0;pointer-events:none}
#highTxt{position:absolute;top:32px;left:20px;color:#ff0;font-size:12px;text-shadow:1px 1px 2px #000;pointer-events:none}
#coinTxt{position:absolute;top:10px;right:100px;color:#ffd600;font-size:16px;font-weight:bold;text-shadow:0 0 8px #ffd600;pointer-events:none}
#attempts{color:#ff0;font-size:13px;position:absolute;top:36px;text-shadow:1px 1px 2px #000}
#pauseBtn{position:absolute;top:8px;right:12px;pointer-events:auto;cursor:pointer;color:#fff;font-size:22px;text-shadow:1px 1px 3px #000;opacity:0.7;user-select:none}
#pauseBtn:hover{opacity:1}
#godBtn{position:absolute;top:8px;right:50px;pointer-events:auto;cursor:pointer;color:#fff;font-size:14px;text-shadow:1px 1px 3px #000;opacity:0.7;user-select:none;padding:2px 6px;border-radius:4px}
#godBtn:hover{opacity:1}
#godBtn.on{color:#0f0;opacity:1;text-shadow:0 0 8px #0f0}
#homeBtn{position:absolute;top:10px;left:50%;transform:translateX(-50%);pointer-events:auto;cursor:pointer;color:#fff;font-size:13px;text-shadow:1px 1px 3px #000;opacity:0.6;user-select:none;padding:3px 10px;border-radius:4px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);text-decoration:none;transition:all 0.15s}
#homeBtn:hover{opacity:1;border-color:#0af;color:#0af}
#keyDisplay{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);display:flex;gap:6px;pointer-events:none}
#keyDisplay .key{padding:4px 10px;border-radius:4px;font-size:13px;font-family:monospace;background:rgba(255,255,255,0.1);color:#666;border:1px solid rgba(255,255,255,0.15);transition:all 0.08s}
#keyDisplay .key.active{background:rgba(0,255,100,0.25);color:#0f0;border-color:#0f0;text-shadow:0 0 6px #0f0}
.scr{position:absolute;top:0;left:0;width:100%;height:100%;display:none;flex-direction:column;justify-content:center;align-items:center;background:rgba(0,0,0,0.75);pointer-events:auto;cursor:pointer}
#startS{display:flex}
#startS h1{color:#fff;font-size:40px;text-shadow:0 0 20px #0af,0 0 40px #07f;margin-bottom:8px}
#startS h2{color:#adf;font-size:20px;margin-bottom:24px}
.scr p{color:#ccc;font-size:16px}.scr .sub{color:#8af;font-size:13px;margin-top:6px}
#deathS h2{color:#f44;font-size:34px;text-shadow:0 0 20px #f00;margin-bottom:12px}
#deathS{cursor:default}
.death-btns{display:flex;gap:16px;margin-top:20px}
.death-btn{pointer-events:auto;padding:12px 32px;border-radius:10px;font-size:16px;font-family:'Arial',sans-serif;cursor:pointer;border:2px solid;transition:all 0.15s;font-weight:bold}
.retry-btn{background:rgba(0,255,100,0.12);border-color:#0f0;color:#0f0;text-shadow:0 0 8px #0f0}
.retry-btn:hover{background:rgba(0,255,100,0.25);transform:translateY(-2px);box-shadow:0 4px 20px rgba(0,255,100,0.3)}
.menu-btn{background:rgba(0,170,255,0.12);border-color:#0af;color:#0af;text-shadow:0 0 8px #0af}
.menu-btn:hover{background:rgba(0,170,255,0.25);transform:translateY(-2px);box-shadow:0 4px 20px rgba(0,170,255,0.3)}
#winS h2{color:#0f0;font-size:34px;text-shadow:0 0 20px #0f0;margin-bottom:12px}
#pauseS h2{color:#fff;font-size:34px;text-shadow:0 0 20px #0af;margin-bottom:12px}
#sidebar{position:fixed;top:0;right:0;width:220px;height:100vh;background:rgba(10,10,30,0.92);border-left:1px solid #2a2a50;padding:12px;overflow-y:auto;z-index:200;display:flex;flex-direction:column;gap:10px;transform:translateX(100%);transition:transform 0.25s}
#sidebar.open{transform:translateX(0)}
#sidebar h3{color:#0af;font-size:14px;margin:0;text-shadow:0 0 6px #0af}
#sidebar .divider{height:1px;background:#2a2a50;margin:2px 0}
.ctrl-row{display:flex;flex-direction:column;gap:2px}
.ctrl-row label{color:#aaa;font-size:11px;display:flex;justify-content:space-between;align-items:center}
.ctrl-row label span{color:#0f0;font-family:monospace;font-size:12px}
.ctrl-row input[type=range]{width:100%;-webkit-appearance:none;appearance:none;height:6px;border-radius:3px;background:#1a1a40;outline:none}
.ctrl-row input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:#0af;cursor:pointer}
#sidebarToggle{position:fixed;top:50%;right:0;transform:translateY(-50%);z-index:201;background:rgba(10,10,30,0.85);border:1px solid #2a2a50;border-right:none;color:#0af;font-size:16px;padding:8px 5px;cursor:pointer;border-radius:6px 0 0 6px;transition:right 0.25s}
#sidebarToggle.shifted{right:220px}
#sidebar .reset-btn{background:#1a1a40;border:1px solid #2a2a50;color:#ccc;padding:4px 10px;border-radius:4px;cursor:pointer;font-size:11px;margin-top:4px}
#sidebar .reset-btn:hover{background:#252560;border-color:#0af;color:#fff}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div id="scoreTxt">0m</div>
  <div id="highTxt">Best: 0m</div>
  <div id="coinTxt">&#9733; 0</div>
  <div id="attempts"></div>
  <a id="homeBtn" href="index.html">&#9664; MENU</a>
  <div id="godBtn" onclick="toggleGod()">GOD</div>
  <div id="pauseBtn" onclick="togglePause()">| |</div>
  <div id="keyDisplay">
    <div class="key" id="k-space">SPACE</div>
    <div class="key" id="k-up">UP</div>
    <div class="key" id="k-w">W</div>
    <div class="key" id="k-p">P</div>
    <div class="key" id="k-g">G</div>
    <div class="key" id="k-esc">ESC</div>
    <div class="key" id="k-r">R</div>
    <div class="key" id="k-h">H</div>
    <div class="key" id="k-m">M</div>
    <div class="key" id="k-c">C</div>
    <div class="key" id="k-mouse">MOUSE</div>
  </div>
</div>
<div class="scr" id="startS" onclick="onInput()">
  <h1>GEOFLYER</h1>
  <h2>Endless Mode</h2>
  <p>Click or press Space to play</p>
  <p class="sub">Hold to fly up, release to fall &bull; Survive as long as you can! &bull; P / Esc = Pause</p>
</div>
<div class="scr" id="deathS">
  <h2>YOU CRASHED!</h2>
  <p id="deathP"></p>
  <div class="death-btns">
    <button class="death-btn retry-btn" onclick="onInput()">&#9654; Play Again</button>
    <button class="death-btn menu-btn" onclick="window.location.href='index.html'">&#9664; Menu</button>
  </div>
</div>
<div class="scr" id="winS" onclick="onInput()">
  <h2>LEVEL COMPLETE!</h2>
  <p id="winI"></p>
  <p style="margin-top:12px">Click or press Space to replay</p>
</div>
<div class="scr" id="pauseS" onclick="togglePause()">
  <h2>PAUSED</h2>
  <p>Click or press P / Escape to resume</p>
</div>

<button id="sidebarToggle" onclick="toggleSidebar()">&#9881;</button>
<div id="sidebar">
  <h3>Ship Controls</h3>
  <div class="divider"></div>

  <div class="ctrl-row">
    <label>Fly Up Force <span id="v-shipUp">-0.5</span></label>
    <input type="range" id="s-shipUp" min="-1.5" max="-0.1" step="0.05" value="-0.5">
  </div>

  <div class="ctrl-row">
    <label>Gravity (fall) <span id="v-shipGrav">0.4</span></label>
    <input type="range" id="s-shipGrav" min="0.1" max="1.2" step="0.05" value="0.3">
  </div>

  <div class="ctrl-row">
    <label>Max Speed <span id="v-shipMax">7</span></label>
    <input type="range" id="s-shipMax" min="2" max="15" step="0.5" value="7">
  </div>

  <div class="divider"></div>
  <h3>Game Speed</h3>

  <div class="ctrl-row">
    <label>Scroll Speed <span id="v-speed">5.0</span></label>
    <input type="range" id="s-speed" min="1" max="12" step="0.5" value="5.0">
  </div>

  <div class="divider"></div>
  <h3>Player Size</h3>

  <div class="ctrl-row">
    <label>Size <span id="v-psiz">36</span></label>
    <input type="range" id="s-psiz" min="16" max="50" step="2" value="36">
  </div>

  <div class="divider"></div>
  <button class="reset-btn" onclick="resetDefaults()">Reset to Defaults</button>

  <div class="divider"></div>
  <h3>Debug</h3>
  <div class="ctrl-row">
    <label style="cursor:pointer">Unlock All <input type="checkbox" id="debugUnlockAll" onchange="toggleDebugUnlockAll(this.checked)" style="cursor:pointer"></label>
  </div>
</div>

<script>
const C = document.getElementById('game');
const X = C.getContext('2d');
const W = 960, H = 540;

function resize() {
  const s = Math.min(innerWidth / W, innerHeight / H);
  C.width = W; C.height = H;
  C.style.width = (W * s) + 'px';
  C.style.height = (H * s) + 'px';
}
resize();
addEventListener('resize', resize);

// ================================================================
// CONSTANTS
// ================================================================
const T = 40;
const GRAV = 0.85;
const JUMP = -11.8;
let SPEED = 5.0;
const GND = T * 11;
let SHIP_UP = -0.5;
let SHIP_GRAV = 0.3;
let SHIP_MAX = 7;
let PSIZ = T - 4;
const G = Math.floor(GND / T);
let shipSkin = parseInt(localStorage.getItem('geoflyer-skin') || '0');
const SKIN_COUNT = 10;
let trailStyle = parseInt(localStorage.getItem('geoflyer-trail') || '0');
const TRAIL_NAMES = ['None','Smoke','Fire','Rainbow','Candy','Snow','Skin Echo'];
const TRAIL_COLORS = [
  null, // none
  ['#888888','#777777','#666666','#555555'], // smoke
  ['#ff2200','#ff6600','#ff9900','#ffcc00'], // fire
  ['#ff0000','#ff8800','#ffff00','#33ff33','#0099ff','#6633ff'], // rainbow
  ['#ff44aa','#ff88cc','#88ddff','#ffee44'], // candy
  ['#aaddff','#cceeff','#ffffff','#ddeeff'], // snow
  null // skin echo (special)
];
const FREE_TRAILS = [0, 1];
function getUnlockedTrails() {
  try { return JSON.parse(localStorage.getItem('geoflyer-unlocked-trails') || '[0,1]'); }
  catch(e) { return [0,1]; }
}
function isTrailUnlocked(idx) { return FREE_TRAILS.includes(idx) || getUnlockedTrails().includes(idx); }
if (!isTrailUnlocked(trailStyle)) { trailStyle = 0; localStorage.setItem('geoflyer-trail', '0'); }

// Sidebar
function toggleSidebar() {
  const sb = document.getElementById('sidebar');
  const btn = document.getElementById('sidebarToggle');
  sb.classList.toggle('open');
  btn.classList.toggle('shifted');
}
function bindSlider(id, valId, setter) {
  const sl = document.getElementById(id);
  const vl = document.getElementById(valId);
  sl.addEventListener('input', () => { const v = parseFloat(sl.value); vl.textContent = v; setter(v); });
}
bindSlider('s-shipUp', 'v-shipUp', v => { SHIP_UP = v; });
bindSlider('s-shipGrav', 'v-shipGrav', v => { SHIP_GRAV = v; });
bindSlider('s-shipMax', 'v-shipMax', v => { SHIP_MAX = v; });
bindSlider('s-speed', 'v-speed', v => { SPEED = v; });
bindSlider('s-psiz', 'v-psiz', v => { PSIZ = v; });

function resetDefaults() {
  SHIP_UP = -0.5; SHIP_GRAV = 0.3; SHIP_MAX = 7; SPEED = 5.0; PSIZ = 36;
  document.getElementById('s-shipUp').value = -0.5; document.getElementById('v-shipUp').textContent = '-0.5';
  document.getElementById('s-shipGrav').value = 0.3; document.getElementById('v-shipGrav').textContent = '0.3';
  document.getElementById('s-shipMax').value = 7; document.getElementById('v-shipMax').textContent = '7';
  document.getElementById('s-speed').value = 5.0; document.getElementById('v-speed').textContent = '5';
  document.getElementById('s-psiz').value = 36; document.getElementById('v-psiz').textContent = '36';
}

function toggleDebugUnlockAll(on) {
  if (on) {
    sessionStorage.setItem('geoflyer-debug-backup', JSON.stringify({
      unlocked: localStorage.getItem('geoflyer-unlocked'),
      achievements: localStorage.getItem('geoflyer-achievements'),
      trails: localStorage.getItem('geoflyer-unlocked-trails')
    }));
    sessionStorage.setItem('geoflyer-debug-active', '1');
    const allSkins = [];
    for (let i = 0; i < SKIN_COUNT; i++) allSkins.push(i);
    localStorage.setItem('geoflyer-unlocked', JSON.stringify(allSkins));
    const allAchs = {};
    Object.keys(ACHIEVEMENTS).forEach(k => allAchs[k] = {time: Date.now()});
    localStorage.setItem('geoflyer-achievements', JSON.stringify(allAchs));
    const allTrails = [];
    for (let i = 0; i < TRAIL_NAMES.length; i++) allTrails.push(i);
    localStorage.setItem('geoflyer-unlocked-trails', JSON.stringify(allTrails));
  } else {
    const raw = sessionStorage.getItem('geoflyer-debug-backup');
    if (raw) {
      const backup = JSON.parse(raw);
      if (backup.unlocked) localStorage.setItem('geoflyer-unlocked', backup.unlocked);
      else localStorage.setItem('geoflyer-unlocked', JSON.stringify([0,1,2,3]));
      if (backup.achievements) localStorage.setItem('geoflyer-achievements', backup.achievements);
      else localStorage.removeItem('geoflyer-achievements');
      if (backup.trails) localStorage.setItem('geoflyer-unlocked-trails', backup.trails);
      else localStorage.setItem('geoflyer-unlocked-trails', JSON.stringify([0,1]));
    }
    sessionStorage.removeItem('geoflyer-debug-backup');
    sessionStorage.removeItem('geoflyer-debug-active');
  }
}
// Restore checkbox state on load
if (sessionStorage.getItem('geoflyer-debug-active') === '1') {
  document.getElementById('debugUnlockAll').checked = true;
}

// ================================================================
// SPACING (not used in endless - kept for compat)
// ================================================================
function sx(x) { return x; }

// ================================================================
// STATE
// ================================================================
let state = 'start', camX = 0, att = 1, particles = [];
let coinsGot = 0;
let persistentCoins = parseInt(localStorage.getItem('geoflyer-coins') || '0');
const FREE_SKINS = [0,1,2,3];
const SKIN_COSTS = {4:50, 5:100, 6:150, 7:200, 8:250};
function getUnlockedSkins() {
  try { return JSON.parse(localStorage.getItem('geoflyer-unlocked') || '[0,1,2,3]'); }
  catch(e) { return [0,1,2,3]; }
}
function isSkinUnlocked(idx) { return FREE_SKINS.includes(idx) || getUnlockedSkins().includes(idx); }
// Achievement system
const ACHIEVEMENTS = {
  'survive-1000m': { name: 'Marathon Flyer', desc: 'Survive 1000 meters', reward: 'skin', rewardSkin: 9 },
  'survive-500m': { name: 'Hot Streak', desc: 'Survive 500 meters', reward: 'trail', rewardTrail: 2 },
  'collect-100': { name: 'Coin Hoarder', desc: 'Collect 100 coins in one run', reward: 'trail', rewardTrail: 3 },
  'collect-25-run': { name: 'Sweet Tooth', desc: 'Collect 25 coins in one run', reward: 'trail', rewardTrail: 4 },
  'survive-2000m': { name: 'Blizzard Runner', desc: 'Survive 2000 meters', reward: 'trail', rewardTrail: 5 },
  'loyal-10': { name: 'Loyal Flyer', desc: 'Play same skin 10 games in a row (300m+ each)', reward: 'trail', rewardTrail: 6 }
};
function getAchievements() {
  try { return JSON.parse(localStorage.getItem('geoflyer-achievements') || '{}'); }
  catch(e) { return {}; }
}
function hasAchievement(id) { return !!getAchievements()[id]; }
function grantAchievement(id) {
  const achs = getAchievements();
  if (achs[id]) return;
  achs[id] = { time: Date.now() };
  localStorage.setItem('geoflyer-achievements', JSON.stringify(achs));
  const ach = ACHIEVEMENTS[id];
  if (ach && ach.reward === 'skin') {
    const unlocked = getUnlockedSkins();
    if (!unlocked.includes(ach.rewardSkin)) {
      unlocked.push(ach.rewardSkin);
      localStorage.setItem('geoflyer-unlocked', JSON.stringify(unlocked));
    }
  }
  if (ach && ach.reward === 'trail') {
    const unlocked = getUnlockedTrails();
    if (!unlocked.includes(ach.rewardTrail)) {
      unlocked.push(ach.rewardTrail);
      localStorage.setItem('geoflyer-unlocked-trails', JSON.stringify(unlocked));
    }
  }
  showAchievementPopup(ach);
}
let achPopup = null;
function showAchievementPopup(ach) {
  if (achPopup) achPopup.remove();
  achPopup = document.createElement('div');
  achPopup.style.cssText = 'position:fixed;top:60px;left:50%;transform:translateX(-50%);background:rgba(10,10,40,0.92);border:2px solid #ffd600;border-radius:12px;padding:14px 28px;color:#ffd600;font-size:16px;font-weight:bold;text-shadow:0 0 8px #ffd600;z-index:500;pointer-events:none;transition:opacity 0.5s;';
  achPopup.textContent = 'Achievement Unlocked: ' + ach.name + '!';
  document.body.appendChild(achPopup);
  setTimeout(() => { achPopup.style.opacity = '0'; }, 2500);
  setTimeout(() => { achPopup.remove(); achPopup = null; }, 3200);
}
// Validate shipSkin on load — reset to 0 if locked
if (!isSkinUnlocked(shipSkin)) { shipSkin = 0; localStorage.setItem('geoflyer-skin', '0'); }
let inputDown = false, inputTap = false, holdJump = false;
let canRestart = false;
let godMode = false;
let showHitboxes = false;
let P = { x: 120, y: GND/2 - PSIZ/2, vy: 0, rot: 0, onG: false, dead: false, ship: true };

// ================================================================
// INPUT
// ================================================================
function onInput() {
  if (state === 'start') { hide('startS'); startGame(); }
  else if (state === 'dead' && canRestart) { hide('deathS'); att++; startGame(); }
  else if (state === 'won' && canRestart) { hide('winS'); att = 1; startGame(); }
}

function toggleGod() {
  godMode = !godMode;
  const btn = document.getElementById('godBtn');
  btn.classList.toggle('on', godMode);
  btn.textContent = godMode ? 'GOD ON' : 'GOD';
}

function forceRestart() {
  hide('deathS'); hide('winS'); hide('pauseS'); hide('startS');
  att++;
  startGame();
}

function toggleHitboxes() {
  showHitboxes = !showHitboxes;
}

function togglePause() {
  if (state === 'playing') {
    state = 'paused';
    show('pauseS');
  } else if (state === 'paused') {
    state = 'playing';
    hide('pauseS');
  }
}

function hide(id) { document.getElementById(id).style.display = 'none'; }
function show(id) { document.getElementById(id).style.display = 'flex'; }

function keyOn(id) { document.getElementById(id).classList.add('active'); }
function keyOff(id) { document.getElementById(id).classList.remove('active'); }
function keyFlash(id) { keyOn(id); setTimeout(() => keyOff(id), 150); }

document.addEventListener('keydown', e => {
  if (e.code === 'Escape') { keyFlash('k-esc'); e.preventDefault(); togglePause(); return; }
  if (e.key === 'p' || e.key === 'P') { keyFlash('k-p'); e.preventDefault(); togglePause(); return; }
  if (e.key === 'g' || e.key === 'G') { keyFlash('k-g'); toggleGod(); return; }
  if (e.key === 'r' || e.key === 'R') { keyFlash('k-r'); forceRestart(); return; }
  if (e.key === 'h' || e.key === 'H') { keyFlash('k-h'); toggleHitboxes(); return; }
  if (e.key === 'c' || e.key === 'C') { keyFlash('k-c'); let tries = 0; do { shipSkin = (shipSkin + 1) % SKIN_COUNT; tries++; } while (!isSkinUnlocked(shipSkin) && tries < SKIN_COUNT); localStorage.setItem('geoflyer-skin', shipSkin); return; }
  if (e.key === 'm' || e.key === 'M') { keyFlash('k-m'); window.location.href = 'index.html'; return; }
  if (e.code === 'Space') { keyOn('k-space'); e.preventDefault(); inputDown = true; holdJump = true; inputTap = true; onInput(); }
  if (e.code === 'ArrowUp') { keyOn('k-up'); e.preventDefault(); inputDown = true; holdJump = true; inputTap = true; onInput(); }
  if (e.key === 'w' || e.key === 'W') { keyOn('k-w'); e.preventDefault(); inputDown = true; holdJump = true; inputTap = true; onInput(); }
});
document.addEventListener('keyup', e => {
  if (e.code === 'Space') keyOff('k-space');
  if (e.code === 'ArrowUp') keyOff('k-up');
  if (e.key === 'w' || e.key === 'W') keyOff('k-w');
  if (['Space','ArrowUp'].includes(e.code) || e.key === 'w' || e.key === 'W') { inputDown = false; holdJump = false; }
});
C.addEventListener('mousedown', () => { keyOn('k-mouse'); inputDown = true; holdJump = true; inputTap = true; onInput(); });
C.addEventListener('mouseup', () => { keyOff('k-mouse'); inputDown = false; holdJump = false; });
C.addEventListener('touchstart', e => { e.preventDefault(); keyOn('k-mouse'); inputDown = true; holdJump = true; inputTap = true; onInput(); }, {passive:false});
C.addEventListener('touchend', e => { e.preventDefault(); keyOff('k-mouse'); inputDown = false; holdJump = false; }, {passive:false});

// ================================================================
// LEVEL OBJECTS - helpers apply sx() spacing
// ================================================================
const L = [];
const blockSet = new Set();
function addObj(t, tx, ty, extra) {
  const key = tx + ',' + ty;
  // Track block positions; skip duplicates
  if (t === 'B') {
    if (blockSet.has(key)) return;
    blockSet.add(key);
  }
  // Delete spikes that overlap with a block
  if (t === 'S' || t === 'SS' || t === 'CS' || t === 'SCS') {
    if (blockSet.has(key)) return;
  }
  L.push({ t, x: tx, y: ty, ...(extra||{}) });
}

// Single-tile objects: scale x with sx()
function blk(tx, ty) { addObj('B', sx(tx), ty); }
function spike(tx) { addObj('S', sx(tx), G - 1); }
function spikeAt(tx, ty) { addObj('S', sx(tx), ty); }
function cspike(tx) { addObj('CS', sx(tx), 0); }
function cspikeAt(tx, ty) { addObj('CS', sx(tx), ty); }
function deco(tx, ty) { addObj('D', sx(tx), ty); }
function pad(tx, ty) { addObj('P', sx(tx), ty); }
function shipPortal(tx) { addObj('PO', sx(tx), G - 3); }
function cubePortal(tx) { addObj('PC', sx(tx), G - 3); }
function hangSpike(tx, ty) { addObj('HG', sx(tx), ty); }
function fire(tx) { addObj('FR', sx(tx), G - 1); }
function smiley(tx, ty) { addObj('SM', sx(tx), ty); }
function coin(tx, ty) { addObj('CN', sx(tx), ty); }

// Multi-tile: scale START position, keep internal tiles consecutive
function plat(tx, ty, w) { const st = sx(tx); for (let i = 0; i < w; i++) addObj('B', st + i, ty); }
function pillar(tx, h) { const st = sx(tx); for (let i = 0; i < h; i++) addObj('B', st, G - 1 - i); }
function decoPlat(tx, ty, w) { const st = sx(tx); for (let i = 0; i < w; i++) addObj('D', st + i, ty); }

// ================================================================
// PROCEDURAL LEVEL GENERATOR - Endless Mode
// ================================================================
let genX = 20; // next tile x to generate at
let gndSpikeX = 0; // next tile x for ground spike generation
let ceilGenX = 0; // next tile x for ceiling block generation
let ceilSpikeX = 0; // next tile x for ceiling spike generation
let ceilBumpX = 0; // next tile x for ceiling bump generation
let coinGenX = 30; // next tile x for coin line generation
let highScore = 0;
try { highScore = parseInt(localStorage.getItem('endless-high') || '0'); } catch(e) {}

// Ceiling occupies rows 0-2; floor obstacles must leave at least 4 rows of gap below row 3
const MAX_FLOOR_H = G - 3 - 4; // = 4 for G=11

// Difficulty ramps with distance: 0 = easy, 1 = hardest
function diff() { return Math.min(1, camX / 40000); }

// Seeded-ish random per generation call
function rng() { return Math.random(); }
function rngInt(min, max) { return min + Math.floor(rng() * (max - min + 1)); }
function pick(arr) { return arr[Math.floor(rng() * arr.length)]; }
// Gap after each obstacle - more breathing room
function gap() { const d = diff(); return rngInt(Math.max(4, Math.floor(6 - d * 2)), Math.max(6, Math.floor(10 - d * 4))); }

// Helper: fill a rectangle of blocks
function blockRect(x, y, w, h) {
  for (let i = 0; i < w; i++)
    for (let j = 0; j < h; j++)
      addObj('B', x + i, y + j);
}
// Helper: add stepped columns to sides of a floor structure (pyramid-style edges)
// Structure sits on ground (bottom = G-1), top at topRow. Steps go outward+down.
function floorSteps(x, topRow, w) {
  const structH = G - topRow;
  const stepsL = Math.min(rngInt(1, 3), structH - 1);
  const stepsR = Math.min(rngInt(1, 3), structH - 1);
  for (let s = 1; s <= stepsL; s++) {
    const colH = structH - s;
    if (colH <= 0) break;
    blockRect(x - s, G - colH, 1, colH);
  }
  for (let s = 1; s <= stepsR; s++) {
    const colH = structH - s;
    if (colH <= 0) break;
    blockRect(x + w - 1 + s, G - colH, 1, colH);
  }
}
// Helper: add stepped columns to sides of a ceiling structure (inverted pyramid edges)
// Structure starts at topRow with height h. Steps go outward+up.
function ceilSteps(x, topRow, w, h) {
  const stepsL = Math.min(rngInt(1, 3), h - 1);
  const stepsR = Math.min(rngInt(1, 3), h - 1);
  for (let s = 1; s <= stepsL; s++) {
    const colH = h - s;
    if (colH <= 0) break;
    blockRect(x - s, topRow, 1, colH);
  }
  for (let s = 1; s <= stepsR; s++) {
    const colH = h - s;
    if (colH <= 0) break;
    blockRect(x + w - 1 + s, topRow, 1, colH);
  }
}
// Helper: build a pyramid from floor — cx is center tile, h is height
function buildPyramid(cx, h) {
  for (let row = 0; row < h; row++) {
    const rowW = 1 + row * 2;
    const startX = cx - row;
    for (let i = 0; i < rowW; i++)
      addObj('B', startX + i, G - h + row);
  }
  return 1 + (h - 1) * 2; // returns base width
}
// Helper: build an inverted pyramid from ceiling — cx is center tile, h is height
function buildInvertPyramid(cx, h) {
  for (let row = 0; row < h; row++) {
    const rowW = 1 + row * 2;
    const startX = cx - row;
    for (let i = 0; i < rowW; i++)
      addObj('B', startX + i, h - 1 - row);
  }
  return 1 + (h - 1) * 2;
}
// Helper: row of mixed spikes on top of blocks (pointing up) — randomly big or small
function spikeRowAbove(x, y, w) {
  for (let i = 0; i < w; i++) addObj(rng() < 0.5 ? 'S' : 'SS', x + i, y);
}
// Helper: row of mixed spikes below blocks (pointing down) — randomly big or small
function spikeRowBelow(x, y, w) {
  for (let i = 0; i < w; i++) addObj(rng() < 0.5 ? 'CS' : 'SCS', x + i, y);
}
// Helper: row of ONLY small spikes (for tight facing gaps)
function smallSpikeRowAbove(x, y, w) {
  for (let i = 0; i < w; i++) addObj('SS', x + i, y);
}
function smallSpikeRowBelow(x, y, w) {
  for (let i = 0; i < w; i++) addObj('SCS', x + i, y);
}

// ========== OBSTACLE PATTERNS ==========
// Rule: ALL spikes must be directly adjacent to a block surface. No floating spikes.
const patterns = [

  // --- PYRAMID: triangular block mass from floor, spikes on top ---
  function pyramidFloor() {
    const h = rngInt(2, Math.min(MAX_FLOOR_H, 4 + Math.floor(diff())));
    if (h >= G - 3) return 0;
    const cx = genX + h;
    const baseW = buildPyramid(cx, h);
    // spikes along all exposed step edges
    for (let row = 0; row < h; row++) {
      const spikeY = G - h + row - 1;
      if (spikeY < 0) continue;
      if (row === 0) {
        addObj(rng() < 0.5 ? 'S' : 'SS', cx, spikeY);
      } else {
        addObj(rng() < 0.5 ? 'S' : 'SS', cx - row, spikeY);
        addObj(rng() < 0.5 ? 'S' : 'SS', cx + row, spikeY);
      }
    }
    return baseW + gap();
  },

  // --- INVERTED PYRAMID: triangular mass from ceiling ---
  function pyramidCeiling() {
    const h = rngInt(2, 4 + Math.floor(diff()));
    if (h >= G - 3) return 0;
    const cx = genX + h;
    const baseW = buildInvertPyramid(cx, h);
    // spikes along all exposed step edges (inverted)
    for (let row = 0; row < h; row++) {
      const spikeY = h - row;
      if (row === 0) {
        addObj(rng() < 0.5 ? 'CS' : 'SCS', cx, spikeY);
      } else {
        addObj(rng() < 0.5 ? 'CS' : 'SCS', cx - row, spikeY);
        addObj(rng() < 0.5 ? 'CS' : 'SCS', cx + row, spikeY);
      }
    }
    return baseW + gap();
  },

  // --- PILLAR: column from floor with stepped edges, fly over ---
  function floorPillar() {
    const w = rngInt(2, 3);
    const h = rngInt(2, Math.min(MAX_FLOOR_H, 5 + Math.floor(diff())));
    if (h >= G - 3) return 0;
    blockRect(genX, G - h, w, h);
    floorSteps(genX, G - h, w);
    spikeRowAbove(genX, G - h - 1, w);
    return w + gap();
  },

  // --- PILLAR: column from ceiling with stepped edges, fly under ---
  function ceilingPillar() {
    const w = rngInt(2, 3);
    const h = rngInt(3, 5 + Math.floor(diff()));
    if (h >= G - 3) return 0;
    blockRect(genX, 0, w, h);
    ceilSteps(genX, 0, w, h);
    spikeRowBelow(genX, h, w);
    return w + gap();
  },

  // --- GATE: floor + ceiling pillars with stepped edges, gap to fly through ---
  function gatePillar() {
    const w = rngInt(2, 4);
    const floorH = rngInt(2, 3 + Math.floor(diff()));
    const ceilH = rngInt(2, 3 + Math.floor(diff()));
    const openRows = G - floorH - ceilH;
    if (openRows < 4) return 0;
    blockRect(genX, G - floorH, w, floorH);
    floorSteps(genX, G - floorH, w);
    blockRect(genX, 0, w, ceilH);
    ceilSteps(genX, 0, w, ceilH);
    smallSpikeRowAbove(genX, G - floorH - 1, w);
    smallSpikeRowBelow(genX, ceilH, w);
    return w + gap();
  },

  // --- ALT PILLARS: floor then ceiling pillar — weave up and down ---
  function altPillars() {
    const w = rngInt(2, 3);
    const spacing = rngInt(5, 8);
    const fh = rngInt(2, Math.min(MAX_FLOOR_H, 5 + Math.floor(diff())));
    const ch = rngInt(3, 5 + Math.floor(diff()));
    if (fh >= G - 3 || ch >= G - 3) return 0;
    blockRect(genX, G - fh, w, fh);
    floorSteps(genX, G - fh, w);
    spikeRowAbove(genX, G - fh - 1, w);
    const cx = genX + w + spacing;
    blockRect(cx, 0, w, ch);
    ceilSteps(cx, 0, w, ch);
    spikeRowBelow(cx, ch, w);
    return w * 2 + spacing + gap();
  },

  // --- ENCLOSED TUNNEL: floor + ceiling corridor ---
  function enclosedTunnel() {
    const w = rngInt(6, 12);
    const floorH = rngInt(2, 3);
    const ceilH = rngInt(2, 3);
    const openRows = G - floorH - ceilH;
    if (openRows < 4) return 0;
    blockRect(genX, 0, w, ceilH);
    blockRect(genX, G - floorH, w, floorH);
    smallSpikeRowBelow(genX, ceilH, w);
    smallSpikeRowAbove(genX, G - floorH - 1, w);
    return w + gap();
  },

  // --- TUNNEL WITH PILLAR: corridor with a stepped pillar inside ---
  function tunnelWithPillar() {
    const w = rngInt(10, 14);
    const floorH = rngInt(2, 3);
    const ceilH = rngInt(2, 3);
    const openRows = G - floorH - ceilH;
    if (openRows < 6) return 0;
    blockRect(genX, 0, w, ceilH);
    blockRect(genX, G - floorH, w, floorH);
    const pillarX = genX + rngInt(4, w - 5);
    const pillarW = 2;
    if (rng() < 0.5) {
      const ph = rngInt(2, openRows - 4);
      blockRect(pillarX, G - floorH - ph, pillarW, ph);
      floorSteps(pillarX, G - floorH - ph, pillarW);
      spikeRowAbove(pillarX, G - floorH - ph - 1, pillarW);
    } else {
      const ph = rngInt(2, openRows - 4);
      blockRect(pillarX, ceilH, pillarW, ph);
      ceilSteps(pillarX, ceilH, pillarW, ph);
      spikeRowBelow(pillarX, ceilH + ph, pillarW);
    }
    return w + gap();
  },

  // --- STAIRCASE UP: ascending steps from floor ---
  function staircaseUp() {
    const steps = rngInt(2, Math.min(MAX_FLOOR_H, 4));
    const stepW = rngInt(2, 3);
    let ox = 0;
    for (let s = 0; s < steps; s++) {
      const h = s + 1;
      if (h > MAX_FLOOR_H) break;
      blockRect(genX + ox, G - h, stepW, h);
      spikeRowAbove(genX + ox, G - h - 1, stepW);
      ox += stepW;
    }
    return ox + gap();
  },

  // --- STAIRCASE DOWN: descending steps from ceiling ---
  function staircaseDown() {
    const steps = rngInt(3, 5);
    const stepW = rngInt(2, 3);
    let ox = 0;
    for (let s = 0; s < steps; s++) {
      const h = s + 1;
      if (h >= G - 3) break;
      blockRect(genX + ox, 0, stepW, h);
      spikeRowBelow(genX + ox, h, stepW);
      ox += stepW;
    }
    return ox + gap();
  },

  // --- WALL WITH WINDOW: solid wall with stepped edges, opening to fly through ---
  function wallWithWindow() {
    const w = rngInt(2, 4);
    const winH = 4;
    const winRow = rngInt(3, G - winH - 2);
    for (let i = 0; i < w; i++) {
      for (let j = 0; j < winRow; j++) addObj('B', genX + i, j);
      for (let j = winRow + winH; j < G; j++) addObj('B', genX + i, j);
    }
    // stepped edges on the wall sections
    ceilSteps(genX, 0, w, winRow);
    floorSteps(genX, winRow + winH, w);
    smallSpikeRowBelow(genX, winRow, w);
    smallSpikeRowAbove(genX, winRow + winH - 1, w);
    return w + gap();
  },

  // --- L-SHAPE FLOOR: base with a stepped tower on one side ---
  function lShapeFloor() {
    const baseW = rngInt(4, 6);
    const baseH = rngInt(1, 2);
    const towerW = 2;
    const towerH = rngInt(2, Math.min(MAX_FLOOR_H - baseH, 4 + Math.floor(diff())));
    if (towerH < 1 || baseH + towerH >= G - 3) return 0;
    const towerSide = rng() < 0.5 ? 0 : baseW - towerW;
    blockRect(genX, G - baseH, baseW, baseH);
    blockRect(genX + towerSide, G - baseH - towerH, towerW, towerH);
    floorSteps(genX + towerSide, G - baseH - towerH, towerW);
    for (let i = 0; i < baseW; i++) {
      if (i >= towerSide && i < towerSide + towerW) continue;
      addObj(rng() < 0.5 ? 'S' : 'SS', genX + i, G - baseH - 1);
    }
    spikeRowAbove(genX + towerSide, G - baseH - towerH - 1, towerW);
    return baseW + gap();
  },

  // --- L-SHAPE CEILING: ceiling base with stepped tower hanging down ---
  function lShapeCeiling() {
    const baseW = rngInt(4, 6);
    const baseH = rngInt(1, 2);
    const towerW = 2;
    const towerH = rngInt(2, 4 + Math.floor(diff()));
    if (baseH + towerH >= G - 3) return 0;
    const towerSide = rng() < 0.5 ? 0 : baseW - towerW;
    blockRect(genX, 0, baseW, baseH);
    blockRect(genX + towerSide, baseH, towerW, towerH);
    ceilSteps(genX + towerSide, baseH, towerW, towerH);
    for (let i = 0; i < baseW; i++) {
      if (i >= towerSide && i < towerSide + towerW) continue;
      addObj(rng() < 0.5 ? 'CS' : 'SCS', genX + i, baseH);
    }
    spikeRowBelow(genX + towerSide, baseH + towerH, towerW);
    return baseW + gap();
  },

  // --- NARROWING CORRIDOR: enclosed path that gets tighter ---
  function narrowingCorridor() {
    const w = rngInt(6, 10);
    const startGap = Math.min(G - 2, rngInt(7, 9));
    const endGap = Math.max(5, startGap - rngInt(1, 2 + Math.floor(diff())));
    for (let i = 0; i < w; i++) {
      const t = i / (w - 1);
      const gapH = Math.round(startGap + (endGap - startGap) * t);
      const ceilH = Math.floor((G - gapH) / 2);
      const floorH = G - gapH - ceilH;
      for (let j = 0; j < ceilH; j++) addObj('B', genX + i, j);
      for (let j = 0; j < floorH; j++) addObj('B', genX + i, G - 1 - j);
    }
    return w + gap();
  },

  // --- U-SHAPE: walls with stepped edges and spiked floor ---
  function uShape() {
    const w = rngInt(6, 10);
    const wallH = rngInt(2, Math.min(MAX_FLOOR_H, 4 + Math.floor(diff())));
    if (wallH >= G - 3) return 0;
    const wallW = 2;
    blockRect(genX, G - wallH, wallW, wallH);
    floorSteps(genX, G - wallH, wallW);
    spikeRowAbove(genX, G - wallH - 1, wallW);
    blockRect(genX + w - wallW, G - wallH, wallW, wallH);
    floorSteps(genX + w - wallW, G - wallH, wallW);
    spikeRowAbove(genX + w - wallW, G - wallH - 1, wallW);
    blockRect(genX + wallW, G - 1, w - wallW * 2, 1);
    spikeRowAbove(genX + wallW, G - 2, w - wallW * 2);
    return w + gap();
  },

  // --- SHELF ROOM: corridor with a shelf creating upper/lower paths ---
  function shelfRoom() {
    const w = rngInt(8, 12);
    const floorH = rngInt(2, 3);
    const ceilH = rngInt(2, 3);
    const openRows = G - floorH - ceilH;
    if (openRows < 6) return 0;
    blockRect(genX, 0, w, ceilH);
    blockRect(genX, G - floorH, w, floorH);
    const shelfGap = rngInt(2, 3);
    const shelfW = w - shelfGap * 2;
    if (shelfW < 3) return 0;
    const shelfRow = ceilH + Math.floor(openRows / 2);
    blockRect(genX + shelfGap, shelfRow, shelfW, 1);
    spikeRowAbove(genX + shelfGap, shelfRow - 1, shelfW);
    spikeRowBelow(genX + shelfGap, shelfRow + 1, shelfW);
    return w + gap();
  },

  // --- DOUBLE STAIRCASE: floor up + ceiling down, diamond shape ---
  function doubleStaircase() {
    if (diff() < 0.15) return 0;
    const steps = rngInt(2, 3);
    const stepW = 2;
    let ox = 0;
    for (let s = 0; s < steps; s++) {
      const floorH = s + 1;
      const ceilH = s + 1;
      if (floorH + ceilH >= G - 4) break;
      blockRect(genX + ox, G - floorH, stepW, floorH);
      blockRect(genX + ox, 0, stepW, ceilH);
      ox += stepW;
    }
    for (let s = steps - 1; s >= 0; s--) {
      const floorH = s + 1;
      const ceilH = s + 1;
      blockRect(genX + ox, G - floorH, stepW, floorH);
      blockRect(genX + ox, 0, stepW, ceilH);
      ox += stepW;
    }
    return ox + gap();
  },

  // --- OVERHANG: ceiling block with floor base, stepped edges ---
  function overhang() {
    const w = rngInt(5, 8);
    const floorH = rngInt(2, 3);
    const ceilH = rngInt(2, 3);
    const openRows = G - floorH - ceilH;
    if (openRows < 5) return 0;
    blockRect(genX, G - floorH, w, floorH);
    const ceilW = rngInt(3, w - 2);
    const ceilOff = rng() < 0.5 ? 0 : w - ceilW;
    blockRect(genX + ceilOff, 0, ceilW, ceilH);
    ceilSteps(genX + ceilOff, 0, ceilW, ceilH);
    smallSpikeRowBelow(genX + ceilOff, ceilH, ceilW);
    smallSpikeRowAbove(genX, G - floorH - 1, w);
    return w + gap();
  },

  // --- ENCLOSED ROOM: walls with openings at different heights ---
  function enclosedRoom() {
    if (diff() < 0.1) return 0;
    const roomW = rngInt(8, 12);
    const wallW = 2;
    const floorH = rngInt(2, 3);
    const ceilH = rngInt(2, 3);
    blockRect(genX, 0, roomW, ceilH);
    blockRect(genX, G - floorH, roomW, floorH);
    const entryOpen = rngInt(ceilH + 1, G - floorH - 4);
    for (let j = ceilH; j < G - floorH; j++) {
      if (j >= entryOpen && j < entryOpen + 3) continue;
      for (let i = 0; i < wallW; i++) addObj('B', genX + i, j);
    }
    const exitOpen = rngInt(ceilH + 1, G - floorH - 4);
    for (let j = ceilH; j < G - floorH; j++) {
      if (j >= exitOpen && j < exitOpen + 3) continue;
      for (let i = 0; i < wallW; i++) addObj('B', genX + roomW - wallW + i, j);
    }
    return roomW + gap();
  },

  // --- TIGHT CORRIDOR: long enclosed section with bumps ---
  function tightCorridor() {
    const w = rngInt(10, 16);
    const ceilH = rngInt(3, 4);
    const floorH = rngInt(2, 3);
    const openRows = G - ceilH - floorH;
    if (openRows < 4) return 0;
    blockRect(genX, 0, w, ceilH);
    blockRect(genX, G - floorH, w, floorH);
    // Add a bump from ceiling or floor midway
    const bumpX = genX + rngInt(3, w - 4);
    const bumpW = rngInt(2, 3);
    if (rng() < 0.5) {
      const bh = rngInt(1, 2);
      if (ceilH + bh + 3 < G - floorH) {
        blockRect(bumpX, ceilH, bumpW, bh);
        spikeRowBelow(bumpX, ceilH + bh, bumpW);
      }
    } else {
      const bh = rngInt(1, 2);
      if (floorH + bh + 3 < G - ceilH) {
        blockRect(bumpX, G - floorH - bh, bumpW, bh);
        spikeRowAbove(bumpX, G - floorH - bh - 1, bumpW);
      }
    }
    smallSpikeRowBelow(genX, ceilH, w);
    smallSpikeRowAbove(genX, G - floorH - 1, w);
    return w + gap();
  },

  // --- BIG STEPPED MASS: large structure with staircase edge, like GD screenshot ---
  function steppedMass() {
    const baseW = rngInt(6, 10);
    const maxH = rngInt(3, Math.min(MAX_FLOOR_H, 6 + Math.floor(diff())));
    if (maxH >= G - 3) return 0;
    const fromFloor = rng() < 0.5;
    const stairSide = rng() < 0.5 ? 'left' : 'right';
    // build stepped structure: one side is flat, other steps down
    for (let col = 0; col < baseW; col++) {
      let colH;
      if (stairSide === 'left') {
        colH = Math.min(maxH, col + 1); // grows from left
      } else {
        colH = Math.min(maxH, baseW - col); // grows from right
      }
      if (fromFloor) {
        blockRect(genX + col, G - colH, 1, colH);
      } else {
        blockRect(genX + col, 0, 1, colH);
      }
    }
    // spikes along the top/bottom edge
    if (fromFloor) {
      for (let col = 0; col < baseW; col++) {
        const colH = stairSide === 'left' ? Math.min(maxH, col + 1) : Math.min(maxH, baseW - col);
        addObj(rng() < 0.5 ? 'S' : 'SS', genX + col, G - colH - 1);
      }
    } else {
      for (let col = 0; col < baseW; col++) {
        const colH = stairSide === 'left' ? Math.min(maxH, col + 1) : Math.min(maxH, baseW - col);
        addObj(rng() < 0.5 ? 'CS' : 'SCS', genX + col, colH);
      }
    }
    return baseW + gap();
  }
];
// Boost tunnel-type patterns for enclosed feel (indices: 4=gate, 6=enclosedTunnel, 7=tunnelWithPillar, 10=wallWithWindow, 13=narrowingCorridor, 18=enclosedRoom, 20=tightCorridor)
[4, 6, 7, 10, 13, 18, 20].forEach(i => { if (patterns[i]) patterns.push(patterns[i]); });

function generateAhead() {
  const aheadTile = Math.floor((camX + W + T * 10) / T);
  let safety = 0;
  while (genX < aheadTile && safety < 50) {
    safety++;
    const pat = pick(patterns);
    const used = pat();
    if (used > 0) genX += used;
    else genX += Math.max(3, gap());
  }
  // Tunnel ceiling: 2 blocks thick (rows 0-1) + spikes at row 2
  while (ceilGenX < aheadTile) {
    addObj('B', ceilGenX, 0);
    addObj('B', ceilGenX, 1);
    ceilGenX++;
  }
  // Ceiling spikes — skip if column has any floor blocks in upper half (would block path)
  while (ceilSpikeX < aheadTile) {
    let blocked = false;
    for (let r = 3; r <= 6; r++) {
      if (blockSet.has(ceilSpikeX + ',' + r)) { blocked = true; break; }
    }
    if (!blocked && rng() < 0.4) {
      addObj(rng() < 0.5 ? 'CS' : 'SCS', ceilSpikeX, 2);
    }
    ceilSpikeX++;
  }
  // Ceiling bumps — skip if column has floor blocks nearby
  while (ceilBumpX < aheadTile) {
    let blocked = false;
    for (let r = 3; r <= 6; r++) {
      if (blockSet.has(ceilBumpX + ',' + r)) { blocked = true; break; }
    }
    if (!blocked && rng() < 0.08) {
      const bw = rngInt(1, 2);
      for (let i = 0; i < bw; i++) addObj('B', ceilBumpX + i, 2);
      ceilBumpX += bw + rngInt(6, 12);
    }
    ceilBumpX++;
  }
  // Scatter ground spikes — skip if column already has floor blocks above ground
  while (gndSpikeX < aheadTile) {
    const hasBlock = blockSet.has(gndSpikeX + ',' + (G - 1)) || blockSet.has(gndSpikeX + ',' + (G - 2));
    if (!hasBlock && rng() < 0.35) {
      addObj(rng() < 0.5 ? 'S' : 'SS', gndSpikeX, G - 1);
    }
    gndSpikeX++;
  }
  // Coins — random single coins or small groups, less frequent
  while (coinGenX < aheadTile) {
    if (rng() < 0.06) {
      // Pick a row in the safe flying zone (rows 4-8)
      const row = rngInt(4, G - 3);
      const count = rngInt(1, 3); // 1-3 coins instead of always 5
      // Check columns are clear of blocks and spikes
      let clear = true;
      for (let i = 0; i < count; i++) {
        const cx = coinGenX + i;
        for (let r = row - 1; r <= row + 1; r++) {
          if (blockSet.has(cx + ',' + r)) { clear = false; break; }
        }
        if (!clear) break;
      }
      if (clear) {
        for (let i = 0; i < count; i++) {
          addObj('CN', coinGenX + i, row);
        }
        coinGenX += count + rngInt(25, 50);
        continue;
      }
    }
    coinGenX++;
  }
}

function cleanupBehind() {
  const behindTile = Math.floor((camX - T * 5) / T);
  while (L.length > 0 && L[0].x < behindTile) {
    const obj = L.shift();
    if (obj.t === 'B') blockSet.delete(obj.x + ',' + obj.y);
  }
}

// ================================================================
// COLOR ZONES - cycle through colors every 3000px
// ================================================================
const zoneList = [
  { bg:'#0a0e3a', bgR:'#101878', bgB:'#1a2494', gnd:'#04061a', gl:'#4488ff',
    sk:'#1a1a2e', skIn:'#2a2a4e', skB:'#111128', nm:'blue' },
  { bg:'#7a0040', bgR:'#a00058', bgB:'#c00078', gnd:'#1a0008', gl:'#ff4090',
    sk:'#fff', skIn:'#ddd', skB:'#ccc', nm:'pink' },
  { bg:'#2a0060', bgR:'#3c0090', bgB:'#5000b0', gnd:'#0a0018', gl:'#aa66ff',
    sk:'#fff', skIn:'#ddd', skB:'#ccc', nm:'purple' },
  { bg:'#3a0000', bgR:'#580000', bgB:'#780000', gnd:'#0a0000', gl:'#ff2020',
    sk:'#fff', skIn:'#ddd', skB:'#ccc', nm:'red' },
  { bg:'#3a0040', bgR:'#580068', bgB:'#780090', gnd:'#140018', gl:'#e040fb',
    sk:'#fff', skIn:'#ddd', skB:'#ccc', nm:'magenta' }
];
const ZONE_LEN = 1200;
function getZone(px) {
  const idx = Math.floor(px / ZONE_LEN) % zoneList.length;
  return zoneList[idx];
}

// ================================================================
// GAME LOGIC
// ================================================================
let gameStartTime = 0;
let lastSpeedUpCount = 0;
let speedUpFlash = 0;
let baseSpeed = 5.0;

function startGame() {
  state = 'playing'; camX = 0; canRestart = false;
  P = { x: 120, y: GND/2 - PSIZ/2, vy: 0, rot: 0, onG: false, dead: false, ship: true };
  particles = []; inputTap = false;
  coinsGot = 0;
  L.length = 0; blockSet.clear(); genX = 20; gndSpikeX = 0; ceilGenX = 0; ceilSpikeX = 0; ceilBumpX = 0; coinGenX = 30; // reset level
  gameStartTime = Date.now();
  lastSpeedUpCount = 0;
  speedUpFlash = 0;
  baseSpeed = SPEED;
  generateAhead(); // pre-fill screen
  document.getElementById('attempts').textContent = 'Attempt ' + att;
  document.getElementById('highTxt').textContent = 'Best: ' + highScore + 'm';
}

function kill() {
  if (P.dead) return;
  if (godMode) return;
  P.dead = true; state = 'dead'; canRestart = false;
  for (let i = 0; i < 16; i++) {
    particles.push({
      x: P.x + PSIZ/2, y: P.y + PSIZ/2,
      vx: (Math.random()-0.5)*14, vy: (Math.random()-0.5)*14 - 4,
      sz: Math.random()*8+3, life: 1,
      col: ['#0f0','#0af','#ff0'][Math.floor(Math.random()*3)]
    });
  }
  // Show death screen after 600ms, allow restart after another 600ms
  setTimeout(() => {
    const dist = Math.floor(camX / T);
    if (dist > highScore) { highScore = dist; localStorage.setItem('endless-high', highScore); }
    // Achievement checks
    if (dist >= 500 && !hasAchievement('survive-500m')) grantAchievement('survive-500m');
    if (dist >= 1000 && !hasAchievement('survive-1000m')) grantAchievement('survive-1000m');
    if (dist >= 2000 && !hasAchievement('survive-2000m')) grantAchievement('survive-2000m');
    if (coinsGot >= 25 && !hasAchievement('collect-25-run')) grantAchievement('collect-25-run');
    persistentCoins += coinsGot;
    if (coinsGot >= 100 && !hasAchievement('collect-100')) grantAchievement('collect-100');
    // Loyal Flyer streak tracking
    const streakSkin = parseInt(localStorage.getItem('geoflyer-streak-skin') || '-1');
    let streakCount = parseInt(localStorage.getItem('geoflyer-streak-count') || '0');
    if (dist >= 300 && shipSkin === streakSkin) {
      streakCount++;
    } else if (dist >= 300 && streakSkin !== shipSkin) {
      streakCount = 1;
    } else {
      streakCount = 0;
    }
    localStorage.setItem('geoflyer-streak-skin', shipSkin);
    localStorage.setItem('geoflyer-streak-count', streakCount);
    if (streakCount >= 10 && !hasAchievement('loyal-10')) grantAchievement('loyal-10');
    localStorage.setItem('geoflyer-coins', persistentCoins);
    document.getElementById('deathP').textContent = 'Distance: ' + dist + 'm  |  Best: ' + highScore + 'm  |  Coins: ' + coinsGot + '  |  Total: ' + persistentCoins;
    show('deathS');
    setTimeout(() => { canRestart = true; }, 600);
  }, 600);
}

function win() {
  state = 'won'; canRestart = false;
  let txt = 'Completed in ' + att + ' attempt' + (att>1?'s':'') + '!';
  if (totalCoins > 0) txt += ' Coins: ' + coinsGot + '/' + totalCoins;
  document.getElementById('winI').textContent = txt;
  show('winS');
  setTimeout(() => { canRestart = true; }, 1000);
}

function pr() { return { x: P.x+2, y: P.y+2, w: PSIZ-4, h: PSIZ-4 }; }
function ov(a, b) { return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

function update() {
  if (state !== 'playing') return;
  camX += SPEED;

  if (P.ship) {
    if (inputDown) P.vy += SHIP_UP; else P.vy += SHIP_GRAV;
    P.vy = Math.max(-SHIP_MAX, Math.min(SHIP_MAX, P.vy));
    P.y += P.vy;
    if (P.y + PSIZ > GND) { P.y = GND - PSIZ; P.vy = 0; }
    P.rot = P.vy * 2;
  } else {
    P.vy += GRAV;
    P.y += P.vy;
    P.onG = false;
    if (P.y + PSIZ >= GND) { P.y = GND - PSIZ; P.vy = 0; P.onG = true; }
  }

  const pR = pr();
  const wX = pR.x + camX;
  const stx = Math.floor((wX - T*2) / T);
  const etx = Math.floor((wX + pR.w + T*2) / T);

  for (const obj of L) {
    if (obj.x < stx || obj.x > etx) continue;
    const osx = obj.x * T - camX;
    const sy = obj.y * T;

    switch (obj.t) {
      case 'B': {
        const bR = { x: osx, y: sy, w: T, h: T };
        const p = pr();
        if (!ov(p, bR)) break;
        const oL = (p.x+p.w)-bR.x, oR = (bR.x+bR.w)-p.x;
        const oT = (p.y+p.h)-bR.y, oB = (bR.y+bR.h)-p.y;
        const mn = Math.min(oL, oR, oT, oB);
        if (P.ship) {
          // Prioritize vertical resolution to allow sliding over block edges
          if (mn === oT && P.vy >= 0) { P.y = sy - PSIZ; P.vy = 0; }
          else if (mn === oB && P.vy <= 0) { P.y = sy + T; P.vy = 0; }
          else if (mn === oL || mn === oR) {
            // Edge clipping — resolve vertically if overlap is small
            if (oT < PSIZ * 0.5) { P.y = sy - PSIZ; P.vy = Math.min(P.vy, 0); }
            else if (oB < PSIZ * 0.5) { P.y = sy + T; P.vy = Math.max(P.vy, 0); }
            else { kill(); return; }
          }
          else { kill(); return; }
        } else {
          if (mn === oT && P.vy >= 0) { P.y = sy - PSIZ; P.vy = 0; P.onG = true; }
          else if (mn === oL) { kill(); return; }
          else if (mn === oB && P.vy < 0) { P.y = sy + T; P.vy = 0; }
        }
        break;
      }
      case 'S': {
        const sR = { x: osx+8, y: sy+10, w: T-16, h: T-10 };
        if (ov(pr(), sR)) { kill(); return; }
        break;
      }
      case 'CS': {
        const sR = { x: osx+8, y: sy, w: T-16, h: T-10 };
        if (ov(pr(), sR)) { kill(); return; }
        break;
      }
      case 'SS': {
        const sR = { x: osx+10, y: sy+T/2+2, w: T-20, h: T/2-2 };
        if (ov(pr(), sR)) { kill(); return; }
        break;
      }
      case 'SCS': {
        const sR = { x: osx+10, y: sy, w: T-20, h: T/2-2 };
        if (ov(pr(), sR)) { kill(); return; }
        break;
      }
      case 'HG': {
        const sR = { x: osx+6, y: sy+T, w: T-12, h: T };
        if (ov(pr(), sR)) { kill(); return; }
        break;
      }
      case 'FR': {
        const fR = { x: osx+6, y: sy + T - 18, w: T-12, h: 18 };
        if (ov(pr(), fR)) { kill(); return; }
        break;
      }
      case 'P': {
        const pRect = { x: osx+4, y: sy, w: T-8, h: T };
        if (ov(pr(), pRect)) { P.vy = -15; P.onG = false; }
        break;
      }
      case 'PO': {
        const pRect = { x: osx, y: sy, w: T, h: T*2 };
        if (ov(pr(), pRect) && !P.ship) { P.ship = true; P.vy = -2; }
        break;
      }
      case 'PC': {
        const pRect = { x: osx, y: sy, w: T, h: T*2 };
        if (ov(pr(), pRect) && P.ship) { P.ship = false; P.vy = 0; }
        break;
      }
      case 'CN': {
        if (obj.collected) break;
        const cR = { x: osx+4, y: sy+4, w: T-8, h: T-8 };
        if (ov(pr(), cR)) { obj.collected = true; coinsGot++; }
        break;
      }
    }
  }

  if (!P.ship) {
    if ((inputTap || holdJump) && P.onG) { P.vy = JUMP; P.onG = false; }
  }
  inputTap = false;

  if (!P.ship) {
    if (!P.onG) P.rot += 5;
    else P.rot = Math.round(P.rot / 90) * 90;
  }

  if (P.y > H + 50 || P.y < -100) { kill(); return; }

  // Endless: generate ahead and cleanup behind
  generateAhead();
  cleanupBehind();

  const dist = Math.floor(camX / T);
  document.getElementById('scoreTxt').textContent = dist + 'm';
  document.getElementById('coinTxt').textContent = '\u2733 ' + coinsGot + ' / ' + persistentCoins;
}

// ================================================================
// RENDERING
// ================================================================
// Background rects - wrapping pattern that tiles endlessly
const BG_TILE_W = 2600; // background repeats every this many pixels (parallax space)
const bgRects = [];
(function() {
  const cols = Math.ceil(BG_TILE_W / 260) + 2;
  for (let c = 0; c < cols; c++) {
    for (let r = 0; r < 3; r++) {
      bgRects.push({
        x: c * 260 - 100 + (Math.random() - 0.5) * 80,
        y: r * (GND / 3) + (Math.random() - 0.5) * 30,
        w: 140 + Math.random() * 180,
        h: 70 + Math.random() * 110
      });
    }
  }
})();

const stars = [];
for (let i = 0; i < 50; i++) stars.push({
  x: Math.random() * 20000, y: Math.random() * (GND - 30) + 10,
  sz: Math.random() * 2.5 + 0.8, br: Math.random() * 0.5 + 0.3
});

function drawBG() {
  const z = getZone(camX);
  X.fillStyle = z.bg;
  X.fillRect(0, 0, W, GND);

  const pOff = (camX * 0.15) % BG_TILE_W;
  X.fillStyle = z.bgR;
  X.strokeStyle = z.bgB;
  X.lineWidth = 2;
  for (const r of bgRects) {
    let rx = r.x - pOff;
    if (rx + r.w < -BG_TILE_W) rx += BG_TILE_W;
    if (rx > W + 50) rx -= BG_TILE_W;
    if (rx + r.w < -50 || rx > W + 50) continue;
    X.fillRect(rx, r.y, r.w, r.h);
    X.strokeRect(rx, r.y, r.w, r.h);
  }

  for (const s of stars) {
    let ssx = ((s.x - camX * 0.08) % (W + 80));
    if (ssx < 0) ssx += W + 80;
    const a = s.br + Math.sin(Date.now() * 0.002 + s.x) * 0.12;
    X.fillStyle = `rgba(255,255,200,${Math.max(0, a)})`;
    X.fillRect(ssx, s.y, s.sz, s.sz);
  }

  // Ground area below blocks
  X.fillStyle = z.gnd;
  X.fillRect(0, GND + T, W, H - GND - T);

  const go = camX % T;
  const bgCols = Math.ceil(W / T) + 2;

  // Ceiling blocks are real objects generated in generateAhead, drawn by drawObjects

  // --- GROUND: row of blocks + scattered decorative spikes on top ---
  for (let col = -1; col < bgCols; col++) {
    const bx = col * T - go;
    X.fillStyle = '#111';
    X.fillRect(bx, GND, T, T);
    X.strokeStyle = 'rgba(255,255,255,0.18)'; X.lineWidth = 0.7;
    for (let i = T/4; i < T; i += T/4) {
      X.beginPath(); X.moveTo(bx+i, GND); X.lineTo(bx+i, GND+T); X.stroke();
      X.beginPath(); X.moveTo(bx, GND+i); X.lineTo(bx+T, GND+i); X.stroke();
    }
    X.strokeStyle = '#fff'; X.lineWidth = 1.5;
    X.strokeRect(bx+0.5, GND+0.5, T-1, T-1);
    X.fillStyle = 'rgba(255,255,255,0.05)';
    X.fillRect(bx+2, GND+2, T-4, (T-4)/2);
    // ground spikes are real collision objects, generated in generateAhead
  }

  // Glow line at ground
  X.strokeStyle = z.gl; X.lineWidth = 2;
  X.beginPath(); X.moveTo(0, GND); X.lineTo(W, GND); X.stroke();
}

function drawBlock(bx, by) {
  X.fillStyle = '#111';
  X.fillRect(bx, by, T, T);
  X.strokeStyle = 'rgba(255,255,255,0.18)'; X.lineWidth = 0.7;
  for (let i = T/4; i < T; i += T/4) {
    X.beginPath(); X.moveTo(bx+i, by); X.lineTo(bx+i, by+T); X.stroke();
    X.beginPath(); X.moveTo(bx, by+i); X.lineTo(bx+T, by+i); X.stroke();
  }
  X.strokeStyle = '#fff'; X.lineWidth = 1.5;
  X.strokeRect(bx+0.5, by+0.5, T-1, T-1);
  X.fillStyle = 'rgba(255,255,255,0.05)';
  X.fillRect(bx+2, by+2, T-4, (T-4)/2);
}

function drawDecoBlock(bx, by) {
  X.globalAlpha = 0.18;
  X.fillStyle = '#222'; X.fillRect(bx, by, T, T);
  X.strokeStyle = '#888'; X.lineWidth = 1;
  X.strokeRect(bx+0.5, by+0.5, T-1, T-1);
  X.globalAlpha = 1;
}

function drawSpike(bx, by, z) {
  X.fillStyle = '#fff';
  X.beginPath(); X.moveTo(bx+T/2, by+2); X.lineTo(bx+T-3, by+T); X.lineTo(bx+3, by+T); X.closePath(); X.fill();
  X.fillStyle = '#ddd';
  X.beginPath(); X.moveTo(bx+T/2, by+10); X.lineTo(bx+T-9, by+T-2); X.lineTo(bx+9, by+T-2); X.closePath(); X.fill();
  X.strokeStyle = '#000'; X.lineWidth = 1.5;
  X.beginPath(); X.moveTo(bx+T/2, by+2); X.lineTo(bx+T-3, by+T); X.lineTo(bx+3, by+T); X.closePath(); X.stroke();
}

function drawCSpike(bx, by, z) {
  X.fillStyle = '#fff';
  X.beginPath(); X.moveTo(bx+T/2, by+T-2); X.lineTo(bx+T-3, by); X.lineTo(bx+3, by); X.closePath(); X.fill();
  X.fillStyle = '#ddd';
  X.beginPath(); X.moveTo(bx+T/2, by+T-10); X.lineTo(bx+T-9, by+2); X.lineTo(bx+9, by+2); X.closePath(); X.fill();
  X.strokeStyle = '#000'; X.lineWidth = 1.5;
  X.beginPath(); X.moveTo(bx+T/2, by+T-2); X.lineTo(bx+T-3, by); X.lineTo(bx+3, by); X.closePath(); X.stroke();
}

// Small spike pointing UP (half height, sits in bottom half of tile)
function drawSmallSpike(bx, by, z) {
  const hh = T / 2; // half height
  X.fillStyle = '#fff';
  X.beginPath(); X.moveTo(bx+T/2, by+hh+2); X.lineTo(bx+T-6, by+T); X.lineTo(bx+6, by+T); X.closePath(); X.fill();
  X.fillStyle = '#ddd';
  X.beginPath(); X.moveTo(bx+T/2, by+hh+7); X.lineTo(bx+T-10, by+T-2); X.lineTo(bx+10, by+T-2); X.closePath(); X.fill();
  X.strokeStyle = '#000'; X.lineWidth = 1.5;
  X.beginPath(); X.moveTo(bx+T/2, by+hh+2); X.lineTo(bx+T-6, by+T); X.lineTo(bx+6, by+T); X.closePath(); X.stroke();
}

// Small ceiling spike pointing DOWN (half height, hangs from top half of tile)
function drawSmallCSpike(bx, by, z) {
  const hh = T / 2;
  X.fillStyle = '#fff';
  X.beginPath(); X.moveTo(bx+T/2, by+hh-2); X.lineTo(bx+T-6, by); X.lineTo(bx+6, by); X.closePath(); X.fill();
  X.fillStyle = '#ddd';
  X.beginPath(); X.moveTo(bx+T/2, by+hh-7); X.lineTo(bx+T-10, by+2); X.lineTo(bx+10, by+2); X.closePath(); X.fill();
  X.strokeStyle = '#000'; X.lineWidth = 1.5;
  X.beginPath(); X.moveTo(bx+T/2, by+hh-2); X.lineTo(bx+T-6, by); X.lineTo(bx+6, by); X.closePath(); X.stroke();
}

function drawHang(bx, by) {
  X.strokeStyle = '#ffd600'; X.lineWidth = 2.5;
  for (let i = 0; i < 3; i++) {
    X.beginPath(); X.ellipse(bx+T/2, by+i*13+5, 5, 7, 0, 0, Math.PI*2); X.stroke();
  }
  const dy = by + 38;
  X.fillStyle = '#222'; X.fillRect(bx+4, dy, T-8, T-10);
  X.fillStyle = '#fff'; X.fillRect(bx+8, dy+3, T-16, T-16);
  X.fillStyle = '#222';
  X.beginPath(); X.moveTo(bx+4, dy+T-10); X.lineTo(bx+T-4, dy+T-10); X.lineTo(bx+T/2, dy+T+12); X.closePath(); X.fill();
  X.fillStyle = '#fff';
  X.beginPath(); X.moveTo(bx+10, dy+T-10); X.lineTo(bx+T-10, dy+T-10); X.lineTo(bx+T/2, dy+T+5); X.closePath(); X.fill();
}

function drawPad(bx, by) {
  X.fillStyle = '#ffd600'; X.fillRect(bx+4, by+T-12, T-8, 12);
  X.fillStyle = '#ff8f00';
  X.beginPath(); X.moveTo(bx+T/2, by+T-20); X.lineTo(bx+T/2+8, by+T-6); X.lineTo(bx+T/2-8, by+T-6); X.closePath(); X.fill();
}

function drawPortal(bx, by, isShip) {
  const t = Date.now() * 0.003;
  const col = isShip ? '#e040fb' : '#00e676';
  X.save(); X.translate(bx+T/2, by+T);
  X.shadowColor = col; X.shadowBlur = 25;
  X.strokeStyle = col; X.lineWidth = 3;
  X.beginPath(); X.ellipse(0, 0, T*0.6+Math.sin(t)*3, T*0.9+Math.cos(t)*3, 0, 0, Math.PI*2); X.stroke();
  X.strokeStyle = '#fff'; X.lineWidth = 2;
  X.beginPath(); X.ellipse(0, 0, T*0.35+Math.cos(t)*2, T*0.6+Math.sin(t)*2, 0, 0, Math.PI*2); X.stroke();
  X.fillStyle = col; X.beginPath(); X.arc(0, 0, 6, 0, Math.PI*2); X.fill();
  X.shadowBlur = 0; X.restore();
}

function drawFire(bx, by) {
  const t = Date.now() * 0.005;
  for (let i = 0; i < 4; i++) {
    const fx = bx + 3 + i*10 + Math.sin(t+i*1.8)*3;
    const fh = 14 + Math.sin(t*1.5+i)*6;
    X.fillStyle = i%2===0 ? '#ffd600' : '#ff6f00';
    X.globalAlpha = 0.8;
    X.beginPath(); X.moveTo(fx, by+T); X.lineTo(fx+5, by+T); X.lineTo(fx+2.5, by+T-fh); X.closePath(); X.fill();
  }
  X.globalAlpha = 1;
}

function drawSmiley(bx, by) {
  const cx = bx+T/2, cy = by+T/2;
  X.fillStyle = '#fff'; X.beginPath(); X.arc(cx, cy, T/2-6, 0, Math.PI*2); X.fill();
  X.fillStyle = '#000';
  X.beginPath(); X.arc(cx-4, cy-2, 2.5, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(cx+4, cy-2, 2.5, 0, Math.PI*2); X.fill();
  X.strokeStyle = '#000'; X.lineWidth = 1.5;
  X.beginPath(); X.arc(cx, cy+3, 4, 0, Math.PI); X.stroke();
}

function drawCoin(bx, by, collected) {
  if (collected) return;
  const cx = bx+T/2, cy = by+T/2;
  X.save();
  X.shadowColor = '#ffd600'; X.shadowBlur = 12;
  X.fillStyle = '#ffd600'; X.beginPath(); X.arc(cx, cy, T/2-6, 0, Math.PI*2); X.fill();
  X.fillStyle = '#ffab00'; X.beginPath(); X.arc(cx, cy, T/2-10, 0, Math.PI*2); X.fill();
  X.fillStyle = '#ffd600'; X.font = '16px Arial'; X.textAlign = 'center'; X.textBaseline = 'middle';
  X.fillText('\u2605', cx, cy+1);
  X.shadowBlur = 0; X.restore();
}

function drawObjects() {
  const vL = camX - T*2, vR = camX + W + T*2;
  for (const o of L) {
    const wx = o.x * T;
    if (wx < vL || wx > vR) continue;
    const ox = wx - camX, oy = o.y * T;
    const z = getZone(o.x * T);
    switch (o.t) {
      case 'B':  drawBlock(ox, oy); break;
      case 'D':  drawDecoBlock(ox, oy); break;
      case 'S':  drawSpike(ox, oy, z); break;
      case 'CS': drawCSpike(ox, oy, z); break;
      case 'SS': drawSmallSpike(ox, oy, z); break;
      case 'SCS': drawSmallCSpike(ox, oy, z); break;
      case 'HG': drawHang(ox, oy); break;
      case 'P':  drawPad(ox, oy); break;
      case 'PO': drawPortal(ox, oy, true); break;
      case 'PC': drawPortal(ox, oy, false); break;
      case 'FR': drawFire(ox, oy); break;
      case 'SM': drawSmiley(ox, oy); break;
      case 'CN': drawCoin(ox, oy, o.collected); break;
    }
    // Hitbox overlay
    if (showHitboxes) {
      let hb = null;
      switch (o.t) {
        case 'B':  hb = { x: ox, y: oy, w: T, h: T }; break;
        case 'S':  hb = { x: ox+8, y: oy+10, w: T-16, h: T-10 }; break;
        case 'CS': hb = { x: ox+8, y: oy, w: T-16, h: T-10 }; break;
        case 'SS': hb = { x: ox+10, y: oy+T/2+2, w: T-20, h: T/2-2 }; break;
        case 'SCS': hb = { x: ox+10, y: oy, w: T-20, h: T/2-2 }; break;
        case 'HG': hb = { x: ox+6, y: oy+T, w: T-12, h: T }; break;
        case 'FR': hb = { x: ox+6, y: oy+T-18, w: T-12, h: 18 }; break;
      }
      if (hb) {
        X.strokeStyle = '#f00';
        X.lineWidth = 1.5;
        X.strokeRect(hb.x, hb.y, hb.w, hb.h);
        X.fillStyle = 'rgba(255,0,0,0.15)';
        X.fillRect(hb.x, hb.y, hb.w, hb.h);
      }
    }
  }
  // Player hitbox
  if (showHitboxes && !P.dead) {
    const p = { x: P.x+2, y: P.y+2, w: PSIZ-4, h: PSIZ-4 };
    X.strokeStyle = '#0f0';
    X.lineWidth = 1.5;
    X.strokeRect(p.x, p.y, p.w, p.h);
    X.fillStyle = 'rgba(0,255,0,0.15)';
    X.fillRect(p.x, p.y, p.w, p.h);
  }
}

// ================================================================
// SHIP SKINS
// ================================================================

// --- Skin 0: Sci-fi Spaceship ---
function drawShipSkin0() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.008;
  // Twin engine plasma trail
  if (trailStyle === 0) {
  for (let i = 0; i < 10; i++) {
    const fx = -w/2 - 8 - i * 6;
    X.globalAlpha = 0.6 - i * 0.055;
    X.fillStyle = i < 3 ? '#66ffff' : (i < 6 ? '#0088ff' : '#4400cc');
    X.beginPath(); X.arc(fx + Math.sin(t+i)*2, -h/6 + Math.sin(t*1.5+i)*2, Math.max(1, 5-i*0.4), 0, Math.PI*2); X.fill();
    X.beginPath(); X.arc(fx + Math.sin(t+i+2)*2, h/6 + Math.sin(t*1.5+i+1)*2, Math.max(1, 5-i*0.4), 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Twin engine glow
  X.save(); X.shadowColor = '#0ff'; X.shadowBlur = 14;
  X.fillStyle = '#66ffff';
  X.beginPath(); X.arc(-w/2 + 1, -h/6, 3.5, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(-w/2 + 1, h/6, 3.5, 0, Math.PI*2); X.fill();
  X.restore();
  // Main hull - layered dark blue
  X.fillStyle = '#1a1a2e';
  X.beginPath();
  X.moveTo(w/2 + 5, 0);
  X.quadraticCurveTo(w/2 + 2, -h/3, w/6, -h/3);
  X.lineTo(-w/3, -h/3);
  X.lineTo(-w/2, -h/5);
  X.lineTo(-w/2, h/5);
  X.lineTo(-w/3, h/3);
  X.lineTo(w/6, h/3);
  X.quadraticCurveTo(w/2 + 2, h/3, w/2 + 5, 0);
  X.closePath(); X.fill();
  // Upper hull panel (lighter)
  X.fillStyle = '#242448';
  X.beginPath();
  X.moveTo(w/2 + 3, -1);
  X.quadraticCurveTo(w/2, -h/3 + 2, w/6, -h/3 + 2);
  X.lineTo(-w/4, -h/3 + 2); X.lineTo(-w/4, -1);
  X.closePath(); X.fill();
  // Swept wings
  X.fillStyle = '#141430';
  X.beginPath(); X.moveTo(0, -h/3); X.lineTo(-w/4, -h/2 - 2); X.lineTo(-w/2 - 2, -h/3); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(0, h/3); X.lineTo(-w/4, h/2 + 2); X.lineTo(-w/2 - 2, h/3); X.closePath(); X.fill();
  // Energy lines
  const pulse = 0.6 + Math.sin(t * 3) * 0.3;
  X.strokeStyle = `rgba(0,255,255,${pulse})`; X.lineWidth = 1;
  X.beginPath(); X.moveTo(w/2 + 2, 0); X.lineTo(-w/3, 0); X.stroke();
  X.beginPath(); X.moveTo(w/4, -h/6); X.lineTo(-w/4, -h/3 + 2); X.stroke();
  X.beginPath(); X.moveTo(w/4, h/6); X.lineTo(-w/4, h/3 - 2); X.stroke();
  // Cockpit dome
  X.save(); X.shadowColor = '#0af'; X.shadowBlur = 6;
  const cg = X.createRadialGradient(w/5, -1, 1, w/5, 0, 5);
  cg.addColorStop(0, '#ffffff'); cg.addColorStop(0.4, '#44ddff'); cg.addColorStop(1, '#0066aa');
  X.fillStyle = cg;
  X.beginPath(); X.ellipse(w/5, 0, 5, 4, 0, 0, Math.PI*2); X.fill();
  X.restore();
}

function drawCubeSkin0() {
  const h = PSIZ;
  const t = Date.now() * 0.008;
  // Trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 5; i++) {
    X.globalAlpha = 0.3 - i * 0.05;
    X.fillStyle = i < 3 ? '#66ffff' : '#0088ff';
    X.fillRect(-h/2 - i * 7, -h/2 + 4, 6, h - 8);
  }
  X.globalAlpha = 1;
  }
  // Body - dark hull
  X.fillStyle = '#1a1a2e'; X.fillRect(-h/2, -h/2, h, h);
  // Upper panel lighter
  X.fillStyle = '#242448'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, (h - 6)/2);
  // Lower panel
  X.fillStyle = '#1e1e3a'; X.fillRect(-h/2 + 3, 0, h - 6, h/2 - 3);
  // Energy line across middle
  const pulse = 0.6 + Math.sin(t * 3) * 0.3;
  X.strokeStyle = `rgba(0,255,255,${pulse})`; X.lineWidth = 1;
  X.beginPath(); X.moveTo(-h/2 + 4, 0); X.lineTo(h/2 - 4, 0); X.stroke();
  // Border
  X.strokeStyle = '#0ff'; X.lineWidth = 1.5; X.strokeRect(-h/2, -h/2, h, h);
  // Cockpit eye
  X.save(); X.shadowColor = '#0af'; X.shadowBlur = 6;
  X.fillStyle = '#44ddff'; X.beginPath(); X.arc(2, -2, 4, 0, Math.PI*2); X.fill();
  X.restore();
  X.fillStyle = '#fff'; X.beginPath(); X.arc(3, -3, 1.5, 0, Math.PI*2); X.fill();
}

// --- Skin 1: Neon Racer ---
function drawShipSkin1() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.003;
  const hue1 = (t * 30) % 360;
  // Light streak trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 8; i++) {
    X.globalAlpha = 0.4 - i * 0.045;
    X.strokeStyle = `hsl(${hue1}, 100%, 60%)`;
    X.lineWidth = 3 - i * 0.3;
    X.beginPath(); X.moveTo(-w/2 - i * 7, -1); X.lineTo(-w/2 - i * 7 - 5, -1); X.stroke();
    X.strokeStyle = `hsl(${hue1 + 180}, 100%, 60%)`;
    X.beginPath(); X.moveTo(-w/2 - i * 7, 1); X.lineTo(-w/2 - i * 7 - 5, 1); X.stroke();
  }
  X.globalAlpha = 1;
  }
  // Sharp angular wedge
  const col1 = `hsl(${hue1}, 100%, 55%)`;
  const col2 = `hsl(${hue1 + 180}, 100%, 55%)`;
  X.save();
  X.shadowColor = col1; X.shadowBlur = 15;
  X.fillStyle = col1;
  X.beginPath();
  X.moveTo(w/2 + 3, 0);
  X.lineTo(0, -h/2);
  X.lineTo(-w/2, -h/3);
  X.lineTo(-w/2 + 4, 0);
  X.closePath(); X.fill();
  X.shadowColor = col2;
  X.fillStyle = col2;
  X.beginPath();
  X.moveTo(w/2 + 3, 0);
  X.lineTo(0, h/2);
  X.lineTo(-w/2, h/3);
  X.lineTo(-w/2 + 4, 0);
  X.closePath(); X.fill();
  X.restore();
  // Center line
  X.strokeStyle = '#fff'; X.lineWidth = 1;
  X.beginPath(); X.moveTo(w/2, 0); X.lineTo(-w/2 + 4, 0); X.stroke();
  // Pulsing core
  const pulse = 2 + Math.sin(t * 3) * 1.5;
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(0, 0, pulse, 0, Math.PI * 2); X.fill();
}

function drawCubeSkin1() {
  const h = PSIZ;
  const t = Date.now() * 0.003;
  const hue1 = (t * 30) % 360;
  const col1 = `hsl(${hue1}, 100%, 55%)`;
  // Trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 4; i++) {
    X.globalAlpha = 0.3 - i * 0.06;
    X.fillStyle = col1;
    X.fillRect(-h/2 - i * 8, -h/2 + 3, 7, h - 6);
  }
  X.globalAlpha = 1;
  }
  X.save();
  X.shadowColor = col1; X.shadowBlur = 12;
  X.fillStyle = col1; X.fillRect(-h/2, -h/2, h, h);
  X.restore();
  X.fillStyle = `hsl(${hue1 + 180}, 100%, 55%)`; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, h - 6);
  X.fillStyle = 'rgba(255,255,255,0.15)'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, (h - 6) / 2);
  X.strokeStyle = '#fff'; X.lineWidth = 1.5; X.strokeRect(-h/2, -h/2, h, h);
  const pulse = 2 + Math.sin(t * 3) * 1;
  X.fillStyle = '#fff'; X.beginPath(); X.arc(2, 0, pulse, 0, Math.PI * 2); X.fill();
}

// --- Skin 2: GD-style clean ship/cube ---
function drawShipSkin2() {
  const h = PSIZ, w = PSIZ;
  // Trail
  if (trailStyle === 0) {
  X.globalAlpha = 0.35; X.fillStyle = '#0f0';
  X.fillRect(-w/2 - 20, -4, 22, 8);
  X.globalAlpha = 0.15; X.fillRect(-w/2 - 38, -3, 20, 6);
  X.globalAlpha = 1;
  }
  // Body - gradient green to teal
  const grd = X.createLinearGradient(-w/2, -h/2, w/2, h/2);
  grd.addColorStop(0, '#00e676'); grd.addColorStop(1, '#00bfa5');
  X.fillStyle = grd;
  X.beginPath();
  X.moveTo(w/2, 0);
  X.lineTo(-w/2, -h/2);
  X.lineTo(-w/2 + 6, 0);
  X.lineTo(-w/2, h/2);
  X.closePath(); X.fill();
  // Small wings
  X.fillStyle = '#00c853';
  X.beginPath(); X.moveTo(-w/6, -h/2 + 2); X.lineTo(-w/4, -h/2 - 5); X.lineTo(-w/2 + 2, -h/2 + 4); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-w/6, h/2 - 2); X.lineTo(-w/4, h/2 + 5); X.lineTo(-w/2 + 2, h/2 - 4); X.closePath(); X.fill();
  // Highlight
  X.fillStyle = 'rgba(255,255,255,0.15)';
  X.beginPath();
  X.moveTo(w/2 - 4, -1);
  X.lineTo(-w/2 + 6, -h/2 + 6);
  X.lineTo(-w/2 + 10, 0);
  X.closePath(); X.fill();
  // Clean outline
  X.strokeStyle = '#1b5e20'; X.lineWidth = 2;
  X.beginPath();
  X.moveTo(w/2, 0); X.lineTo(-w/2, -h/2);
  X.lineTo(-w/2 + 6, 0); X.lineTo(-w/2, h/2);
  X.closePath(); X.stroke();
  // Eye
  X.fillStyle = '#fff'; X.fillRect(-2, -5, 10, 8);
  X.fillStyle = '#000'; X.fillRect(2, -3, 5, 5);
}

function drawCubeSkin2() {
  const h = PSIZ;
  // Trail
  if (trailStyle === 0) {
  X.globalAlpha = 0.3; X.fillStyle = '#0f0';
  X.fillRect(-h/2 - 12, -h/2 + 4, 14, h - 8); X.globalAlpha = 1;
  }
  // Body gradient
  const grd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  grd.addColorStop(0, '#00e676'); grd.addColorStop(1, '#00bfa5');
  X.fillStyle = grd; X.fillRect(-h/2, -h/2, h, h);
  X.fillStyle = 'rgba(255,255,255,0.12)'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, (h - 6) / 2);
  // Small wings
  X.fillStyle = '#00c853';
  X.beginPath(); X.moveTo(-h/2 + 4, -h/2); X.lineTo(h/4, -h/2 - 5); X.lineTo(h/4, -h/2); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-h/2 + 4, h/2); X.lineTo(h/4, h/2 + 5); X.lineTo(h/4, h/2); X.closePath(); X.fill();
  // Clean outline
  X.strokeStyle = '#1b5e20'; X.lineWidth = 2.5; X.strokeRect(-h/2, -h/2, h, h);
  // Eye
  X.fillStyle = '#fff'; X.fillRect(-5, -6, 12, 10);
  X.fillStyle = '#000'; X.fillRect(-1, -3, 6, 6);
}

// --- Skin 3: Space Shuttle ---
function drawShipSkin3() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.01;
  // Engine exhaust - blue-white plasma
  if (trailStyle === 0) {
  for (let i = 0; i < 10; i++) {
    const fx = -w/2 - 6 - i * 6 + Math.sin(t * 2 + i * 1.3) * 2;
    const fy = Math.sin(t + i * 0.8) * 3;
    const sz = 5 - i * 0.4;
    X.globalAlpha = 0.7 - i * 0.06;
    X.fillStyle = i < 3 ? '#ccddff' : (i < 6 ? '#6688ff' : '#3344aa');
    X.beginPath(); X.arc(fx, fy, Math.max(1, sz), 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Engine pods (top and bottom)
  X.fillStyle = '#555566';
  X.fillRect(-w/2 - 3, -h/3 - 2, w/4, 5);
  X.fillRect(-w/2 - 3, h/3 - 3, w/4, 5);
  X.fillStyle = '#6688ff';
  X.beginPath(); X.arc(-w/2, -h/3, 2.5, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(-w/2, h/3, 2.5, 0, Math.PI*2); X.fill();
  // Main fuselage - metallic silver/gray
  const fGrd = X.createLinearGradient(0, -h/3, 0, h/3);
  fGrd.addColorStop(0, '#aaaabb'); fGrd.addColorStop(0.4, '#dddde8'); fGrd.addColorStop(0.6, '#ccccdd'); fGrd.addColorStop(1, '#888899');
  X.fillStyle = fGrd;
  X.beginPath();
  X.moveTo(w/2 + 4, 0);
  X.quadraticCurveTo(w/2 + 2, -h/4, w/6, -h/4);
  X.lineTo(-w/2, -h/4);
  X.lineTo(-w/2, h/4);
  X.lineTo(w/6, h/4);
  X.quadraticCurveTo(w/2 + 2, h/4, w/2 + 4, 0);
  X.closePath(); X.fill();
  // Delta wings
  X.fillStyle = '#777788';
  X.beginPath(); X.moveTo(-w/6, -h/4); X.lineTo(-w/3, -h/2 - 1); X.lineTo(-w/2, -h/4); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-w/6, h/4); X.lineTo(-w/3, h/2 + 1); X.lineTo(-w/2, h/4); X.closePath(); X.fill();
  // Fuselage seam line
  X.strokeStyle = '#666677'; X.lineWidth = 0.8;
  X.beginPath(); X.moveTo(w/3, 0); X.lineTo(-w/2 + 2, 0); X.stroke();
  // Cockpit windshield
  X.save(); X.shadowColor = '#aaddff'; X.shadowBlur = 5;
  const wg = X.createLinearGradient(w/4, -3, w/4, 3);
  wg.addColorStop(0, '#cceeFF'); wg.addColorStop(1, '#6699cc');
  X.fillStyle = wg;
  X.beginPath();
  X.moveTo(w/2 + 2, 0);
  X.quadraticCurveTo(w/2, -h/6, w/4, -h/6);
  X.lineTo(w/4, h/6);
  X.quadraticCurveTo(w/2, h/6, w/2 + 2, 0);
  X.closePath(); X.fill();
  X.restore();
  // Outline
  X.strokeStyle = '#555566'; X.lineWidth = 1;
  X.beginPath();
  X.moveTo(w/2 + 4, 0);
  X.quadraticCurveTo(w/2 + 2, -h/4, w/6, -h/4);
  X.lineTo(-w/2, -h/4); X.lineTo(-w/2, h/4); X.lineTo(w/6, h/4);
  X.quadraticCurveTo(w/2 + 2, h/4, w/2 + 4, 0);
  X.closePath(); X.stroke();
}

function drawCubeSkin3() {
  const h = PSIZ;
  const t = Date.now() * 0.01;
  // Trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 4; i++) {
    X.globalAlpha = 0.35 - i * 0.07;
    X.fillStyle = i < 2 ? '#ccddff' : '#6688ff';
    X.fillRect(-h/2 - i * 7, -h/2 + 5, 6, h - 10);
  }
  X.globalAlpha = 1;
  }
  // Metallic body
  const fGrd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  fGrd.addColorStop(0, '#aaaabb'); fGrd.addColorStop(0.5, '#dddde8'); fGrd.addColorStop(1, '#888899');
  X.fillStyle = fGrd; X.fillRect(-h/2, -h/2, h, h);
  // Hull panel line
  X.strokeStyle = '#666677'; X.lineWidth = 0.8;
  X.beginPath(); X.moveTo(-h/2 + 4, 0); X.lineTo(h/2 - 4, 0); X.stroke();
  X.beginPath(); X.moveTo(0, -h/2 + 4); X.lineTo(0, h/2 - 4); X.stroke();
  // Wing stubs
  X.fillStyle = '#777788';
  X.beginPath(); X.moveTo(-h/2 + 4, -h/2); X.lineTo(0, -h/2 - 5); X.lineTo(0, -h/2); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-h/2 + 4, h/2); X.lineTo(0, h/2 + 5); X.lineTo(0, h/2); X.closePath(); X.fill();
  // Border
  X.strokeStyle = '#555566'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Cockpit window
  X.save(); X.shadowColor = '#aaddff'; X.shadowBlur = 4;
  X.fillStyle = '#aaddff';
  X.beginPath(); X.arc(3, -2, 5, 0, Math.PI * 2); X.fill();
  X.restore();
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(4, -3, 1.8, 0, Math.PI * 2); X.fill();
}

// --- Skin 4: Phoenix ---
function drawShipSkin4() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.008;
  const flap = Math.sin(t * 1.2) * 3;
  // Ember/flame trail
  if (trailStyle === 0) {
  for (let i = 0; i < 12; i++) {
    const fx = -w/2 - 4 - i * 5;
    const fy = Math.sin(t * 2 + i * 1.3) * 4;
    const sz = 4.5 - i * 0.35;
    X.globalAlpha = 0.7 - i * 0.055;
    X.fillStyle = i < 3 ? '#ff2200' : (i < 6 ? '#ff6600' : (i < 9 ? '#ffaa00' : '#ffdd44'));
    X.beginPath(); X.arc(fx, fy, Math.max(1, sz), 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Tail flames (sharp pointed shapes behind body)
  X.fillStyle = '#cc2200';
  X.beginPath();
  X.moveTo(-w/6, 0); X.lineTo(-w/2 - 6, -h/5); X.lineTo(-w/2, -h/10); X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-w/6, 0); X.lineTo(-w/2 - 6, h/5); X.lineTo(-w/2, h/10); X.closePath(); X.fill();
  X.fillStyle = '#ff6600';
  X.beginPath();
  X.moveTo(-w/6, 0); X.lineTo(-w/2 - 10, 0); X.lineTo(-w/2 - 2, -h/14); X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-w/6, 0); X.lineTo(-w/2 - 10, 0); X.lineTo(-w/2 - 2, h/14); X.closePath(); X.fill();
  // Flickering flame tips on tail
  if (trailStyle === 0) {
  const fl1 = Math.sin(t * 4) * 2;
  const fl2 = Math.sin(t * 5 + 1) * 2;
  X.fillStyle = '#ffcc00'; X.globalAlpha = 0.8;
  X.beginPath(); X.moveTo(-w/2 - 6, -h/5); X.lineTo(-w/2 - 10 + fl1, -h/4); X.lineTo(-w/2 - 3, -h/6); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-w/2 - 6, h/5); X.lineTo(-w/2 - 10 + fl2, h/4); X.lineTo(-w/2 - 3, h/6); X.closePath(); X.fill();
  X.globalAlpha = 1;
  }
  // Wings (sharp, angular, flame-shaped with jagged edges)
  const wgrd = X.createLinearGradient(0, -h/2, 0, 0);
  wgrd.addColorStop(0, '#ffaa00'); wgrd.addColorStop(1, '#dd4400');
  X.fillStyle = wgrd;
  // Top wing - sharp angular shape
  X.beginPath();
  X.moveTo(w/8, -h/8);
  X.lineTo(w/10, -h/4 - flap);
  X.lineTo(-w/8, -h/2 - 2 - flap);      // wing tip point
  X.lineTo(-w/6, -h/3 - flap);           // jagged notch
  X.lineTo(-w/3, -h/2 + 1 - flap);      // second point
  X.lineTo(-w/4, -h/4 - flap);           // inner notch
  X.lineTo(-w/3, -h/8);
  X.closePath(); X.fill();
  // Bottom wing
  X.beginPath();
  X.moveTo(w/8, h/8);
  X.lineTo(w/10, h/4 + flap);
  X.lineTo(-w/8, h/2 + 2 + flap);
  X.lineTo(-w/6, h/3 + flap);
  X.lineTo(-w/3, h/2 - 1 + flap);
  X.lineTo(-w/4, h/4 + flap);
  X.lineTo(-w/3, h/8);
  X.closePath(); X.fill();
  // Flame glow at wing tips
  X.fillStyle = '#ffee44'; X.globalAlpha = 0.8;
  X.beginPath();
  X.moveTo(-w/8, -h/2 - 2 - flap); X.lineTo(-w/8 - 3, -h/2 - 5 - flap); X.lineTo(-w/8 + 3, -h/2 - 1 - flap); X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-w/8, h/2 + 2 + flap); X.lineTo(-w/8 - 3, h/2 + 5 + flap); X.lineTo(-w/8 + 3, h/2 + 1 + flap); X.closePath(); X.fill();
  X.globalAlpha = 1;
  // Body (angular diamond/kite shape, NOT oval)
  const bgrd = X.createLinearGradient(-w/4, -h/6, w/4, h/6);
  bgrd.addColorStop(0, '#ff5500'); bgrd.addColorStop(0.5, '#ee3300'); bgrd.addColorStop(1, '#cc1100');
  X.fillStyle = bgrd;
  X.beginPath();
  X.moveTo(w/3 + 4, 0);          // sharp nose
  X.lineTo(w/8, -h/6);           // upper front
  X.lineTo(-w/4, -h/7);          // upper back
  X.lineTo(-w/6, 0);             // tail center
  X.lineTo(-w/4, h/7);           // lower back
  X.lineTo(w/8, h/6);            // lower front
  X.closePath(); X.fill();
  // Bright belly line
  X.strokeStyle = '#ff8800'; X.lineWidth = 1;
  X.beginPath(); X.moveTo(w/3, 0); X.lineTo(-w/6, 0); X.stroke();
  // Head (angular, not round)
  X.fillStyle = '#ee3300';
  X.beginPath();
  X.moveTo(w/2 + 5, 0);          // beak tip
  X.lineTo(w/3 + 2, -h/7);      // top of head
  X.lineTo(w/6, -h/8);           // back top
  X.lineTo(w/6, h/8);            // back bottom
  X.lineTo(w/3 + 2, h/7);       // bottom of head
  X.closePath(); X.fill();
  // Crest (tall, sharp flame spikes)
  X.fillStyle = '#ffcc00';
  X.beginPath();
  X.moveTo(w/5, -h/7);
  X.lineTo(w/5 - 2, -h/7 - 7);
  X.lineTo(w/5 + 2, -h/7 - 2);
  X.lineTo(w/5 + 4, -h/7 - 9);
  X.lineTo(w/5 + 6, -h/7 - 3);
  X.lineTo(w/5 + 7, -h/7);
  X.closePath(); X.fill();
  // Sharp beak
  X.fillStyle = '#ff8800';
  X.beginPath();
  X.moveTo(w/2 + 5, 0);
  X.lineTo(w/3 + 3, -2);
  X.lineTo(w/3 + 3, 2);
  X.closePath(); X.fill();
  // Eye (fierce, angular)
  X.fillStyle = '#ffee44';
  X.save(); X.shadowColor = '#ff6600'; X.shadowBlur = 6;
  X.beginPath();
  X.moveTo(w/3, -1);
  X.lineTo(w/4 + 1, -3);
  X.lineTo(w/4 - 1, -1);
  X.lineTo(w/4 + 1, 1);
  X.closePath(); X.fill();
  X.restore();
  X.fillStyle = '#111';
  X.beginPath(); X.arc(w/4 + 2, -1, 1, 0, Math.PI*2); X.fill();
}

function drawCubeSkin4() {
  const h = PSIZ;
  const t = Date.now() * 0.008;
  const flap = Math.sin(t * 1.2) * 2;
  // Ember trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 5; i++) {
    X.globalAlpha = 0.4 - i * 0.07;
    X.fillStyle = i < 3 ? '#ff4400' : '#ffaa00';
    const fy = Math.sin(t * 2 + i) * 3;
    X.beginPath(); X.arc(-h/2 - i * 7, fy, 3 - i * 0.4, 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Sharp angular wings above and below cube
  const wgrd = X.createLinearGradient(0, -h/2 - 8, 0, 0);
  wgrd.addColorStop(0, '#ffaa00'); wgrd.addColorStop(1, '#dd4400');
  X.fillStyle = wgrd;
  // Top wing - jagged flame shape
  X.beginPath();
  X.moveTo(h/4, -h/2);
  X.lineTo(h/8, -h/2 - 4 - flap);
  X.lineTo(-h/8, -h/2 - 10 - flap);   // outer point
  X.lineTo(-h/6, -h/2 - 5 - flap);    // notch
  X.lineTo(-h/3, -h/2 - 8 - flap);    // second point
  X.lineTo(-h/4, -h/2 - 2 - flap);
  X.lineTo(-h/3, -h/2);
  X.closePath(); X.fill();
  // Bottom wing
  X.beginPath();
  X.moveTo(h/4, h/2);
  X.lineTo(h/8, h/2 + 4 + flap);
  X.lineTo(-h/8, h/2 + 10 + flap);
  X.lineTo(-h/6, h/2 + 5 + flap);
  X.lineTo(-h/3, h/2 + 8 + flap);
  X.lineTo(-h/4, h/2 + 2 + flap);
  X.lineTo(-h/3, h/2);
  X.closePath(); X.fill();
  // Flame tips on wings
  X.fillStyle = '#ffee44'; X.globalAlpha = 0.8;
  X.beginPath();
  X.moveTo(-h/8, -h/2 - 10 - flap); X.lineTo(-h/8 - 2, -h/2 - 13 - flap); X.lineTo(-h/8 + 2, -h/2 - 9 - flap);
  X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-h/8, h/2 + 10 + flap); X.lineTo(-h/8 - 2, h/2 + 13 + flap); X.lineTo(-h/8 + 2, h/2 + 9 + flap);
  X.closePath(); X.fill();
  X.globalAlpha = 1;
  // Sharp tail flames behind cube
  X.fillStyle = '#cc2200';
  X.beginPath();
  X.moveTo(-h/2, -h/6); X.lineTo(-h/2 - 7, -h/4); X.lineTo(-h/2 - 3, -h/8); X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-h/2, h/6); X.lineTo(-h/2 - 7, h/4); X.lineTo(-h/2 - 3, h/8); X.closePath(); X.fill();
  X.fillStyle = '#ff6600';
  X.beginPath();
  X.moveTo(-h/2, -h/12); X.lineTo(-h/2 - 9, 0); X.lineTo(-h/2, h/12); X.closePath(); X.fill();
  // Body gradient
  const grd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  grd.addColorStop(0, '#ff5500'); grd.addColorStop(0.5, '#ee3300'); grd.addColorStop(1, '#cc1100');
  X.fillStyle = grd; X.fillRect(-h/2, -h/2, h, h);
  // Sharp crest spikes on top edge
  X.fillStyle = '#ffcc00';
  X.beginPath();
  X.moveTo(h/6 - 3, -h/2);
  X.lineTo(h/6 - 2, -h/2 - 6);
  X.lineTo(h/6 + 1, -h/2 - 1);
  X.lineTo(h/6 + 3, -h/2 - 8);
  X.lineTo(h/6 + 5, -h/2 - 2);
  X.lineTo(h/6 + 6, -h/2 - 5);
  X.lineTo(h/6 + 8, -h/2);
  X.closePath(); X.fill();
  // Golden border
  X.strokeStyle = '#ffaa00'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Fierce angular eye with glow
  X.save(); X.shadowColor = '#ff6600'; X.shadowBlur = 6;
  X.fillStyle = '#ffee44';
  X.beginPath();
  X.moveTo(6, -1);
  X.lineTo(0, -4);
  X.lineTo(-2, -1);
  X.lineTo(0, 2);
  X.closePath(); X.fill();
  X.restore();
  X.fillStyle = '#111';
  X.beginPath(); X.arc(2, -1, 1.5, 0, Math.PI*2); X.fill();
}

// --- Skin 5: Pirate Ship ---
function drawShipSkin5() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.005;
  // Wake/splash trail
  if (trailStyle === 0) {
  for (let i = 0; i < 8; i++) {
    const wx = -w/2 - 6 - i * 7;
    const wy = h/8 + Math.sin(t * 2.5 + i * 1.5) * 2;
    const sz = 3.5 - i * 0.35;
    X.globalAlpha = 0.35 - i * 0.035;
    X.fillStyle = '#88bbdd';
    X.beginPath(); X.arc(wx, wy, Math.max(1, sz), 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Sail (behind hull) - billowing to the right
  const wave = Math.sin(t * 2) * 1.5;
  X.fillStyle = '#eee8d0';
  X.beginPath();
  X.moveTo(-w/10, -h/5);
  X.lineTo(-w/10, -h/2 - 10);
  X.quadraticCurveTo(w/4 + wave, -h/3 - 5, w/5 + wave, -h/5 - 2);
  X.closePath(); X.fill();
  X.strokeStyle = '#bbb098'; X.lineWidth = 0.6;
  X.beginPath();
  X.moveTo(-w/10, -h/5);
  X.lineTo(-w/10, -h/2 - 10);
  X.quadraticCurveTo(w/4 + wave, -h/3 - 5, w/5 + wave, -h/5 - 2);
  X.closePath(); X.stroke();
  // Mast
  X.strokeStyle = '#3a2000'; X.lineWidth = 2;
  X.beginPath(); X.moveTo(-w/10, -h/5); X.lineTo(-w/10, -h/2 - 13); X.stroke();
  // Jolly roger flag at mast top
  const fw = Math.sin(t * 3) * 2;
  X.fillStyle = '#111';
  X.fillRect(-w/10 + 1, -h/2 - 18 + fw, 9, 7);
  X.fillStyle = '#ddd';
  X.beginPath(); X.arc(-w/10 + 5, -h/2 - 15.5 + fw, 1.5, 0, Math.PI*2); X.fill();
  X.fillRect(-w/10 + 4, -h/2 - 13 + fw, 1.5, 2);
  // Hull - flat deck on top, curved bottom
  const hGrd = X.createLinearGradient(0, -h/5, 0, h/4);
  hGrd.addColorStop(0, '#A07830'); hGrd.addColorStop(0.4, '#8B6914'); hGrd.addColorStop(1, '#6B4F10');
  X.fillStyle = hGrd;
  X.beginPath();
  X.moveTo(w/2 + 6, -h/10);         // bow tip
  X.lineTo(w/3, -h/5);              // deck front
  X.lineTo(-w/3, -h/5);             // deck runs flat
  X.lineTo(-w/2, -h/4);             // stern raised up
  X.lineTo(-w/2, h/8);              // stern bottom
  X.quadraticCurveTo(-w/6, h/3 + 2, w/6, h/4);
  X.quadraticCurveTo(w/3, h/5, w/2 + 6, -h/10);
  X.closePath(); X.fill();
  // Plank lines on hull
  X.strokeStyle = '#5a3a08'; X.lineWidth = 0.5;
  X.beginPath(); X.moveTo(-w/3, -h/10); X.lineTo(w/3, -h/10); X.stroke();
  X.beginPath(); X.moveTo(-w/3, h/12); X.lineTo(w/4, h/12); X.stroke();
  // Deck railing
  X.strokeStyle = '#6B4F10'; X.lineWidth = 1;
  X.beginPath(); X.moveTo(w/3, -h/5 - 1); X.lineTo(-w/3, -h/5 - 1); X.stroke();
  // Railing posts
  for (let i = -2; i <= 2; i++) {
    const px = i * w/6;
    X.beginPath(); X.moveTo(px, -h/5 - 1); X.lineTo(px, -h/5 + 2); X.stroke();
  }
  // Cannon ports
  X.fillStyle = '#222';
  X.beginPath(); X.arc(-w/6, h/16, 2, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(w/10, h/16, 2, 0, Math.PI*2); X.fill();
  // Stern cabin window
  X.fillStyle = '#ffdd66';
  X.fillRect(-w/2 + 2, -h/6, 4, 3);
  // Hull outline
  X.strokeStyle = '#4a2a00'; X.lineWidth = 1.5;
  X.beginPath();
  X.moveTo(w/2 + 6, -h/10);
  X.lineTo(w/3, -h/5);
  X.lineTo(-w/3, -h/5);
  X.lineTo(-w/2, -h/4);
  X.lineTo(-w/2, h/8);
  X.quadraticCurveTo(-w/6, h/3 + 2, w/6, h/4);
  X.quadraticCurveTo(w/3, h/5, w/2 + 6, -h/10);
  X.closePath(); X.stroke();
}

function drawCubeSkin5() {
  const h = PSIZ;
  const t = Date.now() * 0.005;
  // Wake trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 4; i++) {
    X.globalAlpha = 0.3 - i * 0.06;
    X.fillStyle = '#88bbdd';
    X.beginPath(); X.arc(-h/2 - i * 8, h/6 + Math.sin(t + i) * 2, 3 - i*0.4, 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Mast + sail above cube
  X.strokeStyle = '#3a2000'; X.lineWidth = 2;
  X.beginPath(); X.moveTo(0, -h/2); X.lineTo(0, -h/2 - 12); X.stroke();
  const sw = Math.sin(t * 2) * 1.5;
  X.fillStyle = '#eee8d0';
  X.beginPath();
  X.moveTo(0, -h/2 - 11);
  X.quadraticCurveTo(h/3 + sw, -h/2 - 6, h/4 + sw, -h/2 - 1);
  X.lineTo(0, -h/2);
  X.closePath(); X.fill();
  X.strokeStyle = '#bbb098'; X.lineWidth = 0.5;
  X.stroke();
  // Flag at top
  const fw = Math.sin(t * 3) * 1.5;
  X.fillStyle = '#111';
  X.fillRect(1, -h/2 - 17 + fw, 8, 6);
  X.fillStyle = '#ddd';
  X.beginPath(); X.arc(5, -h/2 - 14.5 + fw, 1.2, 0, Math.PI*2); X.fill();
  // Wooden body
  const hGrd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  hGrd.addColorStop(0, '#A07830'); hGrd.addColorStop(0.5, '#8B6914'); hGrd.addColorStop(1, '#6B4F10');
  X.fillStyle = hGrd; X.fillRect(-h/2, -h/2, h, h);
  // Plank lines
  X.strokeStyle = '#5a3a08'; X.lineWidth = 0.7;
  for (let i = 1; i < 4; i++) {
    X.beginPath(); X.moveTo(-h/2 + 3, -h/2 + i * h/4); X.lineTo(h/2 - 3, -h/2 + i * h/4); X.stroke();
  }
  // Cannon ports on hull
  X.fillStyle = '#222';
  X.beginPath(); X.arc(-h/5, 0, 2, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(h/5, 0, 2, 0, Math.PI*2); X.fill();
  // Deck railing on top edge
  X.strokeStyle = '#6B4F10'; X.lineWidth = 1;
  X.beginPath(); X.moveTo(-h/2, -h/2); X.lineTo(h/2, -h/2); X.stroke();
  // Border
  X.strokeStyle = '#4a2a00'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Skull and crossbones eye
  X.fillStyle = '#eee8d0'; X.beginPath(); X.arc(1, -1, 5, 0, Math.PI*2); X.fill();
  X.fillStyle = '#333';
  X.beginPath(); X.arc(-1, -2, 1.5, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(3, -2, 1.5, 0, Math.PI*2); X.fill();
  X.fillRect(0, 1, 2, 3);
}

// --- Skin 6: Ice Crystal ---
function drawShipSkin6() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.006;
  // Sparkle/snowflake trail particles
  if (trailStyle === 0) {
  for (let i = 0; i < 8; i++) {
    const fx = -w/2 - 6 - i * 7 + Math.sin(t * 1.2 + i * 2) * 3;
    const fy = Math.sin(t * 1.8 + i * 1.5) * 8;
    const sz = 3 - i * 0.3;
    X.globalAlpha = 0.6 - i * 0.065;
    X.fillStyle = i % 2 === 0 ? '#aaddff' : '#ffffff';
    X.beginPath(); X.arc(fx, fy, Math.max(0.5, sz), 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Crystalline diamond body - icy blue/white gradient
  const grd = X.createLinearGradient(-w/2, -h/2, w/2, h/2);
  grd.addColorStop(0, '#88ccff'); grd.addColorStop(0.5, '#cceeff'); grd.addColorStop(1, '#66aaee');
  X.fillStyle = grd;
  X.beginPath();
  X.moveTo(w/2 + 5, 0);
  X.lineTo(0, -h/2);
  X.lineTo(-w/2, -h/4);
  X.lineTo(-w/2 + 4, 0);
  X.lineTo(-w/2, h/4);
  X.lineTo(0, h/2);
  X.closePath(); X.fill();
  // Faceted highlights - overlapping translucent triangles
  X.fillStyle = 'rgba(255,255,255,0.2)';
  X.beginPath(); X.moveTo(w/2 + 2, 0); X.lineTo(0, -h/2 + 4); X.lineTo(-w/4, 0); X.closePath(); X.fill();
  X.fillStyle = 'rgba(200,230,255,0.15)';
  X.beginPath(); X.moveTo(w/4, -h/4); X.lineTo(-w/6, -h/3); X.lineTo(-w/6, 0); X.closePath(); X.fill();
  X.fillStyle = 'rgba(255,255,255,0.1)';
  X.beginPath(); X.moveTo(-w/4, 0); X.lineTo(-w/2 + 4, h/4); X.lineTo(0, h/3); X.closePath(); X.fill();
  // Icy outline
  X.strokeStyle = '#88bbee'; X.lineWidth = 1.5;
  X.beginPath();
  X.moveTo(w/2 + 5, 0); X.lineTo(0, -h/2); X.lineTo(-w/2, -h/4);
  X.lineTo(-w/2 + 4, 0); X.lineTo(-w/2, h/4); X.lineTo(0, h/2);
  X.closePath(); X.stroke();
  // Sparkle accents
  const sp = Math.sin(t * 3) * 0.3 + 0.7;
  X.globalAlpha = sp;
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(w/6, -h/6, 2, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(-w/6, h/6, 1.5, 0, Math.PI * 2); X.fill();
  X.globalAlpha = 1;
}

function drawCubeSkin6() {
  const h = PSIZ;
  const t = Date.now() * 0.006;
  // Snowflake/sparkle trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 5; i++) {
    const fy = Math.sin(t * 1.5 + i * 1.8) * 5;
    X.globalAlpha = 0.4 - i * 0.07;
    X.fillStyle = i % 2 === 0 ? '#aaddff' : '#fff';
    X.beginPath(); X.arc(-h/2 - i * 7, fy, 2.5 - i * 0.3, 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Light blue body
  const grd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  grd.addColorStop(0, '#88ccff'); grd.addColorStop(1, '#66aaee');
  X.fillStyle = grd; X.fillRect(-h/2, -h/2, h, h);
  // White frost overlay triangles
  X.fillStyle = 'rgba(255,255,255,0.2)';
  X.beginPath(); X.moveTo(-h/2, -h/2); X.lineTo(h/4, -h/2); X.lineTo(-h/2, h/4); X.closePath(); X.fill();
  X.fillStyle = 'rgba(200,230,255,0.15)';
  X.beginPath(); X.moveTo(h/2, h/2); X.lineTo(-h/4, h/2); X.lineTo(h/2, -h/4); X.closePath(); X.fill();
  // Icy border
  X.strokeStyle = '#88bbee'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Blue eye
  X.fillStyle = '#4488cc'; X.fillRect(-3, -5, 10, 8);
  X.fillStyle = '#cceeff'; X.fillRect(0, -3, 5, 5);
}

// --- Skin 7: Seagull ---
function drawShipSkin7() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.006;
  const flap = Math.sin(t * 1.5) * 3;
  // White wisp trail
  if (trailStyle === 0) {
  for (let i = 0; i < 8; i++) {
    const fx = -w/2 - 6 - i * 7 + Math.sin(t * 1.3 + i * 1.5) * 3;
    const fy = Math.sin(t * 1.6 + i * 1.2) * 5;
    const sz = 3 - i * 0.3;
    X.globalAlpha = 0.35 - i * 0.04;
    X.fillStyle = '#ddeeff';
    X.beginPath(); X.arc(fx, fy, Math.max(0.5, sz), 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Tail feathers (short, behind body)
  X.fillStyle = '#99aabb';
  X.beginPath();
  X.moveTo(-w/4, -1);
  X.lineTo(-w/2 - 6, -h/8);
  X.lineTo(-w/2 - 8, 0);
  X.lineTo(-w/2 - 6, h/8);
  X.lineTo(-w/4, 1);
  X.closePath(); X.fill();
  // Wings (long, curved, with animated flap)
  // Top wing
  X.fillStyle = '#dde8f0';
  X.beginPath();
  X.moveTo(w/8, -2);
  X.quadraticCurveTo(w/10, -h/4 - flap, -w/4, -h/2 - 3 - flap);
  X.lineTo(-w/3 - 2, -h/2 + 2 - flap);
  X.quadraticCurveTo(-w/5, -h/5 - flap, -w/4, -2);
  X.closePath(); X.fill();
  // Bottom wing
  X.beginPath();
  X.moveTo(w/8, 2);
  X.quadraticCurveTo(w/10, h/4 + flap, -w/4, h/2 + 3 + flap);
  X.lineTo(-w/3 - 2, h/2 - 2 + flap);
  X.quadraticCurveTo(-w/5, h/5 + flap, -w/4, 2);
  X.closePath(); X.fill();
  // Gray/dark wing tips
  X.fillStyle = '#556677';
  X.beginPath();
  X.moveTo(-w/4 - 2, -h/2 - 1 - flap);
  X.lineTo(-w/3 - 4, -h/2 + 1 - flap);
  X.lineTo(-w/3, -h/2 + 5 - flap);
  X.closePath(); X.fill();
  X.beginPath();
  X.moveTo(-w/4 - 2, h/2 + 1 + flap);
  X.lineTo(-w/3 - 4, h/2 - 1 + flap);
  X.lineTo(-w/3, h/2 - 5 + flap);
  X.closePath(); X.fill();
  // Body (oval bird torso)
  X.fillStyle = '#f0f4f8';
  X.beginPath();
  X.ellipse(0, 0, w/3, h/7, 0, 0, Math.PI*2);
  X.fill();
  // Light belly highlight
  X.fillStyle = 'rgba(255,255,255,0.4)';
  X.beginPath();
  X.ellipse(0, 2, w/4, h/10, 0, 0, Math.PI*2);
  X.fill();
  // Head (round)
  X.fillStyle = '#f0f4f8';
  X.beginPath(); X.arc(w/4 + 2, -1, h/7, 0, Math.PI*2); X.fill();
  // Beak (yellow-orange, slightly curved down)
  X.fillStyle = '#eeaa33';
  X.beginPath();
  X.moveTo(w/4 + h/7, -1);
  X.lineTo(w/2 + 7, -1);
  X.lineTo(w/2 + 5, 2);
  X.quadraticCurveTo(w/2 + 3, 3, w/4 + h/7, 1);
  X.closePath(); X.fill();
  // Eye
  X.fillStyle = '#222';
  X.beginPath(); X.arc(w/4 + 4, -2, 2, 0, Math.PI*2); X.fill();
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(w/4 + 4.5, -2.5, 0.7, 0, Math.PI*2); X.fill();
}

function drawCubeSkin7() {
  const h = PSIZ;
  const t = Date.now() * 0.006;
  const flap = Math.sin(t * 1.5) * 2;
  // White wisp trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 5; i++) {
    const fy = Math.sin(t * 1.4 + i * 1.6) * 4;
    X.globalAlpha = 0.35 - i * 0.06;
    X.fillStyle = '#ddeeff';
    X.beginPath(); X.arc(-h/2 - i * 7, fy, 2.5 - i * 0.3, 0, Math.PI*2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Wings extending above and below cube
  X.fillStyle = '#dde8f0';
  // Top wing
  X.beginPath();
  X.moveTo(h/4, -h/2);
  X.quadraticCurveTo(0, -h/2 - 5 - flap, -h/4, -h/2 - 9 - flap);
  X.lineTo(-h/3, -h/2 - 5 - flap);
  X.quadraticCurveTo(-h/6, -h/2 - 1, -h/4, -h/2);
  X.closePath(); X.fill();
  // Bottom wing
  X.beginPath();
  X.moveTo(h/4, h/2);
  X.quadraticCurveTo(0, h/2 + 5 + flap, -h/4, h/2 + 9 + flap);
  X.lineTo(-h/3, h/2 + 5 + flap);
  X.quadraticCurveTo(-h/6, h/2 + 1, -h/4, h/2);
  X.closePath(); X.fill();
  // Dark wing tips
  X.fillStyle = '#556677';
  X.beginPath(); X.arc(-h/4, -h/2 - 8 - flap, 2, 0, Math.PI*2); X.fill();
  X.beginPath(); X.arc(-h/4, h/2 + 8 + flap, 2, 0, Math.PI*2); X.fill();
  // Tail feathers behind
  X.fillStyle = '#99aabb';
  X.beginPath();
  X.moveTo(-h/2, -h/8); X.lineTo(-h/2 - 5, -h/6); X.lineTo(-h/2 - 6, 0);
  X.lineTo(-h/2 - 5, h/6); X.lineTo(-h/2, h/8);
  X.closePath(); X.fill();
  // White body
  X.fillStyle = '#f0f4f8'; X.fillRect(-h/2, -h/2, h, h);
  // Belly highlight
  X.fillStyle = 'rgba(255,255,255,0.3)';
  X.fillRect(-h/4, -h/4, h/2, h/2);
  // Border
  X.strokeStyle = '#99aabb'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Beak stub on right edge
  X.fillStyle = '#eeaa33';
  X.beginPath();
  X.moveTo(h/2, -2); X.lineTo(h/2 + 5, 0); X.lineTo(h/2, 3);
  X.closePath(); X.fill();
  // Eye
  X.fillStyle = '#222';
  X.beginPath(); X.arc(h/6, -2, 2.5, 0, Math.PI*2); X.fill();
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(h/6 + 0.7, -2.5, 0.8, 0, Math.PI*2); X.fill();
}

// --- Skin 8: Dolphin ---
function drawShipSkin8() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.007;
  // Water droplet trail
  if (trailStyle === 0) {
  for (let i = 0; i < 8; i++) {
    const fx = -w/2 - 6 - i * 7 + Math.sin(t * 1.4 + i * 1.8) * 3;
    const fy = Math.sin(t * 2.0 + i * 1.3) * 7;
    const sz = 3 - i * 0.3;
    X.globalAlpha = 0.5 - i * 0.055;
    X.fillStyle = i % 2 === 0 ? '#66bbee' : '#aaddff';
    X.beginPath(); X.arc(fx, fy, Math.max(0.5, sz), 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Smooth curved blue-gray body
  const grd = X.createLinearGradient(0, -h/2, 0, h/2);
  grd.addColorStop(0, '#5588aa'); grd.addColorStop(0.5, '#88bbcc'); grd.addColorStop(1, '#ccddee');
  X.fillStyle = grd;
  X.beginPath();
  X.moveTo(w/2 + 4, 0);
  X.quadraticCurveTo(w/2 + 2, -h/3, w/6, -h/3);
  X.lineTo(-w/2, -h/4);
  X.lineTo(-w/2, h/4);
  X.lineTo(w/6, h/3);
  X.quadraticCurveTo(w/2 + 2, h/3, w/2 + 4, 0);
  X.closePath(); X.fill();
  // Lighter belly
  X.fillStyle = 'rgba(220,238,248,0.35)';
  X.beginPath();
  X.moveTo(w/2 + 2, 2);
  X.quadraticCurveTo(w/3, h/3 - 2, -w/3, h/4);
  X.lineTo(-w/3, 2);
  X.closePath(); X.fill();
  // Dorsal fin on top
  X.fillStyle = '#4477aa';
  X.beginPath(); X.moveTo(0, -h/3); X.lineTo(-w/8, -h/2 - 3); X.lineTo(-w/4, -h/3); X.closePath(); X.fill();
  // Tail fluke at back
  X.fillStyle = '#5588aa';
  X.beginPath(); X.moveTo(-w/2, -h/4); X.lineTo(-w/2 - 7, -h/3 - 3); X.lineTo(-w/3, -h/5); X.closePath(); X.fill();
  X.beginPath(); X.moveTo(-w/2, h/4); X.lineTo(-w/2 - 7, h/3 + 3); X.lineTo(-w/3, h/5); X.closePath(); X.fill();
  // Eye
  X.fillStyle = '#224';
  X.beginPath(); X.arc(w/5, -2, 2.5, 0, Math.PI * 2); X.fill();
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(w/5 + 0.8, -2.5, 0.8, 0, Math.PI * 2); X.fill();
}

function drawCubeSkin8() {
  const h = PSIZ;
  const t = Date.now() * 0.007;
  // Water splash trail
  if (trailStyle === 0) {
  for (let i = 1; i <= 5; i++) {
    const fy = Math.sin(t * 1.8 + i * 1.5) * 5;
    X.globalAlpha = 0.4 - i * 0.07;
    X.fillStyle = i % 2 === 0 ? '#66bbee' : '#aaddff';
    X.beginPath(); X.arc(-h/2 - i * 7, fy, 2.5 - i * 0.3, 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Blue-gray gradient body
  const grd = X.createLinearGradient(-h/2, -h/2, h/2, h/2);
  grd.addColorStop(0, '#5588aa'); grd.addColorStop(1, '#88bbcc');
  X.fillStyle = grd; X.fillRect(-h/2, -h/2, h, h);
  // Lighter blue inner
  X.fillStyle = '#aaccdd'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, h - 6);
  // Curved highlight
  X.fillStyle = 'rgba(255,255,255,0.15)';
  X.beginPath(); X.moveTo(-h/2, -h/2); X.lineTo(h/4, -h/2); X.lineTo(-h/2, h/4); X.closePath(); X.fill();
  // Border
  X.strokeStyle = '#4477aa'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Teal eye
  X.fillStyle = '#008899'; X.fillRect(-3, -5, 10, 8);
  X.fillStyle = '#ccffff'; X.fillRect(0, -3, 5, 5);
}

// --- Skin 9: Shooting Star ---
function drawShipSkin9() {
  const h = PSIZ, w = PSIZ;
  const t = Date.now() * 0.008;
  // Long rainbow/gold sparkle trail
  if (trailStyle === 0) {
  for (let i = 0; i < 12; i++) {
    const fx = -w/2 - 6 - i * 7 + Math.sin(t + i * 0.8) * 2;
    const fy = Math.sin(t * 1.5 + i * 1.2) * 5;
    const sz = 4 - i * 0.3;
    X.globalAlpha = 0.7 - i * 0.055;
    const hue = (t * 40 + i * 30) % 360;
    X.fillStyle = `hsl(${hue}, 90%, 65%)`;
    X.beginPath(); X.arc(fx, fy, Math.max(0.5, sz), 0, Math.PI * 2); X.fill();
  }
  X.globalAlpha = 1;
  }
  // Radiating glow
  X.save();
  X.shadowColor = '#ffdd44'; X.shadowBlur = 18;
  // Golden-white pointed star shape
  X.fillStyle = '#ffe866';
  X.beginPath();
  X.moveTo(w/2 + 6, 0);       // right point
  X.lineTo(w/8, -h/6);
  X.lineTo(0, -h/2);            // top point
  X.lineTo(-w/8, -h/6);
  X.lineTo(-w/2, -h/5);         // left-top point
  X.lineTo(-w/5, 0);
  X.lineTo(-w/2, h/5);          // left-bottom point
  X.lineTo(-w/8, h/6);
  X.lineTo(0, h/2);             // bottom point
  X.lineTo(w/8, h/6);
  X.closePath(); X.fill();
  X.restore();
  // White glow overlay
  X.fillStyle = 'rgba(255,255,255,0.3)';
  X.beginPath();
  X.moveTo(w/2 + 4, 0); X.lineTo(w/8, -h/8); X.lineTo(-w/6, 0); X.lineTo(w/8, h/8);
  X.closePath(); X.fill();
  // Sparkle accents
  const sp = Math.sin(t * 3) * 0.3 + 0.7;
  X.globalAlpha = sp;
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(w/6, -h/5, 2, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(-w/6, h/5, 1.5, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(w/4, h/8, 1.5, 0, Math.PI * 2); X.fill();
  X.globalAlpha = 1;
}

function drawCubeSkin9() {
  const h = PSIZ;
  const t = Date.now() * 0.008;
  // Gold/rainbow trail segments
  if (trailStyle === 0) {
  for (let i = 1; i <= 6; i++) {
    X.globalAlpha = 0.5 - i * 0.07;
    const hue = (t * 40 + i * 45) % 360;
    X.fillStyle = `hsl(${hue}, 90%, 65%)`;
    X.fillRect(-h/2 - i * 7, -h/2 + 5, 6, h - 10);
  }
  X.globalAlpha = 1;
  }
  // Golden body with glow
  X.save();
  X.shadowColor = '#ffdd44'; X.shadowBlur = 12;
  X.fillStyle = '#ffe866'; X.fillRect(-h/2, -h/2, h, h);
  X.restore();
  // White glow overlay
  X.fillStyle = 'rgba(255,255,255,0.25)'; X.fillRect(-h/2 + 3, -h/2 + 3, h - 6, h - 6);
  // Sparkle accents
  const sp = Math.sin(t * 3) * 0.3 + 0.7;
  X.globalAlpha = sp;
  X.fillStyle = '#fff';
  X.beginPath(); X.arc(-h/4, -h/4, 2, 0, Math.PI * 2); X.fill();
  X.beginPath(); X.arc(h/4, h/4, 1.5, 0, Math.PI * 2); X.fill();
  X.globalAlpha = 1;
  // Border
  X.strokeStyle = '#ccaa22'; X.lineWidth = 2; X.strokeRect(-h/2, -h/2, h, h);
  // Gold eye
  X.fillStyle = '#cc8800'; X.fillRect(-3, -5, 10, 8);
  X.fillStyle = '#fff'; X.fillRect(0, -3, 5, 5);
}

function drawPlayer() {
  if (P.dead) {
    particles.forEach(p => {
      p.x += p.vx; p.y += p.vy; p.vy += 0.3; p.life -= 0.02;
      if (p.life > 0) {
        X.globalAlpha = p.life; X.fillStyle = p.col;
        X.fillRect(p.x-p.sz/2, p.y-p.sz/2, p.sz, p.sz);
        X.globalAlpha = 1;
      }
    });
    particles = particles.filter(p => p.life > 0);
    return;
  }
  const cx = P.x+PSIZ/2, cy = P.y+PSIZ/2;
  X.save(); X.translate(cx, cy); X.rotate(P.rot * Math.PI / 180);

  // Custom trail overlay (if not default)
  if (trailStyle > 0) {
    const t = Date.now() * 0.008;
    const h = PSIZ;
    if (trailStyle === 1) { // Smoke — puffy expanding clouds
      for (let i = 0; i < 12; i++) {
        const age = (t * 0.6 + i * 0.4) % 5;
        const fx = -h/2 - 12 - i * 8;
        const fy = Math.sin(t * 0.5 + i * 0.7) * 4 - age * 1.5;
        const sz = 3 + age * 2.5 + i * 0.4;
        X.globalAlpha = Math.max(0, 0.4 - i * 0.03);
        X.fillStyle = TRAIL_COLORS[1][i % 4];
        X.beginPath(); X.arc(fx, fy, sz, 0, Math.PI * 2); X.fill();
        X.beginPath(); X.arc(fx + 3, fy - 2, sz * 0.6, 0, Math.PI * 2); X.fill();
      }
    } else if (trailStyle === 2) { // Fire — shooting flames
      // Bright core jet
      const grd = X.createLinearGradient(-h/2, 0, -h/2 - 60, 0);
      grd.addColorStop(0, 'rgba(255,255,200,0.7)');
      grd.addColorStop(0.2, 'rgba(255,220,0,0.5)');
      grd.addColorStop(0.5, 'rgba(255,100,0,0.3)');
      grd.addColorStop(1, 'rgba(255,0,0,0)');
      X.fillStyle = grd;
      const flicker = Math.sin(t * 6) * 2;
      X.beginPath();
      X.moveTo(-h/2, -h/5 + flicker);
      X.lineTo(-h/2 - 70 - Math.sin(t*4)*8, flicker * 0.5);
      X.lineTo(-h/2, h/5 + flicker);
      X.closePath(); X.fill();
      // Fire particles shooting out
      for (let i = 0; i < 14; i++) {
        const speed = 5 + i * 4;
        const fx = -h/2 - 4 - speed + Math.sin(t * 3 + i * 1.1) * (2 + i * 0.5);
        const fy = Math.sin(t * 4 + i * 1.7) * (3 + i * 0.8) + flicker * 0.3;
        const sz = Math.max(1, 6 - i * 0.35);
        X.globalAlpha = Math.max(0, 0.8 - i * 0.055);
        X.fillStyle = i < 3 ? '#ffffcc' : (i < 6 ? '#ffcc00' : (i < 10 ? '#ff6600' : '#cc2200'));
        X.beginPath(); X.arc(fx, fy, sz, 0, Math.PI * 2); X.fill();
      }
    } else if (trailStyle === 3) { // Rainbow — hue-cycling sparkles
      for (let i = 0; i < 12; i++) {
        const fx = -h/2 - 6 - i * 7 + Math.sin(t + i * 0.8) * 2;
        const fy = Math.sin(t * 1.5 + i * 1.2) * 5;
        const sz = 4 - i * 0.3;
        X.globalAlpha = 0.7 - i * 0.055;
        const hue = (t * 40 + i * 30) % 360;
        X.fillStyle = `hsl(${hue}, 90%, 65%)`;
        X.beginPath(); X.arc(fx, fy, Math.max(0.5, sz), 0, Math.PI * 2); X.fill();
      }
    } else if (trailStyle === 4) { // Candy — pieces tumbling and falling
      const candyColors = ['#ff44aa','#ff88cc','#88ddff','#ffee44','#66ff66','#ff6644'];
      for (let i = 0; i < 10; i++) {
        const seed = i * 137.5;
        const age = (t * 0.7 + seed) % 4;
        const fx = -h/2 - 6 - age * 18;
        const fy = -2 + age * age * 3 + Math.sin(seed) * 4;
        const sz = 4 - age * 0.5;
        const spin = t * 3 + seed;
        X.globalAlpha = Math.max(0, 0.8 - age * 0.18);
        X.save();
        X.translate(fx, fy);
        X.rotate(spin);
        X.fillStyle = candyColors[i % candyColors.length];
        // Alternate between circles, squares, and little stars
        if (i % 3 === 0) {
          X.beginPath(); X.arc(0, 0, sz, 0, Math.PI * 2); X.fill();
        } else if (i % 3 === 1) {
          X.fillRect(-sz, -sz, sz * 2, sz * 2);
        } else {
          X.beginPath();
          for (let p = 0; p < 5; p++) {
            const a = (p * 4 * Math.PI / 5) - Math.PI / 2;
            const r = p % 2 === 0 ? sz * 1.2 : sz * 0.5;
            if (p === 0) X.moveTo(Math.cos(a)*r, Math.sin(a)*r);
            else X.lineTo(Math.cos(a)*r, Math.sin(a)*r);
          }
          X.closePath(); X.fill();
        }
        X.restore();
      }
    } else if (trailStyle === 5) { // Snow — snowflake crystals
      for (let i = 0; i < 10; i++) {
        const seed = i * 73.7;
        const age = (t * 0.6 + seed) % 3.5;
        const fx = -h/2 - 6 - age * 14;
        const fy = Math.sin(seed) * 4 + age * age * 1.5;
        const sz = 4 - age * 0.6;
        const spin = t * 1.5 + seed;
        X.globalAlpha = Math.max(0, 0.75 - age * 0.18);
        X.strokeStyle = i % 3 === 0 ? '#ffffff' : (i % 3 === 1 ? '#cceeff' : '#aaddff');
        X.lineWidth = 0.8;
        X.save();
        X.translate(fx, fy);
        X.rotate(spin);
        // Draw 6-armed snowflake
        for (let a = 0; a < 6; a++) {
          const ang = a * Math.PI / 3;
          const cx = Math.cos(ang), sy = Math.sin(ang);
          X.beginPath(); X.moveTo(0, 0); X.lineTo(cx * sz, sy * sz); X.stroke();
          // Small branches
          X.beginPath(); X.moveTo(cx * sz * 0.5, sy * sz * 0.5);
          X.lineTo(cx * sz * 0.5 + Math.cos(ang + 0.8) * sz * 0.3, sy * sz * 0.5 + Math.sin(ang + 0.8) * sz * 0.3);
          X.stroke();
          X.beginPath(); X.moveTo(cx * sz * 0.5, sy * sz * 0.5);
          X.lineTo(cx * sz * 0.5 + Math.cos(ang - 0.8) * sz * 0.3, sy * sz * 0.5 + Math.sin(ang - 0.8) * sz * 0.3);
          X.stroke();
        }
        X.restore();
      }
    } else if (trailStyle === 6) { // Skin Echo — spits out tumbling mini copies like candy
      for (let i = 0; i < 10; i++) {
        const seed = i * 137.5;
        const age = (t * 0.7 + seed) % 4;
        const fx = -h/2 - 6 - age * 18;
        const fy = -2 + age * age * 3 + Math.sin(seed) * 4;
        const spin = t * 3 + seed;
        const sc = 0.5 - age * 0.05;
        X.save();
        X.translate(fx, fy);
        X.rotate(spin);
        X.scale(sc, sc);
        X.globalAlpha = Math.max(0, 0.9 - age * 0.18);
        if (P.ship) {
          switch(shipSkin) {
            case 0: drawShipSkin0(); break; case 1: drawShipSkin1(); break;
            case 2: drawShipSkin2(); break; case 3: drawShipSkin3(); break;
            case 4: drawShipSkin4(); break; case 5: drawShipSkin5(); break;
            case 6: drawShipSkin6(); break; case 7: drawShipSkin7(); break;
            case 8: drawShipSkin8(); break; case 9: drawShipSkin9(); break;
          }
        } else {
          switch(shipSkin) {
            case 0: drawCubeSkin0(); break; case 1: drawCubeSkin1(); break;
            case 2: drawCubeSkin2(); break; case 3: drawCubeSkin3(); break;
            case 4: drawCubeSkin4(); break; case 5: drawCubeSkin5(); break;
            case 6: drawCubeSkin6(); break; case 7: drawCubeSkin7(); break;
            case 8: drawCubeSkin8(); break; case 9: drawCubeSkin9(); break;
          }
        }
        X.restore();
      }
    }
    X.globalAlpha = 1;
  }

  if (P.ship) {
    switch (shipSkin) {
      case 0: drawShipSkin0(); break;
      case 1: drawShipSkin1(); break;
      case 2: drawShipSkin2(); break;
      case 3: drawShipSkin3(); break;
      case 4: drawShipSkin4(); break;
      case 5: drawShipSkin5(); break;
      case 6: drawShipSkin6(); break;
      case 7: drawShipSkin7(); break;
      case 8: drawShipSkin8(); break;
      case 9: drawShipSkin9(); break;
    }
  } else {
    switch (shipSkin) {
      case 0: drawCubeSkin0(); break;
      case 1: drawCubeSkin1(); break;
      case 2: drawCubeSkin2(); break;
      case 3: drawCubeSkin3(); break;
      case 4: drawCubeSkin4(); break;
      case 5: drawCubeSkin5(); break;
      case 6: drawCubeSkin6(); break;
      case 7: drawCubeSkin7(); break;
      case 8: drawCubeSkin8(); break;
      case 9: drawCubeSkin9(); break;
    }
  }
  X.restore();
}

// ================================================================
// MAIN LOOP
// ================================================================
function checkSpeedUp() {
  if (state !== 'playing') return;
  const elapsed = (Date.now() - gameStartTime) / 1000;
  const count = Math.floor(elapsed / 30);
  if (count > lastSpeedUpCount) {
    lastSpeedUpCount = count;
    SPEED = baseSpeed + count * 0.5;
    document.getElementById('v-speed').textContent = SPEED.toFixed(1);
    document.getElementById('s-speed').value = SPEED;
    speedUpFlash = Date.now();
  }
}

function drawSpeedUpFlash() {
  if (speedUpFlash === 0) return;
  const elapsed = Date.now() - speedUpFlash;
  if (elapsed > 1500) { speedUpFlash = 0; return; }
  const alpha = elapsed < 300 ? elapsed / 300 : Math.max(0, 1 - (elapsed - 300) / 1200);
  X.save();
  X.globalAlpha = alpha;
  X.fillStyle = '#ff4400';
  X.font = 'bold 48px Arial';
  X.textAlign = 'center';
  X.textBaseline = 'middle';
  X.shadowColor = '#ff4400';
  X.shadowBlur = 20;
  X.fillText('SPEED UP!', W / 2, H / 2 - 40);
  X.restore();
}

function loop() {
  try {
    X.clearRect(0, 0, W, H);
    drawBG();
    drawObjects();
    checkSpeedUp();
    update();
    drawPlayer();
    drawSpeedUpFlash();
  } catch(e) {
    console.error('Game error:', e);
  }
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
