<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stereo Madness - Interactive Video Analyzer</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a1a;
  color: #e0e0e0;
  font-family: 'Segoe UI', Arial, sans-serif;
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Top bar */
.top-bar {
  background: #111128;
  border-bottom: 1px solid #2a2a50;
  padding: 10px 20px;
  display: flex;
  align-items: center;
  gap: 16px;
  flex-shrink: 0;
}
.top-bar h1 {
  font-size: 18px;
  color: #fff;
  text-shadow: 0 0 10px #0af;
}
.top-bar .badge {
  background: #0af;
  color: #000;
  font-size: 11px;
  font-weight: 700;
  padding: 2px 8px;
  border-radius: 10px;
}
.top-bar .spacer { flex: 1; }
.top-bar .help-text { font-size: 12px; color: #666; }

/* Main layout */
.main {
  display: flex;
  flex: 1;
  min-height: 0;
}

/* Left panel - viewer */
.viewer-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
}

.frame-viewer {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #000;
  position: relative;
  overflow: hidden;
  min-height: 0;
}
.frame-viewer img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}
.frame-overlay {
  position: absolute;
  top: 12px;
  left: 12px;
  display: flex;
  gap: 8px;
  align-items: center;
}
.frame-time-badge {
  background: rgba(0,0,0,0.7);
  color: #0af;
  padding: 4px 12px;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 600;
  font-variant-numeric: tabular-nums;
}
.frame-number-badge {
  background: rgba(0,0,0,0.7);
  color: #888;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 12px;
}
.scene-badge {
  position: absolute;
  top: 12px;
  right: 12px;
  padding: 4px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
}

/* Controls */
.controls {
  background: #111128;
  border-top: 1px solid #2a2a50;
  padding: 12px 20px;
  flex-shrink: 0;
}
.scrubber-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}
.scrubber {
  flex: 1;
  -webkit-appearance: none;
  appearance: none;
  height: 8px;
  border-radius: 4px;
  background: #1a1a40;
  outline: none;
  position: relative;
}
.scrubber::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #0af;
  cursor: pointer;
  box-shadow: 0 0 8px #0af;
}
.scrubber-time {
  font-size: 13px;
  color: #888;
  font-variant-numeric: tabular-nums;
  min-width: 80px;
}
.btn-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.btn {
  background: #1a1a40;
  border: 1px solid #2a2a50;
  color: #ccc;
  padding: 6px 14px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  transition: all 0.15s;
}
.btn:hover { background: #252560; border-color: #0af; color: #fff; }
.btn.active { background: #0a3a6a; border-color: #0af; color: #0af; }
.btn-icon { font-size: 16px; padding: 6px 10px; }
.speed-label { font-size: 12px; color: #666; margin-left: 12px; }

/* Markers on scrubber */
.scrubber-container {
  position: relative;
  flex: 1;
}
.marker-track {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 8px;
  pointer-events: none;
}
.marker-dot {
  position: absolute;
  top: -3px;
  width: 4px;
  height: 14px;
  background: #ff0;
  border-radius: 2px;
  pointer-events: auto;
  cursor: pointer;
  z-index: 2;
}
.marker-dot:hover { background: #fff; }
.marker-dot.scene-marker { background: #f06; height: 16px; top: -4px; width: 3px; }

/* Right panel - notes */
.notes-panel {
  width: 380px;
  background: #0d0d25;
  border-left: 1px solid #2a2a50;
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
}
.notes-header {
  padding: 14px 16px;
  border-bottom: 1px solid #2a2a50;
  display: flex;
  align-items: center;
  gap: 10px;
}
.notes-header h2 { font-size: 15px; flex: 1; }
.tab-btn {
  background: none;
  border: 1px solid #2a2a50;
  color: #888;
  padding: 4px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}
.tab-btn.active { border-color: #0af; color: #0af; background: #0a2a4a; }

/* Notes list */
.notes-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}
.note-card {
  background: #151530;
  border: 1px solid #2a2a50;
  border-radius: 8px;
  padding: 10px 12px;
  margin-bottom: 6px;
  cursor: pointer;
  transition: border-color 0.15s;
}
.note-card:hover { border-color: #0af; }
.note-card.active { border-color: #0af; background: #1a1a50; }
.note-time {
  font-size: 11px;
  color: #0af;
  font-weight: 600;
  margin-bottom: 4px;
}
.note-text {
  font-size: 13px;
  color: #ccc;
  line-height: 1.4;
}
.note-tags {
  margin-top: 6px;
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
}
.note-tag {
  font-size: 10px;
  padding: 1px 6px;
  border-radius: 8px;
  background: #0af2;
  color: #0af;
  border: 1px solid #0af4;
}

/* Add note area */
.add-note-area {
  border-top: 1px solid #2a2a50;
  padding: 12px;
  flex-shrink: 0;
}
.add-note-area textarea {
  width: 100%;
  background: #111128;
  border: 1px solid #2a2a50;
  border-radius: 6px;
  color: #e0e0e0;
  padding: 8px 10px;
  font-family: inherit;
  font-size: 13px;
  resize: none;
  height: 60px;
  outline: none;
}
.add-note-area textarea:focus { border-color: #0af; }
.add-note-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-top: 8px;
}
.tag-input {
  flex: 1;
  background: #111128;
  border: 1px solid #2a2a50;
  border-radius: 4px;
  color: #e0e0e0;
  padding: 4px 8px;
  font-size: 12px;
  outline: none;
}
.tag-input:focus { border-color: #0af; }
.add-btn {
  background: #0af;
  color: #000;
  border: none;
  padding: 5px 14px;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 600;
  font-size: 12px;
}
.add-btn:hover { background: #0cf; }

/* Scene info */
.scene-info-box {
  border-top: 1px solid #2a2a50;
  padding: 12px;
  flex-shrink: 0;
  background: #0a0a20;
}
.scene-info-title {
  font-size: 13px;
  font-weight: 600;
  margin-bottom: 4px;
}
.scene-info-desc {
  font-size: 11px;
  color: #888;
  line-height: 1.5;
  max-height: 60px;
  overflow-y: auto;
}

/* Keyboard hints */
.kbd {
  display: inline-block;
  background: #1a1a40;
  border: 1px solid #2a2a50;
  border-radius: 3px;
  padding: 1px 6px;
  font-size: 11px;
  color: #888;
  font-family: monospace;
}

/* Export area */
.export-area {
  display: none;
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: #151530;
  border: 1px solid #2a2a50;
  border-radius: 12px;
  padding: 24px;
  z-index: 100;
  width: 500px;
  max-height: 80vh;
  overflow-y: auto;
}
.export-area.active { display: block; }
.export-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.7);
  z-index: 99;
}
.export-overlay.active { display: block; }
.export-area h3 { margin-bottom: 12px; }
.export-area textarea {
  width: 100%;
  height: 300px;
  background: #0a0a1a;
  color: #ccc;
  border: 1px solid #2a2a50;
  border-radius: 6px;
  padding: 10px;
  font-family: monospace;
  font-size: 12px;
  resize: vertical;
}
.export-area .btn { margin-top: 10px; }

/* Drawing canvas overlay */
.draw-canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100%;
  height: 100%;
  cursor: crosshair;
  display: none;
}
.draw-canvas.active { display: block; }

/* Selection overlay */
.select-canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100%;
  height: 100%;
  cursor: crosshair;
  display: none;
  z-index: 10;
}
.select-canvas.active { display: block; }

/* Tool mode indicator */
.tool-indicator {
  position: absolute;
  bottom: 12px;
  left: 12px;
  padding: 4px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  display: none;
  z-index: 11;
  pointer-events: none;
}
.tool-indicator.active { display: block; }
.tool-indicator.select-mode { background: rgba(255,100,0,0.8); color: #fff; }
.tool-indicator.draw-mode { background: rgba(255,255,0,0.8); color: #000; }

/* Zoom panel (shows selected region) */
.zoom-panel {
  display: none;
  position: absolute;
  bottom: 12px;
  right: 12px;
  background: #111128;
  border: 2px solid #f60;
  border-radius: 10px;
  overflow: hidden;
  z-index: 20;
  box-shadow: 0 4px 24px rgba(0,0,0,0.7);
  max-width: 400px;
  max-height: 350px;
}
.zoom-panel.active { display: flex; flex-direction: column; }
.zoom-panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 10px;
  background: #1a1a40;
  border-bottom: 1px solid #2a2a50;
}
.zoom-panel-header span { font-size: 11px; color: #f60; font-weight: 600; }
.zoom-panel-close {
  cursor: pointer;
  color: #888;
  font-size: 16px;
  line-height: 1;
  padding: 0 4px;
}
.zoom-panel-close:hover { color: #fff; }
.zoom-panel canvas {
  display: block;
}
.zoom-panel-actions {
  display: flex;
  gap: 6px;
  padding: 6px 10px;
  background: #1a1a40;
  border-top: 1px solid #2a2a50;
}
.zoom-panel-actions .btn { font-size: 11px; padding: 3px 10px; }

/* Selection rectangles drawn on frame */
.selection-rect {
  position: absolute;
  border: 2px solid #f60;
  border-radius: 3px;
  pointer-events: auto;
  cursor: pointer;
  z-index: 5;
  transition: border-color 0.15s;
}
.selection-rect:hover { border-color: #ff0; }
.selection-rect .sel-label {
  position: absolute;
  top: -18px;
  left: -2px;
  background: #f60;
  color: #fff;
  font-size: 9px;
  font-weight: 700;
  padding: 1px 6px;
  border-radius: 3px 3px 0 0;
  white-space: nowrap;
  pointer-events: none;
}
.selection-rect:hover .sel-label { background: #ff0; color: #000; }
.selection-rect .sel-delete {
  position: absolute;
  top: -18px;
  right: -2px;
  background: #f00;
  color: #fff;
  font-size: 9px;
  font-weight: 700;
  padding: 1px 5px;
  border-radius: 0 3px 0 0;
  cursor: pointer;
  display: none;
}
.selection-rect:hover .sel-delete { display: block; }

/* Note card with selection thumbnail */
.note-thumb {
  margin-top: 6px;
  border-radius: 4px;
  overflow: hidden;
  border: 1px solid #2a2a50;
  max-width: 200px;
  cursor: pointer;
}
.note-thumb img {
  width: 100%;
  display: block;
}
.note-thumb:hover { border-color: #f60; }
</style>
</head>
<body>

<div class="top-bar">
  <h1>Stereo Madness Analyzer</h1>
  <span class="badge">INTERACTIVE</span>
  <span class="spacer"></span>
  <span class="help-text">
    <span class="kbd">&larr;</span> <span class="kbd">&rarr;</span> Navigate &nbsp;
    <span class="kbd">Space</span> Play/Pause &nbsp;
    <span class="kbd">N</span> Add Note &nbsp;
    <span class="kbd">S</span> Select Region &nbsp;
    <span class="kbd">D</span> Draw
  </span>
</div>

<div class="main">
  <div class="viewer-panel">
    <div class="frame-viewer" id="frameViewer">
      <img id="frameImg" src="frames_hd/f_0001.jpg" alt="Frame">
      <canvas class="draw-canvas" id="drawCanvas"></canvas>
      <canvas class="select-canvas" id="selectCanvas"></canvas>
      <div id="selectionRectsContainer"></div>
      <div class="frame-overlay">
        <span class="frame-time-badge" id="timeBadge">0:00.0</span>
        <span class="frame-number-badge" id="frameBadge">1 / 182</span>
      </div>
      <span class="scene-badge" id="sceneBadge" style="background:rgba(0,100,255,0.7);color:#fff;">Scene 1: Intro</span>
      <div class="tool-indicator" id="toolIndicator"></div>
      <div class="zoom-panel" id="zoomPanel">
        <div class="zoom-panel-header">
          <span>Selected Region</span>
          <span class="zoom-panel-close" onclick="closeZoom()">&times;</span>
        </div>
        <canvas id="zoomCanvas" width="380" height="250"></canvas>
        <div class="zoom-panel-actions">
          <button class="btn" onclick="noteFromSelection()">Add Note for Selection</button>
          <button class="btn" onclick="saveSelectionAsImage()">Save Crop</button>
          <button class="btn" onclick="closeZoom()">Close</button>
        </div>
      </div>
    </div>

    <div class="controls">
      <div class="scrubber-row">
        <div class="scrubber-container">
          <input type="range" class="scrubber" id="scrubber" min="1" max="182" value="1">
          <div class="marker-track" id="markerTrack"></div>
        </div>
        <span class="scrubber-time" id="scrubberTime">0:00 / 1:31</span>
      </div>
      <div class="btn-row">
        <button class="btn btn-icon" id="btnPrev" title="Previous frame">&#9664;&#9664;</button>
        <button class="btn btn-icon" id="btnPlay" title="Play/Pause">&#9654;</button>
        <button class="btn btn-icon" id="btnNext" title="Next frame">&#9654;&#9654;</button>
        <span class="speed-label">Speed:</span>
        <button class="btn speed-btn" data-speed="0.5">0.5x</button>
        <button class="btn speed-btn active" data-speed="1">1x</button>
        <button class="btn speed-btn" data-speed="2">2x</button>
        <button class="btn speed-btn" data-speed="4">4x</button>
        <span style="flex:1"></span>
        <button class="btn" id="btnSelect">Select</button>
        <button class="btn" id="btnDraw">Draw</button>
        <button class="btn" id="btnClearDraw">Clear All</button>
        <button class="btn" id="btnExport">Export Notes</button>
      </div>
    </div>
  </div>

  <div class="notes-panel">
    <div class="notes-header">
      <h2>Notes & Annotations</h2>
      <button class="tab-btn active" data-tab="notes">Notes</button>
      <button class="tab-btn" data-tab="scenes">Scenes</button>
    </div>

    <div class="notes-list" id="notesList">
      <div style="text-align:center; color:#555; padding: 30px 10px; font-size:13px;">
        No notes yet.<br>Scrub to a frame and add your observations below.
      </div>
    </div>

    <div class="scene-info-box" id="sceneInfoBox">
      <div class="scene-info-title" id="sceneInfoTitle">Scene 1: Intro - First Steps</div>
      <div class="scene-info-desc" id="sceneInfoDesc">The level begins. Simple obstacles appear: ground-level spikes and the first blocks. Blue/purple environment.</div>
    </div>

    <div class="add-note-area">
      <textarea id="noteInput" placeholder="Type your observation about this frame...&#10;What obstacles do you see? What patterns?"></textarea>
      <div class="add-note-row">
        <input class="tag-input" id="tagInput" placeholder="Tags (comma-separated)" value="">
        <button class="add-btn" id="btnAddNote">Add Note</button>
      </div>
    </div>
  </div>
</div>

<!-- Export modal -->
<div class="export-overlay" id="exportOverlay" onclick="closeExport()"></div>
<div class="export-area" id="exportArea">
  <h3>Export Notes</h3>
  <textarea id="exportText" readonly></textarea>
  <button class="btn" onclick="copyExport()">Copy to Clipboard</button>
  <button class="btn" onclick="closeExport()" style="margin-left:8px;">Close</button>
</div>

<script>
// ============================================================
// CONFIG
// ============================================================
const TOTAL_FRAMES = 182;
const FPS = 2;
const TOTAL_DURATION = 91;

const scenes = [
  { start: 1, end: 12, title: "Intro - First Steps", color: "#0064ff", desc: "The level begins. Simple obstacles: ground-level spikes and first blocks. Blue/purple environment." },
  { start: 13, end: 24, title: "Blocks & Pillars", color: "#5030cc", desc: "Single/double ground spikes, 1-wide blocks, taller 2-3 block pillars, collectible orbs." },
  { start: 25, end: 40, title: "Long Platforms & Spike Rows", color: "#7030b0", desc: "Extended block platforms with grid texture, spike rows, floating half-width platforms, quad spikes." },
  { start: 41, end: 56, title: "Floating Platforms & Gap Jumps", color: "#8030a0", desc: "Small floating platforms, precise gap jumps, spike on platform, large raised sections." },
  { start: 57, end: 80, title: "Ship Mode (Pink)", color: "#d02060", desc: "Portal to SHIP MODE. Hold to fly up, release to fall. Ceiling + floor spikes, narrow passages, pink/magenta BG." },
  { start: 81, end: 100, title: "Back to Cube - Jump Pads", color: "#6030c0", desc: "Portal back to cube. Tall staircase pillars, yellow jump pads, hanging ceiling spikes." },
  { start: 101, end: 124, title: "Red Section - Fire & Chains", color: "#cc2020", desc: "Deep red color. Fire/flame deco, hanging chain-spikes from ceiling, ground spikes with blocks." },
  { start: 125, end: 148, title: "Red Platforms & Orbs", color: "#b02020", desc: "Floating platform hopping, smiley orbs, fire deco, jump pad chains. Portal to pink at end." },
  { start: 149, end: 176, title: "Ship Finale (Magenta)", color: "#c030c0", desc: "Final ship section. Dense corridors, ceiling+floor spikes, block walls, smiley orbs. Hardest section." },
  { start: 177, end: 182, title: "Level Complete!", color: "#d040d0", desc: "LEVEL COMPLETE! Burst effect with radiating beams, particle effects, victory animation." }
];

// State
let currentFrame = 1;
let isPlaying = false;
let playInterval = null;
let playSpeed = 1;
let notes = [];
let drawMode = false;
let selectMode = false;
let isDrawing = false;
let isSelecting = false;
let lastDrawPos = null;
let selStart = null;
let selEnd = null;
let currentSelection = null; // {x, y, w, h} in image-relative percentages
let selections = []; // saved selections per frame: [{frame, x, y, w, h, label}]

// Elements
const frameImg = document.getElementById('frameImg');
const scrubber = document.getElementById('scrubber');
const timeBadge = document.getElementById('timeBadge');
const frameBadge = document.getElementById('frameBadge');
const sceneBadge = document.getElementById('sceneBadge');
const scrubberTime = document.getElementById('scrubberTime');
const notesList = document.getElementById('notesList');
const noteInput = document.getElementById('noteInput');
const tagInput = document.getElementById('tagInput');
const sceneInfoTitle = document.getElementById('sceneInfoTitle');
const sceneInfoDesc = document.getElementById('sceneInfoDesc');
const markerTrack = document.getElementById('markerTrack');
const drawCanvas = document.getElementById('drawCanvas');
const drawCtx = drawCanvas.getContext('2d');
const selectCanvas = document.getElementById('selectCanvas');
const selectCtx = selectCanvas.getContext('2d');
const zoomPanel = document.getElementById('zoomPanel');
const zoomCanvas = document.getElementById('zoomCanvas');
const zoomCtx = zoomCanvas.getContext('2d');
const toolIndicator = document.getElementById('toolIndicator');
const selRectsContainer = document.getElementById('selectionRectsContainer');

// Load saved data from localStorage
try {
  const saved = localStorage.getItem('stereo-madness-notes');
  if (saved) notes = JSON.parse(saved);
  const savedSel = localStorage.getItem('stereo-madness-selections');
  if (savedSel) selections = JSON.parse(savedSel);
} catch(e) {}

// ============================================================
// HELPERS
// ============================================================
function padFrame(n) { return String(n).padStart(4, '0'); }

function frameToTime(f) {
  const secs = (f - 1) / FPS;
  const m = Math.floor(secs / 60);
  const s = secs % 60;
  return `${m}:${s.toFixed(1).padStart(4, '0')}`;
}

function frameToTimeShort(f) {
  const secs = (f - 1) / FPS;
  const m = Math.floor(secs / 60);
  const s = Math.floor(secs % 60);
  return `${m}:${String(s).padStart(2, '0')}`;
}

function getScene(f) {
  for (const s of scenes) { if (f >= s.start && f <= s.end) return s; }
  return scenes[scenes.length - 1];
}

// Get the actual rendered position/size of the image inside the viewer
function getImgRect() {
  const viewer = document.getElementById('frameViewer');
  const vw = viewer.clientWidth;
  const vh = viewer.clientHeight;
  const iw = frameImg.naturalWidth || 640;
  const ih = frameImg.naturalHeight || 296;
  const scale = Math.min(vw / iw, vh / ih);
  const rw = iw * scale;
  const rh = ih * scale;
  const rx = (vw - rw) / 2;
  const ry = (vh - rh) / 2;
  return { x: rx, y: ry, w: rw, h: rh, scale };
}

// Convert mouse position to image-relative percentage (0-1)
function mouseToImgPct(e, canvas) {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const ir = getImgRect();
  const px = (mx - ir.x) / ir.w;
  const py = (my - ir.y) / ir.h;
  return { px: Math.max(0, Math.min(1, px)), py: Math.max(0, Math.min(1, py)) };
}

// ============================================================
// FRAME NAVIGATION
// ============================================================
function goToFrame(f) {
  currentFrame = Math.max(1, Math.min(TOTAL_FRAMES, f));
  frameImg.src = `frames_hd/f_${padFrame(currentFrame)}.jpg`;
  scrubber.value = currentFrame;
  timeBadge.textContent = frameToTime(currentFrame);
  frameBadge.textContent = `${currentFrame} / ${TOTAL_FRAMES}`;
  scrubberTime.textContent = `${frameToTimeShort(currentFrame)} / 1:31`;

  const scene = getScene(currentFrame);
  const sceneIdx = scenes.indexOf(scene) + 1;
  sceneBadge.textContent = `Scene ${sceneIdx}: ${scene.title}`;
  sceneBadge.style.background = scene.color + 'cc';
  sceneInfoTitle.textContent = `Scene ${sceneIdx}: ${scene.title}`;
  sceneInfoDesc.textContent = scene.desc;

  document.querySelectorAll('.note-card').forEach(card => {
    card.classList.toggle('active', parseInt(card.dataset.frame) === currentFrame);
  });

  resizeCanvases();
  renderSelectionRects();
  clearSelectOverlay();
}

function resizeCanvases() {
  const viewer = document.getElementById('frameViewer');
  const w = viewer.clientWidth;
  const h = viewer.clientHeight;
  drawCanvas.width = w;
  drawCanvas.height = h;
  selectCanvas.width = w;
  selectCanvas.height = h;
}

// ============================================================
// PLAYBACK
// ============================================================
function togglePlay() { isPlaying ? stopPlay() : startPlay(); }

function startPlay() {
  isPlaying = true;
  document.getElementById('btnPlay').innerHTML = '&#9646;&#9646;';
  playInterval = setInterval(() => {
    if (currentFrame >= TOTAL_FRAMES) { stopPlay(); return; }
    goToFrame(currentFrame + 1);
  }, 500 / playSpeed);
}

function stopPlay() {
  isPlaying = false;
  document.getElementById('btnPlay').innerHTML = '&#9654;';
  if (playInterval) clearInterval(playInterval);
  playInterval = null;
}

function setSpeed(s) {
  playSpeed = s;
  document.querySelectorAll('.speed-btn').forEach(b => {
    b.classList.toggle('active', parseFloat(b.dataset.speed) === s);
  });
  if (isPlaying) { stopPlay(); startPlay(); }
}

// ============================================================
// SELECTION TOOL
// ============================================================
function toggleSelect() {
  if (drawMode) toggleDraw();
  selectMode = !selectMode;
  selectCanvas.classList.toggle('active', selectMode);
  document.getElementById('btnSelect').classList.toggle('active', selectMode);
  updateToolIndicator();
}

function updateToolIndicator() {
  if (selectMode) {
    toolIndicator.textContent = 'SELECT MODE - Drag to select a region';
    toolIndicator.className = 'tool-indicator active select-mode';
  } else if (drawMode) {
    toolIndicator.textContent = 'DRAW MODE - Draw on the frame';
    toolIndicator.className = 'tool-indicator active draw-mode';
  } else {
    toolIndicator.className = 'tool-indicator';
  }
}

function clearSelectOverlay() {
  selectCtx.clearRect(0, 0, selectCanvas.width, selectCanvas.height);
}

selectCanvas.addEventListener('mousedown', e => {
  if (!selectMode) return;
  isSelecting = true;
  selStart = mouseToImgPct(e, selectCanvas);
  selEnd = null;
  currentSelection = null;
  closeZoom();
});

selectCanvas.addEventListener('mousemove', e => {
  if (!isSelecting || !selectMode) return;
  selEnd = mouseToImgPct(e, selectCanvas);
  drawSelectRect();
});

selectCanvas.addEventListener('mouseup', e => {
  if (!isSelecting || !selectMode) return;
  isSelecting = false;
  selEnd = mouseToImgPct(e, selectCanvas);
  finalizeSelection();
});

selectCanvas.addEventListener('mouseleave', e => {
  if (isSelecting) {
    isSelecting = false;
    if (selEnd) finalizeSelection();
  }
});

function drawSelectRect() {
  if (!selStart || !selEnd) return;
  const ir = getImgRect();
  clearSelectOverlay();

  const x1 = ir.x + Math.min(selStart.px, selEnd.px) * ir.w;
  const y1 = ir.y + Math.min(selStart.py, selEnd.py) * ir.h;
  const x2 = ir.x + Math.max(selStart.px, selEnd.px) * ir.w;
  const y2 = ir.y + Math.max(selStart.py, selEnd.py) * ir.h;
  const w = x2 - x1;
  const h = y2 - y1;

  // Dim outside
  selectCtx.fillStyle = 'rgba(0,0,0,0.5)';
  selectCtx.fillRect(0, 0, selectCanvas.width, selectCanvas.height);
  selectCtx.clearRect(x1, y1, w, h);

  // Selection border
  selectCtx.strokeStyle = '#f60';
  selectCtx.lineWidth = 2;
  selectCtx.setLineDash([6, 3]);
  selectCtx.strokeRect(x1, y1, w, h);
  selectCtx.setLineDash([]);

  // Corner handles
  const hs = 6;
  selectCtx.fillStyle = '#f60';
  [[x1, y1], [x2, y1], [x1, y2], [x2, y2]].forEach(([cx, cy]) => {
    selectCtx.fillRect(cx - hs/2, cy - hs/2, hs, hs);
  });

  // Size label
  const iw = frameImg.naturalWidth || 640;
  const ih = frameImg.naturalHeight || 296;
  const pw = Math.round(Math.abs(selEnd.px - selStart.px) * iw);
  const ph = Math.round(Math.abs(selEnd.py - selStart.py) * ih);
  selectCtx.fillStyle = 'rgba(255,102,0,0.85)';
  selectCtx.fillRect(x1, y1 - 20, 80, 18);
  selectCtx.fillStyle = '#fff';
  selectCtx.font = '11px sans-serif';
  selectCtx.fillText(`${pw} x ${ph}`, x1 + 4, y1 - 6);
}

function finalizeSelection() {
  if (!selStart || !selEnd) return;

  const px = Math.min(selStart.px, selEnd.px);
  const py = Math.min(selStart.py, selEnd.py);
  const pw = Math.abs(selEnd.px - selStart.px);
  const ph = Math.abs(selEnd.py - selStart.py);

  // Ignore tiny accidental clicks
  if (pw < 0.02 && ph < 0.02) {
    clearSelectOverlay();
    return;
  }

  currentSelection = { px, py, pw, ph };
  showZoomPanel();
}

function showZoomPanel() {
  if (!currentSelection) return;

  const sel = currentSelection;
  const iw = frameImg.naturalWidth || 640;
  const ih = frameImg.naturalHeight || 296;

  // Source crop in image pixels
  const sx = sel.px * iw;
  const sy = sel.py * ih;
  const sw = sel.pw * iw;
  const sh = sel.ph * ih;

  // Fit into zoom canvas while preserving aspect ratio
  const maxW = 380;
  const maxH = 280;
  const aspect = sw / sh;
  let dw, dh;
  if (aspect > maxW / maxH) {
    dw = maxW;
    dh = maxW / aspect;
  } else {
    dh = maxH;
    dw = maxH * aspect;
  }
  zoomCanvas.width = Math.round(dw);
  zoomCanvas.height = Math.round(dh);

  // Wait for the image to be loaded then draw
  const tmpImg = new Image();
  tmpImg.onload = () => {
    zoomCtx.imageSmoothingEnabled = true;
    zoomCtx.drawImage(tmpImg, sx, sy, sw, sh, 0, 0, dw, dh);
  };
  tmpImg.src = frameImg.src;

  zoomPanel.classList.add('active');
}

function closeZoom() {
  zoomPanel.classList.remove('active');
  currentSelection = null;
  clearSelectOverlay();
}

function noteFromSelection() {
  if (!currentSelection) return;

  // Create a thumbnail data URL
  const dataUrl = zoomCanvas.toDataURL('image/jpeg', 0.85);

  const sel = currentSelection;
  const iw = frameImg.naturalWidth || 640;
  const ih = frameImg.naturalHeight || 296;
  const region = `(${Math.round(sel.px*iw)},${Math.round(sel.py*ih)}) ${Math.round(sel.pw*iw)}x${Math.round(sel.ph*ih)}`;

  noteInput.value = '';
  noteInput.placeholder = `Describe what you see in the selected region [${region}]...`;
  noteInput.focus();

  // Store the pending selection so we attach it when the note is added
  noteInput.dataset.pendingThumb = dataUrl;
  noteInput.dataset.pendingRegion = JSON.stringify(sel);

  // Also save selection rect for this frame
  selections.push({
    frame: currentFrame,
    ...sel,
    label: `Selection ${selections.filter(s => s.frame === currentFrame).length + 1}`
  });
  saveSelections();
  renderSelectionRects();
}

function saveSelectionAsImage() {
  if (!currentSelection) return;
  const link = document.createElement('a');
  link.download = `stereo-madness_frame${currentFrame}_crop.jpg`;
  link.href = zoomCanvas.toDataURL('image/jpeg', 0.92);
  link.click();
}

function saveSelections() {
  localStorage.setItem('stereo-madness-selections', JSON.stringify(selections));
}

function deleteSelection(idx) {
  selections.splice(idx, 1);
  saveSelections();
  renderSelectionRects();
}

function renderSelectionRects() {
  selRectsContainer.innerHTML = '';
  const frameSels = selections.filter(s => s.frame === currentFrame);
  if (!frameSels.length) return;

  const ir = getImgRect();

  frameSels.forEach((sel, i) => {
    const globalIdx = selections.indexOf(sel);
    const div = document.createElement('div');
    div.className = 'selection-rect';
    div.style.left = (ir.x + sel.px * ir.w) + 'px';
    div.style.top = (ir.y + sel.py * ir.h) + 'px';
    div.style.width = (sel.pw * ir.w) + 'px';
    div.style.height = (sel.ph * ir.h) + 'px';
    div.innerHTML = `<span class="sel-label">${sel.label}</span><span class="sel-delete" onclick="event.stopPropagation(); deleteSelection(${globalIdx})">X</span>`;
    div.onclick = () => {
      currentSelection = { px: sel.px, py: sel.py, pw: sel.pw, ph: sel.ph };
      showZoomPanel();
    };
    selRectsContainer.appendChild(div);
  });
}

// ============================================================
// NOTES
// ============================================================
function saveNotes() {
  localStorage.setItem('stereo-madness-notes', JSON.stringify(notes));
}

function addNote() {
  const text = noteInput.value.trim();
  if (!text) return;
  const tags = tagInput.value.split(',').map(t => t.trim()).filter(t => t);

  const noteObj = {
    frame: currentFrame,
    time: frameToTime(currentFrame),
    text,
    tags,
    scene: scenes.indexOf(getScene(currentFrame)) + 1
  };

  // Attach selection thumbnail if pending
  if (noteInput.dataset.pendingThumb) {
    noteObj.thumb = noteInput.dataset.pendingThumb;
    noteObj.region = JSON.parse(noteInput.dataset.pendingRegion);
    delete noteInput.dataset.pendingThumb;
    delete noteInput.dataset.pendingRegion;
  }

  notes.push(noteObj);
  notes.sort((a, b) => a.frame - b.frame);
  saveNotes();
  renderNotes();
  updateMarkers();
  noteInput.value = '';
  noteInput.placeholder = "Type your observation about this frame...\nWhat obstacles do you see? What patterns?";
  closeZoom();
}

function deleteNote(idx) {
  notes.splice(idx, 1);
  saveNotes();
  renderNotes();
  updateMarkers();
}

function renderNotes(filter) {
  if (filter === 'scenes') { renderScenesList(); return; }

  if (notes.length === 0) {
    notesList.innerHTML = `<div style="text-align:center; color:#555; padding: 30px 10px; font-size:13px;">
      No notes yet.<br>Scrub to a frame and add your observations below.<br><br>
      Tip: Use <b>Select</b> to crop a region, then add a note with the cropped thumbnail attached.
    </div>`;
    return;
  }

  notesList.innerHTML = notes.map((n, i) => `
    <div class="note-card ${n.frame === currentFrame ? 'active' : ''}" data-frame="${n.frame}" onclick="goToFrame(${n.frame})">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <span class="note-time">Scene ${n.scene} &bull; ${n.time} &bull; Frame ${n.frame}</span>
        <span style="cursor:pointer; color:#666; font-size:14px;" onclick="event.stopPropagation(); deleteNote(${i})" title="Delete note">&times;</span>
      </div>
      <div class="note-text">${escapeHtml(n.text)}</div>
      ${n.thumb ? `<div class="note-thumb" onclick="event.stopPropagation(); viewThumb(${i})"><img src="${n.thumb}" alt="crop"></div>` : ''}
      ${n.tags.length ? `<div class="note-tags">${n.tags.map(t => `<span class="note-tag">${escapeHtml(t)}</span>`).join('')}</div>` : ''}
    </div>
  `).join('');
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function viewThumb(noteIdx) {
  const n = notes[noteIdx];
  if (!n || !n.region) return;
  goToFrame(n.frame);
  currentSelection = { px: n.region.px, py: n.region.py, pw: n.region.pw, ph: n.region.ph };
  setTimeout(() => showZoomPanel(), 100);
}

function renderScenesList() {
  notesList.innerHTML = scenes.map((s, i) => {
    const count = notes.filter(n => n.frame >= s.start && n.frame <= s.end).length;
    const selCount = selections.filter(sl => sl.frame >= s.start && sl.frame <= s.end).length;
    return `
      <div class="note-card" onclick="goToFrame(${s.start})" style="border-left: 3px solid ${s.color};">
        <div style="display:flex; justify-content:space-between;">
          <span class="note-time" style="color:${s.color}">Scene ${i + 1}</span>
          <span style="font-size:11px; color:#666;">Frames ${s.start}-${s.end} &bull; ${count} notes &bull; ${selCount} selections</span>
        </div>
        <div class="note-text" style="font-weight:600;">${s.title}</div>
        <div class="note-text" style="font-size:11px; color:#888; margin-top:4px;">${s.desc}</div>
      </div>
    `;
  }).join('');
}

function updateMarkers() {
  markerTrack.innerHTML = '';
  scenes.forEach((s, i) => {
    if (i === 0) return;
    const pct = ((s.start - 1) / (TOTAL_FRAMES - 1)) * 100;
    const dot = document.createElement('div');
    dot.className = 'marker-dot scene-marker';
    dot.style.left = `calc(${pct}% - 1px)`;
    dot.title = `Scene ${i + 1}: ${s.title}`;
    dot.onclick = () => goToFrame(s.start);
    markerTrack.appendChild(dot);
  });
  notes.forEach((n) => {
    const pct = ((n.frame - 1) / (TOTAL_FRAMES - 1)) * 100;
    const dot = document.createElement('div');
    dot.className = 'marker-dot';
    dot.style.left = `calc(${pct}% - 2px)`;
    dot.title = n.text.substring(0, 40);
    dot.onclick = () => goToFrame(n.frame);
    markerTrack.appendChild(dot);
  });
}

// ============================================================
// DRAWING
// ============================================================
function toggleDraw() {
  if (selectMode) toggleSelect();
  drawMode = !drawMode;
  drawCanvas.classList.toggle('active', drawMode);
  document.getElementById('btnDraw').classList.toggle('active', drawMode);
  updateToolIndicator();
}

function clearAll() {
  drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
  // Clear selections for current frame
  selections = selections.filter(s => s.frame !== currentFrame);
  saveSelections();
  renderSelectionRects();
  clearSelectOverlay();
  closeZoom();
}

drawCanvas.addEventListener('mousedown', e => {
  if (!drawMode) return;
  isDrawing = true;
  const rect = drawCanvas.getBoundingClientRect();
  lastDrawPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
});
drawCanvas.addEventListener('mousemove', e => {
  if (!isDrawing || !drawMode) return;
  const rect = drawCanvas.getBoundingClientRect();
  const pos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  drawCtx.strokeStyle = '#ff0';
  drawCtx.lineWidth = 3;
  drawCtx.lineCap = 'round';
  drawCtx.beginPath();
  drawCtx.moveTo(lastDrawPos.x, lastDrawPos.y);
  drawCtx.lineTo(pos.x, pos.y);
  drawCtx.stroke();
  lastDrawPos = pos;
});
drawCanvas.addEventListener('mouseup', () => { isDrawing = false; });
drawCanvas.addEventListener('mouseleave', () => { isDrawing = false; });

// ============================================================
// EXPORT
// ============================================================
function exportNotes() {
  let text = '# Stereo Madness - Video Analysis Notes\n';
  text += `# Total frames: ${TOTAL_FRAMES} | Duration: ~91s | FPS: ${FPS}\n`;
  text += `# Selections: ${selections.length} | Notes: ${notes.length}\n\n`;

  scenes.forEach((s, i) => {
    text += `## Scene ${i + 1}: ${s.title}\n`;
    text += `Frames ${s.start}-${s.end} | ${s.desc}\n\n`;
    const sceneNotes = notes.filter(n => n.frame >= s.start && n.frame <= s.end);
    if (sceneNotes.length) {
      sceneNotes.forEach(n => {
        text += `  [${n.time} | Frame ${n.frame}] ${n.text}`;
        if (n.tags.length) text += ` (${n.tags.join(', ')})`;
        if (n.region) {
          const iw = 640, ih = 296;
          text += ` [Region: ${Math.round(n.region.px*iw)},${Math.round(n.region.py*ih)} ${Math.round(n.region.pw*iw)}x${Math.round(n.region.ph*ih)}]`;
        }
        text += '\n';
      });
    } else {
      text += '  (no notes)\n';
    }
    text += '\n';
  });

  document.getElementById('exportText').value = text;
  document.getElementById('exportArea').classList.add('active');
  document.getElementById('exportOverlay').classList.add('active');
}

function closeExport() {
  document.getElementById('exportArea').classList.remove('active');
  document.getElementById('exportOverlay').classList.remove('active');
}

function copyExport() {
  document.getElementById('exportText').select();
  document.execCommand('copy');
  alert('Copied to clipboard!');
}

// ============================================================
// EVENT LISTENERS
// ============================================================
scrubber.addEventListener('input', e => goToFrame(parseInt(e.target.value)));

document.getElementById('btnPrev').addEventListener('click', () => goToFrame(currentFrame - 1));
document.getElementById('btnNext').addEventListener('click', () => goToFrame(currentFrame + 1));
document.getElementById('btnPlay').addEventListener('click', togglePlay);
document.getElementById('btnAddNote').addEventListener('click', addNote);
document.getElementById('btnSelect').addEventListener('click', toggleSelect);
document.getElementById('btnDraw').addEventListener('click', toggleDraw);
document.getElementById('btnClearDraw').addEventListener('click', clearAll);
document.getElementById('btnExport').addEventListener('click', exportNotes);

document.querySelectorAll('.speed-btn').forEach(btn => {
  btn.addEventListener('click', () => setSpeed(parseFloat(btn.dataset.speed)));
});

document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    renderNotes(btn.dataset.tab);
  });
});

document.addEventListener('keydown', e => {
  if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
    if (e.key === 'Enter' && !e.shiftKey && e.target === noteInput) {
      e.preventDefault();
      addNote();
    }
    return;
  }
  switch(e.key) {
    case 'ArrowLeft': e.preventDefault(); goToFrame(currentFrame - 1); break;
    case 'ArrowRight': e.preventDefault(); goToFrame(currentFrame + 1); break;
    case ' ': e.preventDefault(); togglePlay(); break;
    case 'n': case 'N': noteInput.focus(); break;
    case 's': case 'S': toggleSelect(); break;
    case 'd': case 'D': toggleDraw(); break;
    case 'Escape':
      if (selectMode) toggleSelect();
      if (drawMode) toggleDraw();
      closeZoom();
      closeExport();
      break;
  }
});

window.addEventListener('resize', () => {
  resizeCanvases();
  renderSelectionRects();
});

// ============================================================
// INIT
// ============================================================
goToFrame(1);
renderNotes();
updateMarkers();
</script>
</body>
</html>
